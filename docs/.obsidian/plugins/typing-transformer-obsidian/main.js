/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name2 in all)
    __defProp(target, name2, { get: all[name2], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
var __toBinary = /* @__PURE__ */ (() => {
  var table = new Uint8Array(128);
  for (var i = 0; i < 64; i++)
    table[i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i * 4 - 205] = i;
  return (base64) => {
    var n = base64.length, bytes = new Uint8Array((n - (base64[n - 1] == "=") - (base64[n - 2] == "=")) * 3 / 4 | 0);
    for (var i2 = 0, j = 0; i2 < n; ) {
      var c0 = table[base64.charCodeAt(i2++)], c1 = table[base64.charCodeAt(i2++)];
      var c2 = table[base64.charCodeAt(i2++)], c3 = table[base64.charCodeAt(i2++)];
      bytes[j++] = c0 << 2 | c1 >> 4;
      bytes[j++] = c1 << 4 | c2 >> 2;
      bytes[j++] = c2 << 6 | c3;
    }
    return bytes;
  };
})();

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => TypingTransformer
});
module.exports = __toCommonJS(main_exports);
var import_obsidian2 = require("obsidian");
var import_state2 = require("@codemirror/state");
var import_view3 = require("@codemirror/view");

// wasm-binary:/home/runner/work/typing-transformer-obsidian/typing-transformer-obsidian/liberty-web/charliberty_bg.wasm
var charliberty_bg_default = __toBinary("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wABBKEHQnsAAEH8ACyADIAIgBSACEI0BAAsgDSALIAIgCxCNAQALIA0gCyADIAsQjQEAC9kNAQR/IwBB8AFrIgIkACACIABBLGooAgAiBCAAQTRqKAIAIgMgBCADSxsgBCAAQShqKAIAGzYC0AEgAkHkAGpBATYCACACQgE3AlQgAkHojcAANgJQIAJBAzYC5AEgAiACQeABajYCYCACIAJB0AFqNgLgASACQagBaiACQdAAahArIAIoArABIQMgAigCrAEEQCACKAKoARATC0EAIQQgAkEANgIoIAJCATcDIAJAIANFDQAgA0F/aiEDA0AgBCAFRgR/IAJBIGogBBBRIAIoAigFIAULIAIoAiBqQSA6AAAgAiACKAIoQQFqIgU2AiggA0UNASADQX9qIQMgAigCJCEEDAALAAsCQAJAIAAoAjwEQCACIABBPGo2AtABIAJB5ABqQQE2AgAgAkICNwJUIAJB2I3AADYCUCACQQQ2AuQBIAIgAkHgAWo2AmAgAiACQdABajYC4AEgAkGoAWogAkHQAGoQKyACKAKoAQ0BCyACQQA2AjggAkIBNwMwDAELIAJBOGogAkGwAWooAgA2AgAgAiACKQOoATcDMAsCQAJAIABBKGooAgAEQCAAKAJUDQELIAIgAEEwaigCACIENgLEASACIABBLGooAgAiAzYCwAEgAiAENgLMASACIAM2AsgBIAJB0AFqIAAQHiACQeABaiAAECogAkGEAWpBATYCACACQfwAakEBNgIAIAJB9ABqQQE2AgAgAkHsAGpBAzYCACACQeQAakEDNgIAIAJB3ABqQQE2AgAgAkG8AWpBBzYCACACQbQBakEMNgIAIAIgAEHIAGo2AnAgAiACQcgBakEEcjYCaCACQQE2AlQgAkHIgcAANgKwASACQQw2AqwBIAJB6IDAADYCqAEgAiACQeABajYCgAEgAiACQdABajYCeCACIAJBwAFqNgJgIAIgAkEwajYCWCACIAJBIGo2AlAgAiACQdAAajYCuAEgAkEQaiACQagBahArIAIoAuQBBEAgAigC4AEQEwsgAigC1AFFDQEgAigC0AEQEwwBCyAAQTRqKAIAIQMgAiAAQThqKAIANgJEIAIgAzYCQCACIABB1ABqNgJMIABBMGooAgAhBCADIABBLGooAgAiA2tBAU0EQCACIAIoAig2AqQBIAIgBDYCxAEgAiADNgLAASACIAQ2AswBIAIgAzYCyAEgAkHQAWogABAeIAJB4AFqIAAQKiACQQhqIAJBpAFqELQBIAJBlAFqQQE2AgAgAkGMAWpBATYCACACQYQBakEENgIAIAJB/ABqQQE2AgAgAkH0AGpBAzYCACACQewAakEDNgIAIAJB5ABqQQM2AgAgAkHcAGpBATYCACACIABByABqNgJ4IAIgAkHIAWpBBHI2AnAgAkEBNgJUIAIgAikDCDcDmAEgAiACQeABajYCkAEgAiACQdABajYCiAEgAiACQcwAajYCgAEgAiACQUBrNgJoIAIgAkHAAWo2AmAgAiACQTBqNgJYIAIgAkEgajYCUCACQbwBakEKNgIAIAJBtAFqQQ42AgAgAkGYisAANgKwASACQQ42AqwBIAJBqInAADYCqAEgAiACQdAAajYCuAEgAkEQaiACQagBahArIAIoAuQBBEAgAigC4AEQEwsgAigC1AFFDQEgAigC0AEQEwwBCyACIAIoAig2AqQBIAIgBDYCxAEgAiADNgLAASACIAQ2AswBIAIgAzYCyAEgAkHQAWogABAeIAJB4AFqIAAQKiACIAJBpAFqELQBIAJBlAFqQQE2AgAgAkGMAWpBATYCACACQYQBakEENgIAIAJB/ABqQQE2AgAgAkH0AGpBAzYCACACQewAakEDNgIAIAJB5ABqQQM2AgAgAkHcAGpBATYCACACIABByABqNgJ4IAIgAkHIAWpBBHI2AnAgAkEBNgJUIAIgAikDADcDmAEgAiACQeABajYCkAEgAiACQdABajYCiAEgAiACQcwAajYCgAEgAiACQUBrNgJoIAIgAkHAAWo2AmAgAiACQTBqNgJYIAIgAkEgajYCUCACQbwBakEKNgIAIAJBtAFqQQ82AgAgAkHIhcAANgKwASACQQ82AqwBIAJB0ITAADYCqAEgAiACQdAAajYCuAEgAkEQaiACQagBahArIAIoAuQBBEAgAigC4AEQEwsgAigC1AFFDQAgAigC0AEQEwsgAigCNARAIAIoAjAQEwsgAigCJARAIAIoAiAQEwsgAkHkAGpBATYCACACQQE2AqwBIAJCATcCVCACQeiNwAA2AlAgAiACQRBqNgKoASACIAJBqAFqNgJgIAEgAkHQAGoQbiACKAIUBEAgAigCEBATCyAC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QQxsaiICIAg2AgggAkEANgIEIAJBADoAACABQRRqIgIgAigCAEEBaiICNgIAIAEoAjAhAwsgAUEsaigCACABQSBqKAIAaiABLQBZIgsEQCABQQA6AFkLQQAgAyAIRhshDiABKAIAIQwCQAJAAkACQAJAAkAgAUEIaigCACIKQQFqIgMgCkkgAyABQQRqKAIAIgRLcg0AIAogDGotAABB4ABHDQAgAUEIaiADNgIAIAlBCGogARAlIAkoAgwhASAJKAIIRQRAA0AgCSABECUgCSgCBCEBIAkoAgBFDQALCyABQQhqKAIAIg1BAWoiAyANSQ0AIAMgASgCBEsNACABKAIAIA1qLQAAQeAARw0AIAFBCGogAzYCACALBEAgASALOgBZCyABLQBYIgJBAUYNAQwCCyABIAo2AgggASAENgIEIAEgDDYCACABKAIUIAJPBEAgASACNgIUCyALBEAgASALOgBZC0EBIQMgAS0AWCICQQFGDQICQCABLQBZRQ0AIAFBLGooAgAiCyABQSBqKAIAIgRqQQAgASgCMCIKIAhGIgwbIg0gDktBACANIA5rQQFGGw0AAkAgDEUEQCAKIAhPDQIgASAINgIwQQAhBCABQSxqQQA2AgAgAUEgakEANgIADAELIAQgBU8EQCABQSBqIAU2AgAgBSEECyALIAdJDQAgAUEsaiAHNgIACyABQRxqKAIAIARGBH8gAUEYaiAEEFEgASgCIAUgBAsgASgCGGpBCToAACABIAEoAiBBAWo2AiAgAS0AWCECCyACQf8BcUECRw0CIAEtAFlFDQIgASgCFCAGSQ0CIAEgBjYCFAwCCyABLQBZRQRAQQAhAwwCC0EAIQMgAUEsaigCACICIAFBIGooAgAiCmpBACABKAIwIgwgCEYiDRsiBCAOS0EAIAQgDmtBAUYbDQECQCANRQRAIAwgCE8NAyABIAg2AjBBACECIAFBLGpBADYCACABQSBqQQA2AgAMAQsgCiAFTwRAIAFBIGogBTYCAAsgAiAHSQ0AIAFBLGogBzYCACAHIQILIAFBKGooAgAgAkYEfyABQSRqIAIQUSABKAIsBSACCyABKAIkakEJOgAAIAEgASgCLEEBajYCLCABLQBYIQILQQAhAyACQf8BcUECRw0AIAEtAFlFDQAgAUEUaigCACIFIAZNDQEgASgCDCICIAZB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hgEACyAAIAFBACAFEI0BAAsgBCACIAMgBRs2AiggBEHEAGpBAzYCACAEQdwAakHCADYCACAEQdQAakHCADYCACAEQgM3AjQgBEGQr8AANgIwIARBAzYCTCAEIARByABqNgJAIAQgBEEYajYCWCAEIARBEGo2AlAgBCAEQShqNgJIIARBMGpBqK/AABCGAQALIAMgBRDNAQALQfipwABBK0GMsMAAEH8ACyAAIAEgAyABEI0BAAvxCAEPfyABQQhqKAIAIgMgASgCMCIMRgRAIAFBLGooAgAhCyABQSBqKAIAIQkLIAFBDGohECABQRRqKAIAIQQCfyABLQBYQQJHBEAgBCEFIAMMAQsgBCEFIAMgAS0AWUUNABogBCICIAFBEGooAgBGBEAgECAEEEkgAUEUaigCACECCyABKAIMIAJBDGxqIgIgAzYCCCACQQA2AgQgAkEAOgAAIAFBFGoiAiACKAIAQQFqIgU2AgAgASgCMCEMIAFBCGooAgALIQJBASENIAFBLGooAgAhCiABQSBqKAIAIQcCQAJAAkACfwJAAkACQCACQQFqIgYgAkkNACAGIAFBBGooAgAiDksNACAGQX9GIAEoAgAiDyACai0AAEEgR3INACACQQJqIgggDksNACAGIA9qLQAAQSBHDQAgAUEIaiAINgIAAkAgCEF/Rg0AIAJBA2oiBiAOSw0AIAggD2otAABBIEcNACABQQhqIAY2AgACQCAGQX9GDQAgAkEEaiIIIA5LDQAgBiAPai0AAEEgRw0AIAFBCGogCDYCACAIQX9GIAJBBWogDktyDQAgAkEGaiECIAFBCGohBgNAIAIgD2pBfmotAABBIEcNASAGIAJBf2o2AgAgAkUNASACIA5NIAJBAWohAg0ACwsgAUEUaiAFNgIACyABLQBYIgJBAUYNAQwCCyABQRRqIAU2AgAgAS0AWCICQQFGDQMCQCABLQBZRQ0AAkAgAyAMRwRAIAwgA08NAiABIAM2AjBBACEHIAFBLGpBADYCACABQSBqQQA2AgAMAQsgByAJTwRAIAFBIGogCTYCACAJIQcLIAogC0kNACABQSxqIAs2AgALIAFBHGooAgAgB0YEfyABQRhqIAcQUSABQSBqKAIABSAHCyABKAIYakEFOgAAIAFBIGoiAiACKAIAQQFqNgIAIAEtAFghAgsgAkH/AXFB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AiABQQZ2QcABcjoADEECDAILIAAoAggiAyAAQQRqKAIARgRAIAAgAxBVIAAoAgghAwsgACADQQFqNgIIIAAoAgAgA2ogAToAAAwCCyABQYCABE8EQCACIAFBP3FBgAFyOgAPIAIgAUESdkHwAXI6AAwgAiABQQZ2QT9xQYABcjoADiACIAFBDHZBP3FBgAFyOgANQQQMAQsgAiABQT9xQYABcjoADiACIAFBDHZB4AFyOgAMIAIgAUEGdkE/cUGAAXI6AA1BAwshASAAQQRqKAIAIABBCGoiBCgCACIDayABSQRAIAAgAyABEFQgBCgCACEDCyAAKAIAIANqIAJBDGogARDPARogBCABIANqNgIACyACQRBqJAAL1AIBA38jAEEQayICJAACQAJ/AkACQCABQYABTwRAIAJBADYCDCABQYAQSQ0BIAFBgIAETw0CIAIgAUE/cUGAAXI6AA4gAiABQQx2QeABcjoADCACIAFBBnZBP3FBgAFyOgANQQMMAwsgACgCCCIDIABBBGooAgBGBEAgACADEFUgACgCCCEDCyAAIANBAWo2AgggACgCACADaiABOgAADAMLIAIgAUE/cUGAAXI6AA0gAiABQQZ2QcABcjoADEECDAELIAIgAUE/cUGAAXI6AA8gAiABQRJ2QfABcjoADCACIAFBBnZBP3FBgAFyOgAOIAIgAUEMdkE/cUGAAXI6AA1BBAshASAAQQRqKAIAIABBCGoiBCgCACIDayABSQRAIAAgAyABEFQgBCgCACEDCyAAKAIAIANqIAJBDGogARDPARogBCABIANqNgIACyACQRBqJAALtgIBB38CQCACQQ9NBEAgACEDDAELIABBACAAa0EDcSIEaiEFIAQEQCAAIQMgASEGA0AgAyAGLQAAOgAAIAZBAWohBiADQQFqIgMgBUkNAAsLIAUgAiAEayIIQXxxIgdqIQMCQCABIARqIgRBA3EEQCAHQQFIDQEgBEEDdCICQRhxIQkgBEF8cSIGQQRqIQFBACACa0EYcSECIAYoAgAhBgNAIAUgBiAJdiABKAIAIgYgAnRyNgIAIAFBBGohASAFQQRqIgUgA0kNAAsMAQsgB0EBSA0AIAQhAQNAIAUgASgCADYCACABQQRqIQEgBUEEaiIFIANJDQALCyAIQQNxIQIgBCAHaiEBCyACBEAgAiADaiEC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C0GMxMAAIAUgBnI2AgAgAyAANgIADAMLIAEgAnQhBQNAIAMgBUEddkEEcWpBEGoiBigCACICRQ0CIAVBAXQhBSACIgMQxgEgAUcNAAsLIAIoAggiASAENgIMIAIgBDYCCCAEIAI2AgwgBCABNgIIIABBADYCGA8LIAYgADYCAAsgACADNgIYIAQgBDYCCCAEIAQ2AgwL2wICBH8CfiMAQUBqIgIkAEEBIQQCQCAALQAEDQAgAC0ABSEEAkACQAJAIAAoAgAiAygCACIFQQRxRQRAIAQNAQwDCyAEDQFBASEEIAMoAhhB/arAAEEBIANBHGooAgAoAgwRAgANAyADKAIAIQUMAQtBASEEIAMoAhhB8arAAEECIANBHGooAgAoAgwRAgBFDQEMAgtBASEEIAJBAToAFyACQTRqQdCqwAA2AgAgAkEQaiACQRdqNgIAIAIgBTYCGCACIAMpAhg3AwggAykCCCEGIAMpAhAhByACIAMtACA6ADggAiADKAIENgIcIAIgBzcDKCACIAY3AyAgAiACQQhqNgIwIAEgAkEYakGsk8AAKAIAEQEADQEgAigCMEHvqsAAQQIgAigCNCgCDBECACEEDAELIAEgA0Gsk8AAKAIAEQEAIQQLIABBAToABSAAIAQ6AAQgAkFAayQAC7YCAQV/IAAoAhghBAJAAkAgACAAKAIMRgRAIABBFEEQIABBFGoiASgCACIDG2ooAgAiAg0BQQAhAQwCCyAAKAIIIgIgACgCDCIBNgIMIAEgAjYCCAwBCyABIABBEGogAxshAwNAIAMhBSACIgFBFGoiAygCACICRQRAIAFBEGohAyABKAIQIQILIAINAAsgBUEANgIACwJAIARFDQACQCAAIAAoAhxBAnRBmMbAAGoiAigCAEcEQCAEQRBBFCAEKAIQIABGG2ogATYCACABDQEMAgsgAiABNgIAIAENAEGMxMAAQYzEwAAoAgBBfiAAKAIcd3E2AgAPCyABIAQ2AhggACgCECICBEAgASACNgIQIAIgATYCGAsgAEEUaigCACIARQ0AIAFBFGogADYCACAAIAE2AhgLC28BDH9BuMfAACgCACICRQRAQcjHwABB/x82AgBBAA8LQbDHwAAhBgNAIAIiASgCCCECIAEoAgQhAyABKAIAIQQgAUEMaigCABogASEGIAVBAWohBSACDQAL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DQEgAygCBCAAEMoBAAsgAygCBCEBIABBBGogBDYCACAAIAE2AgAgA0EgaiQADwsQhQEAC64BAQN/IwBBIGsiAiQAAkAgAUEBaiIDIAFJDQAgAEEEaigCACIBQQF0IgQgAyAEIANLGyIDQQggA0EISxshAyACIAEEfyACIAE2AhQgAiAAKAIANgIQQQEFQQALNgIYIAIgAyACQRBqEFkgAigCAARAIAJBCGooAgAiAEUNASACKAIEIAAQygEACyACKAIEIQEgAEEEaiADNgIAIAAgATYCACACQSBqJAAPCxCFAQALswEBBH8jAEEgayIDJAAgA0EIaiABIAIQBQJAIAMoAghFBEAgA0EUaigCACEEIANBEGooAgAhBiADKAIMIQUgAgRAIAEQEwsCQCAGIARNDQAgBEUEQCAFEBNBASEFDAELIAUgBkEBIAQQpwEiBUUNAgsgACAENgIEIAAgBTYCACADQSBqJAAPCyADIAMoAgw2AhxB5aHAAEErIANBHGpBkKLAAEGsosAAEGMACyAEQQEQygEAC6MBAQJ/IAFFBEBBAA8LIAFBA3EhAgJAIAFBf2pBA0kEQEEAIQEMAQsgAUF8cSEDQQAhAQNAIAEgACwAAEG/f0pqIABBAWosAABBv39KaiAAQQJqLAAAQb9/SmogAEEDaiwAAEG/f0pqIQEgAEEEaiEAIANBfGoiAw0ACwsgAgRAA0AgASAALAAAQb9/SmohASAAQQFqIQAgAkF/aiICDQALCyABC6wBAQN/IwBBMGsiAiQAIAFBBGohAyABKAIERQRAIAEoAgAhASACQRBqIgRBADYCACACQgE3AwggAiACQQhqNgIUIAJBKGogAUEQaikCADcDACACQSBqIAFBCGopAgA3AwAgAiABKQIANwMYIAJBFGpB9KTAACACQRhqECQaIANBCGogBCgCADYCACADIAIpAwg3AgALIABB0KbAADYCBCAAIAM2AgAgAkEwaiQAC5ABAQJ/AkACfwJAAkACQAJ/QQEiAyABQQBIDQAaIAIoAghFDQIgAigCBCIEDQEgAQ0DQQEMBAshA0EAIQEMBAsgAigCACAEQQEgARCnAQwCCyABDQBBAQwBCyABQQEQrwELIgIEQCAAIAI2AgRBACEDDAELIAAgATYCBEEBIQELIAAgAzYCACAAQQhqIAE2AgALpwEBAn8C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QYCAgAE2AgALbwEEfyMAQSBrIgIkAEEBIQMCQCAAIAEQOw0AIAFBHGooAgAhBCABKAIYIAJBHGpBADYCACACQaipwAA2AhggAkIBNwIMIAJBrKnAADYCCCAEIAJBCGoQJA0AIABBBGogARA7IQMLIAJBIGokACADC2YBAX8jAEEgayICJAAgACgCACEAIAJBCGogAUHko8AAQQAQigEgAiAANgIYIAIgAEEEajYCHCACQQhqIAJBGGpB5KPAABA8IAJBCGogAkEcakHko8AAEDwgAkEIahBgIAJBIGokAAtwAQF/IwBBMGsiAiQAIAIgATYCBCACIAA2AgAgAkEcakECNgIAIAJBLGpBAzYCACACQgM3AgwgAkGQqcAANgIIIAJBAzYCJCACIAJBIGo2AhggAiACQQRqNgIoIAIgAjYCICACQQhqQdSXwAAQhgEAC3ABAX8jAEEwayICJAAgAiABNgIEIAIgADYCACACQRxqQQI2AgAgAkEsakEDNgIAIAJCAjcCDCACQZitwAA2AgggAkEDNgIkIAIgAkEgajYCGCACIAJBBGo2AiggAiACNgIgIAJBCGpByK3AABCGAQALcAEBfyMAQTBrIgIkACACIAE2AgQgAiAANgIAIAJBHGpBAjYCACACQSxqQQM2AgAgAkICNwIMIAJBrK7AADYCCCACQQM2AiQgAiACQSBqNgIYIAIgAkEEajYCKCACIAI2AiAgAkEIakG8rsAAEIYBAAtwAQF/IwBBMGsiAiQAIAIgATYCBCACIAA2AgAgAkEcakECNgIAIAJBLGpBAzYCACACQgI3AgwgAkHorcAANgIIIAJBAzYCJCACIAJBIGo2AhggAiACQQRqNgIoIAIgAjYCICACQQhqQfitwAAQhgEAC20BAX8jAEEwayIDJAAgAyABNgIEIAMgADYCACADQRxqQQI2AgAgA0EsakEDNgIAIANCAjcCDCADQeipwAA2AgggA0EDNgIkIAMgA0EgajYCGCADIAM2AiggAyADQQRqNgIgIANBCGogAhCGAQALVgECfyMAQSBrIgIkACAAQRxqKAIAIQMgACgCGCACQRhqIAFBEGopAgA3AwAgAkEQaiABQQhqKQIANwMAIAIgASkCADcDCCADIAJBCGoQJCACQSBqJAALWwECfyMAQRBrIgIkACAAKAIAIgAoAgghAyAAKAIAIQAgAiABEI8BIAMEQANAIAIgADYCDCACIAJBDGoQPiAAQQFqIQAgA0F/aiIDDQALCyACEJIBIAJBEGokAAtZAQF/IwBBIGsiAiQAIAIgACgCADYCBCACQRhqIAFBEGopAgA3AwAgAkEQaiABQQhqKQIANwMAIAIgASkCADcDCCACQQRqQZykwAAgAkEIahAkIAJBIGokAAtZAQF/IwBBIGsiAiQAIAIgACgCADYCBCACQRhqIAFBEGopAgA3AwAgAkEQaiABQQhqKQIANwMAIAIgASkCADcDCCACQQRqQfSkwAAgAkEIahAkIAJBIGokAAtoACMAQTBrIgEkAEHQw8AALQAABEAgAUEcakEBNgIAIAFCAjcCDCABQdylwAA2AgggAUEDNgIkIAEgADYCLCABIAFBIGo2AhggASABQSxqNgIgIAFBCGpBhKbAABCGAQALIAFBMGokAAtZAQF/IwBBIGsiAiQAIAIgACgCADYCBCACQRhqIAFBEGopAgA3AwAgAkEQaiABQQhqKQIANwMAIAIgASkCADcDCCACQQRqQZinwAAgAkEIahAkIAJBIGokAAtoAQJ/IAEoAgAhAwJAAkACQCABQQhqKAIAIgFFBEBBASECDAELIAFBf0wNASABQQEQrwEiAkUNAgsgAiADIAEQzwEhAiAAIAE2AgggACABNgIEIAAgAjYCAA8LEIUBAAsgAUEBEMoBAAtZAQF/IwBBIGsiAiQAIAIgACgCADYCBCACQRhqIAFBEGopAgA3AwAgAkEQaiABQQhqKQIANwMAIAIgASkCADcDCCACQQRqQcyswAAgAkEIahAkIAJBIGokAAtWAQF/IwBBIGsiAiQAIAIgADYCBCACQRhqIAFBEGopAgA3AwAgAkEQaiABQQhqKQIANwMAIAIgASkCADcDCCACQQRqQcyswAAgAkEIahAkIAJBIGokAAtaAQF/IwBBEGsiAiQAAn8gACgCACIAKAIARQRAIAFB5JTAAEEEEJ8BDAELIAIgAUHQlMAAQQQQigEgAiAANgIMIAIgAkEMakHUlMAAEDwgAhBgCyACQRBqJAALVgECfyABKAIAIQIgAUEANgIAAkAgAgRAIAEoAgQhA0EIQQQQrwEiAUUNASABIAM2AgQgASACNgIAIABB6JTAADYCBCAAIAE2AgAPCwALQQhBBBDKAQALUQECfyAAQQhqKAIAIQIgAEEgaigCACIBIABBHGooAgBGBEAgAEEYaiABEEsgACgCICEBCyAAKAIYIAFBAnRqIAI2AgAgACAAKAIgQQFqNgIgC08BAn8gACgCACIDQQRqKAIAIANBCGoiBCgCACIAayACSQRAIAMgACACEFQgBCgCACEACyADKAIAIABqIAEgAhDPARogBCAAIAJqNgIAQQALTAACQCADRQ0AAkAgAiADTQRAIAIgA0cNAQwCCyABIANqLAAAQb9/Sg0BCyAAQQA2AgAPCyAAIAI2AgQgACABNgIAIABBCGogAzYCAAtDAQN/AkAgAkUNAANAIAAtAAAiBCABLQAAIgVGBEAgAEEBaiEAIAFBAWohASACQX9qIgINAQwCCwsgBCAFayEDCyADC0sAAkACfyABQYCAxABHBEBBASAAKAIYIAEgAEEcaigCACgCEBEBAA0BGgsgAg0BQQALDwsgACgCGCACIAMgAEEcaigCACgCDBECAAtIAQF/IwBBEGsiAiQAIAJBCGogARCCASACIAIoAgggAigCDCgCGBEAACACKAIEIQEgACACKAIANgIAIAAgATYCBCACQRBqJAALSAEBfyMAQSBrIgMkACADQRRqQQA2AgAgA0GoqcAANgIQIANCATcCBCADIAE2AhwgAyAANgIYIAMgA0EYajYCACADIAIQhgEAC0kBAX8jAEEgayICJAAgAkEUakEBNgIAIAJCATcCBCACQbSqwAA2AgAgAkHCADYCHCACIAA2AhggAiACQRhqNgIQIAIgARCGAQALRgECfyABKAIEIQIgASgCACEDQQhBBBCvASIBRQRAQQhBBBDKAQALIAEgAjYCBCABIAM2AgAgAEHgpsAANgIEIAAgATYCAAs+AQF/IwBBEGsiAiQAIAJBCGogASABKAIAKAIEEQAAIAIoAgwhASAAIAIoAgg2AgAgACABNgIEIAJBEGokAAs5AQF/IAFBEHZAACECIABBADYCCCAAQQAgAUGAgHxxIAJBf0YiARs2AgQgAEEAIAJBEHQgARs2AgALaAEDfyMAQRBrIgEkACAAKAIMIgJFBEBBjKXAAEErQbCmwAAQfwALIAAoAggiA0UEQEGMpcAAQStBwKbAABB/AAsgASACNgIIIAEgADYCBCABIAM2AgAgASgCACABKAIEIAEoAggQYQALQAEBfyMAQSBrIgAkACAAQRxqQQA2AgAgAEGwp8AANgIYIABCATcCDCAAQfCnwAA2AgggAEEIakH4p8AAEIYBAAs/AQF/IwBBIGsiAiQAIAJBAToAGCACIAE2AhQgAiAANgIQIAJBpKrAADYCDCACQaipwAA2AgggAkEIahCEAQALKwACQCAAQXxLDQAgAEUEQEEEDwsgACAAQX1JQQJ0EK8BIgBFDQAgAA8LAAswAQF/IwBBEGsiAiQAIAJBCGogABCCASACKAIIIAEgAigCDCgCEBEBACACQRBqJAALPAAgACgCACEAIAEtAABBEHFBBHZFBEAgAS0AAEEgcUEFdkUEQCAAIAEQvAEPCyAAIAEQXA8LIAAgARBbCzQAIAAgASgCGCACIAMgAUEcaigCACgCDBECADoACCAAIAE2AgAgACADRToACSAAQQA2AgQLNQEBf0HkAEEEEK8BIgFFBEBB5ABBBBDKAQALIAFBoKPAADYCACABQQRqIABB4AAQzwEaIAELLgEBfyMAQRBrIgMkACADIAE2AgwgAyAANgIIIANBCGpBjJPAAEEAIAJBARBPAAtAAQF/IwBBEGsiBCQAIAQgAzYCDCAEIAI2AgggBCABNgIEIAQgADYCACAEKAIAIAQoAgQgBCgCCCAEKAIMEA8ACzAAIAEoAhggAiADIAFBHGooAgAoAgwRAgAhAiAAQQA6AAUgACACOgAEIAAgATYCAAs1AQF/IAEoAhhB/qrAAEEBIAFBHGooAgAoAgwRAgAhAiAAQQA6AAUgACACOgAEIAAgATYCAAsnACAAIAAoAgRBAXEgAXJBAnI2AgQgACABaiIAIAAoAgRBAXI2AgQLLQEBfyAAIAFBDGooAgBBDSABKAIAIgIbNgIEIAAgASgCBEGGkcAAIAIbNgIACy8BAX9BASEBIAAtAAQEfyABBSAAKAIAIgAoAhhB/6rAAEEBIAAoAhwoAgwRAgALCzUBAX8jAEEQayIDJAAgAyACNgIIIAMgATYCBCADIAA2AgAgAygCACADKAIEIAMoAggQjAEACyABAX8CQCAAKAIEIgFFDQAgAEEIaigCAEUNACABEBMLCyYBAX8jAEEQayIDJAAgAyABNgIMIAMgADYCCCADQQhqIAIQgAEACx8AAkAgAUF8TQRAIAAgAUEEIAIQpwEiAA0BCwALIAALIwAgAiACKAIEQX5xNgIEIAAgAUEBcjYCBCAAIAFqIAE2AgALHgAgACABQQNyNgIEIAAgAWoiACAAKAIEQQFyNgIECxQAIABBBGooAgAEQCAAKAIAEBMLCx0AIAEoAgBFBEAACyAAQeiUwAA2AgQgACABNgIACx4AIAAgBDYCDCAAIAM2AgggACACNgIEIAAgATYCAAsZAQF/IAAoAhAiAQR/IAEFIABBFGooAgALCxIAQQBBGSAAQQF2ayAAQR9GGwsWACAAIAFBAXI2AgQgACABaiABNgIACxkAIAAoAhggASACIABBHGooAgAoAgwRAgALHAAgASgCGEGEvcAAQQUgAUEcaigCACgCDBECAAsQACAAIAFqQX9qQQAgAWtxCxYAIABB6JPAADYCBCAAIAFBBGo2AgALDQAgAEEEahBTIAAQEwsYACAAQQRqQQAgAUKH0tfA7buRod0AURsLFQAgACgCACIAKAIAIAAoAgggARAXCxYAIAAoAgAiACgCACAAKAIIIAEQzgELDAAgACABIAIgAxAbCwsAIAEEQCAAEBMLCw8AIABBAXQiAEEAIABrcgsUACAAKAIAIAEgACgCBCgCEBEBAAsUACAAKAIAIAEgACgCBCgCDBEBAAsRACAAKAIAIAAoAgggARDOAQsTACAAQSg2AgQgAEGwk8AANgIACxMAIABBpJTAADYCBCAAIAE2AgALCAAgACABEDALDQAgACgCACABEDVBAAsTACAAQeCmwAA2AgQgACABNgIACw0AIAAtAARBAnFBAXYLEAAgASAAKAIAIAAoAgQQFgsRACAAQcUANgIEIAAgATYCAAsNACAAKAIAIAEgAhAjCwoAQQAgAGsgAHELCwAgAC0ABEEDcUULDAAgACABQQNyNgIECw0AIAAoAgAgACgCBGoLDQAgACgCACABEDZBAAsOACAAKAIAGgNADAALAAsLACAANQIAIAEQOgsMACAAIAEgAhCVAQALDQAgACgCACABIAIQHwsLACAAIwBqJAAjAAsLACAAKAIAIAEQZQsLACAAKAIAIAEQYgsJACAAQQRqEFMLBgAgABATCwsAIAAoAgAgARBECwsAIAAoAgAgARAoCwoAIAAoAgRBeHELCgAgACgCBEEBcQsKACAAKAIMQQFxCwoAIAAoAgxBAXYLGQAgACABQfTDwAAoAgAiAEEwIAAbEQAAAAsJACAAIAEQagALCQAgACABEGwACwkAIAAgARBrAAsKACACIAAgARAWCwoAIAAgASACEDcLCgAgACABIAIQfAsJACAAQQA2AgALCAAgACABECgLBwAgACABagsHACAAIAFrCwcAIABBCGoLBwAgAEF4agsUACAAKAIAIgAgACgCACgCABEFAAsNAEKH0tfA7buRod0ACwQAQQALDQBCi4X19pmw+oa4fwsNAEKL5OeV8riP17h/CwwAQo/05MKc7pTNbwsNAEK0r6rI5Z+Hvu8ACwMAAQsL1kMCAEGAgMAAC9UkdW5rbm93biBwYXJzaW5nIGVycm9yZXhwZWN0ZWQgAAAVABAACQAAAHVuZXhwZWN0ZWQgACgAEAALAAAAOyBleHBlY3RlZCAAKAAQAAsAAAA8ABAACwAAAC0tPiA6CiB8CiB8ICA9IAAAABAAAAAAAFgAEAAEAAAAAAAQAAAAAABcABAAAQAAAF0AEAABAAAAXgAQAAMAAABhABAAAwAAAF0AEAABAAAAYQAQAAMAAABdABAAAQAAAF4AEAADAAAAZAAQAAMAAAAAAAAAIAAAAAAAAAACAAAAAAAAAAIAAAAAAAAAAwAAAAEAAAAgAAAAAAAAAAIAAAAAAAAAAgAAAAAAAAADAAAAAgAAACAAAAAAAAAAAgAAAAAAAAACAAAAAAAAAAMAAAADAAAAIAAAAAAAAAACAAAAAAAAAAIAAAAAAAAAAwAAAAAAAAAgAAAAAAAAAAIAAAAAAAAAAgAAAAAAAAADAAAAAgAAACAAAAAAAAAAAgAAAAAAAAACAAAAAAAAAAMAAAAEAAAAIAAAAAAAAAACAAAAAAAAAAIAAAAAAAAAAwAAAAAAAAAgAAAAAAAAAAIAAAAAAAAAAgAAAAAAAAADAAAABQAAACAAAAAAAAAAAgAAAAAAAAACAAAAAAAAAAMAAAAAAAAAIAAAAAAAAAACAAAAAAAAAAIAAAAAAAAAAwAAAAAAAAAgAAAAAAAAAAIAAAAAAAAAAgAAAAAAAAADAAAABgAAACAAAAAAAAAAAgAAAAAAAAACAAAAAAAAAAMAAAAgfCAuLi4KAAAAEAAAAAAAWAAQAAQAAAAAABAAAAAAAFwAEAABAAAAXQAQAAEAAABeABAAAwAAAGEAEAADAAAAXQAQAAEAAABIAhAABwAAAGEAEAADAAAAXQAQAAEAAABhABAAAwAAAF0AEAABAAAAXgAQAAMAAABkABAAAwAAAAAAAAAgAAAAAAAAAAIAAAAAAAAAAgAAAAAAAAADAAAAAQAAACAAAAAAAAAAAgAAAAAAAAACAAAAAAAAAAMAAAACAAAAIAAAAAAAAAACAAAAAAAAAAIAAAAAAAAAAwAAAAQAAAAgAAAAAAAAAAIAAAAAAAAAAgAAAAAAAAADAAAAAAAAACAAAAAAAAAAAgAAAAAAAAACAAAAAAAAAAMAAAACAAAAIAAAAAAAAAACAAAAAAAAAAEAAAAJAAAAAwAAAAUAAAAgAAAAAAAAAAIAAAAAAAAAAgAAAAAAAAADAAAAAAAAACAAAAAAAAAAAgAAAAAAAAACAAAAAAAAAAMAAAADAAAAIAAAAAAAAAACAAAAAAAAAAEAAAAJAAAAAwAAAAYAAAAgAAAAAAAAAAIAAAAAAAAAAgAAAAAAAAADAAAAAAAAACAAAAAAAAAAAgAAAAAAAAACAAAAAAAAAAMAAAAHAAAAIAAAAAAAAAACAAAAAAAAAAIAAAAAAAAAAwAAAAAAAAAgAAAAAAAAAAIAAAAAAAAAAgAAAAAAAAADAAAAAAAAACAAAAAAAAAAAgAAAAAAAAACAAAAAAAAAAMAAAAIAAAAIAAAAAAAAAACAAAAAAAAAAIAAAAAAAAAAwAAAAAAEAAAAAAAWAAQAAQAAAAAABAAAAAAAFwAEAABAAAAXQAQAAEAAABeABAAAwAAAGEAEAADAAAAXQAQAAEAAABhABAAAwAAAF0AEAABAAAAYQAQAAMAAABdABAAAQAAAF4AEAADAAAAZAAQAAMAAAAAAAAAIAAAAAAAAAACAAAAAAAAAAIAAAAAAAAAAwAAAAEAAAAgAAAAAAAAAAIAAAAAAAAAAgAAAAAAAAADAAAAAgAAACAAAAAAAAAAAgAAAAAAAAACAAAAAAAAAAMAAAAEAAAAIAAAAAAAAAACAAAAAAAAAAIAAAAAAAAAAwAAAAAAAAAgAAAAAAAAAAIAAAAAAAAAAgAAAAAAAAADAAAAAgAAACAAAAAAAAAAAgAAAAAAAAABAAAACQAAAAMAAAAFAAAAIAAAAAAAAAACAAAAAAAAAAIAAAAAAAAAAwAAAAMAAAAgAAAAAAAAAAIAAAAAAAAAAQAAAAkAAAADAAAABgAAACAAAAAAAAAAAgAAAAAAAAACAAAAAAAAAAMAAAAAAAAAIAAAAAAAAAACAAAAAAAAAAIAAAAAAAAAAwAAAAcAAAAgAAAAAAAAAAIAAAAAAAAAAgAAAAAAAAADAAAAAAAAACAAAAAAAAAAAgAAAAAAAAACAAAAAAAAAAMAAAAAAAAAIAAAAAAAAAACAAAAAAAAAAIAAAAAAAAAAwAAAAgAAAAgAAAAAAAAAAIAAAAAAAAAAgAAAAAAAAADAAAAAAAQAAAAAABcABAAAQAAAAAAEAAAAAAALCAsIG9yIAAAABAAAAAAAPIGEAAFAAAAIG9yIAAAEAAAAAAACAcQAAQAAABwb3NpdGlvbiBvdXQgb2YgYm91bmRzL2hvbWUvcnVubmVyLy5jYXJnby9yZWdpc3RyeS9zcmMvZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzL3Blc3QtMi4xLjMvc3JjL3Bvc2l0aW9uLnJzAAAAMgcQAFcAAADHAAAADQAAADIHEABXAAAAygAAAAoAAAAyBxAAVwAAAIkAAAANAAAAMgcQAFcAAACOAAAAFgAAAGludGVybmFsIGVycm9yOiBlbnRlcmVkIHVucmVhY2hhYmxlIGNvZGUyBxAAVwAAAK0AAAAZAAAARXJyb3J2YXJpYW50BQAAAAQAAAAEAAAABgAAAGxvY2F0aW9uBQAAAAQAAAAEAAAABwAAAGxpbmVfY29sBQAAAAQAAAAEAAAACAAAAHBhdGgFAAAABAAAAAQAAAAJAAAAbGluZQUAAAAEAAAABAAAAAoAAABjb250aW51ZWRfbGluZXBhcnNpbmcgZXJyb3JDdXN0b21FcnJvcm1lc3NhZ2VQYXJzaW5nRXJyb3Jwb3NpdGl2ZXMAAAUAAAAEAAAABAAAAAsAAABuZWdhdGl2ZXMvaG9tZS9ydW5uZXIvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvcGVzdC0yLjEuMy9zcmMvaXRlcmF0b3JzL3BhaXIucnMAANUIEABdAAAA+gAAAA8AAADVCBAAXQAAAPEAAAAPAAAAaW50ZXJuYWwgZXJyb3I6IGVudGVyZWQgdW5yZWFjaGFibGUgY29kZdUIEABdAAAA9QAAABIAAAAMAAAACAAAAAQAAAANAAAADgAAAAwAAAAEAAAABAAAAAIAAABkZXNjcmlwdGlvbigpIGlzIGRlcHJlY2F0ZWQ7IHVzZSBEaXNwbGF5DwAAAGAAAAAEAAAAEAAAAA8AAABgAAAABAAAABEAAAAQAAAA2AkQABIAAAATAAAAFAAAABUAAAAWAAAAFwAAAGQAAAAEAAAAGAAAABcAAABkAAAABAAAABkAAAAYAAAAFAoQABoAAAAbAAAAHAAAAB0AAAAaAAAAU29tZR4AAAAEAAAABAAAAAoAAABOb25lHgAAAAgAAAAEAAAAHwAAAC9ob21lL3J1bm5lci8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9wZXN0LTIuMS4zL3NyYy9pdGVyYXRvcnMvcGFpcnMucnMAAHgKEABeAAAAwwAAAA8AAABpbnRlcm5hbCBlcnJvcjogZW50ZXJlZCB1bnJlYWNoYWJsZSBjb2RleAoQAF4AAADHAAAAEgAAACALEAAAAAAAL3J1c3RjL2E4MzE0ZWY3ZDBlYzdiNzVjMzM2YWYyYzk4NTdiZmFmNDMwMDJiZmMvbGlicmFyeS9hbGxvYy9zcmMvc2xpY2UucnMAACgLEABKAAAAZwQAABUAAAAoCxAASgAAAHUEAAAeAAAAKAsQAEoAAAB+BAAAGAAAACgLEABKAAAAfwQAABkAAAAoCxAASgAAAIIEAAAaAAAAKAsQAEoAAACIBAAADQAAACgLEABKAAAAiQQAABIAAABhc3NlcnRpb24gZmFpbGVkOiBtaWQgPD0gc2VsZi5sZW4oKWF0dGVtcHQgdG8gam9pbiBpbnRvIGNvbGxlY3Rpb24gd2l0aCBsZW4gPiB1c2l6ZTo6TUFYL3J1c3RjL2E4MzE0ZWY3ZDBlYzdiNzVjMzM2YWYyYzk4NTdiZmFmNDMwMDJiZmMvbGlicmFyeS9hbGxvYy9zcmMvc3RyLnJzPAwQAEgAAACrAAAACgAAADwMEABIAAAAwgAAABYAAABjYWxsZWQgYE9wdGlvbjo6dW53cmFwKClgIG9uIGEgYE5vbmVgIHZhbHVlL2hvbWUvcnVubmVyLy5jYXJnby9yZWdpc3RyeS9zcmMvZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzL3Blc3QtMi4xLjMvc3JjL2l0ZXJhdG9ycy9wYWlyLnJzzwwQAF0AAAB0AAAACgAAAM8MEABdAAAAUwAAAA8AAABpbnRlcm5hbCBlcnJvcjogZW50ZXJlZCB1bnJlYWNoYWJsZSBjb2RlzwwQAF0AAABVAAAAEgAAAHNyYy9wYXJzZXIucnMAAACEDRAADQAAACQAAAAvAAAAhA0QAA0AAAA7AAAALgAAAIQNEAANAAAAQAAAAB8AAABMaW5lQmxvY2tPdGhlck90aGVyQ2hhclNwZWNpYWxCbG9ja0lubGluZUVtaW5saW5lRW1DaGFyZW1waGFzaXNNYXJrSW5saW5lTWF0aGlubGluZU1hdGhDaGFySW5saW5lQ29kZWlubGluZUNvZGVDaGFyUHVuY3RGV1B1bmN0TXVsdGlTcGFjZU51bUVuZ0NuV0hJVFNQQUNFRU9JY2FsbGVkIGBPcHRpb246OnVud3JhcCgpYCBvbiBhIGBOb25lYCB2YWx1ZXBlZWsgd2FzIGNhbGxlZCBvbiBlbXB0eSBzdGFjay9ob21lL3J1bm5lci8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9wZXN0LTIuMS4zL3NyYy9wYXJzZXJfc3RhdGUucnMAAACqDhAAWwAAAHQDAAAOAAAAqg4QAFsAAADsAAAAGwAAAGludGVybmFsIGVycm9yOiBlbnRlcmVkIHVucmVhY2hhYmxlIGNvZGWqDhAAWwAAAPEAAAAeAAAAcG9wIHdhcyBjYWxsZWQgb24gZW1wdHkgc3RhY2sAAACqDhAAWwAAAJEDAAAOAAAAqg4QAFsAAABhAAAAQwAAAC9ob21lL3J1bm5lci8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9wZXN0LTIuMS4zL3NyYy9zcGFuLnJzAKAPEABTAAAAtQAAAAoAAAAvaG9tZS9ydW5uZXIvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvcGVzdC0yLjEuMy9zcmMvcG9zaXRpb24ucnMABBAQAFcAAAB7AQAAHAAAAAQQEABXAAAAZwEAABoAAAAEEBAAVwAAAAQBAAAfAAAAc3BhbiBjcmVhdGVkIGZyb20gcG9zaXRpb25zIGZyb20gZGlmZmVyZW50IGlucHV0cwAAAAQQEABXAAAAcgAAAA0AAADjgILvvIzvvJvjgIHvvIHvvJ/vvJpjYWxsZWQgYFJlc3VsdDo6dW53cmFwKClgIG9uIGFuIGBFcnJgIHZhbHVlIAAAAAQAAAAEAAAAIQAAAHNyYy9saWIucnMAACAREAAKAAAACwAAABoAAAAvaG9tZS9ydW5uZXIvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvcGVzdC0yLjEuMy9zcmMvc3RhY2sucnM8ERAAVAAAAFkAAAAeAAAAIgAAACMAAAAkAAAAJQAAACYAAADikI3ikIpTcGFuAAAnAAAABAAAAAQAAAAoAAAAUG9zACcAAAAEAAAABAAAACkAAAAqAAAABAAAAAQAAAApAAAA9BEQAAAAAAAKCkNhdXNlZCBieTr8ERAADAAAAAoAAAAQEhAAAQAAACwAAAAEAAAABAAAAC0AAAAuAAAALwAAADogAAA0EhAAAAAAADQSEAACAAAAAAAAACAAAAAAAAAAAgBB4KTAAAvuHgUAAAABAAAAICAgICAgICAgICAAMQAAAAQAAAAEAAAAMgAAADMAAAA0AAAAY2FsbGVkIGBPcHRpb246OnVud3JhcCgpYCBvbiBhIGBOb25lYCB2YWx1ZW1lbW9yeSBhbGxvY2F0aW9uIG9mICBieXRlcyBmYWlsZWQKAAC3EhAAFQAAAMwSEAAOAAAAbGlicmFyeS9zdGQvc3JjL2FsbG9jLnJz7BIQABgAAABEAQAACQAAAGxpYnJhcnkvc3RkL3NyYy9wYW5pY2tpbmcucnMUExAAHAAAAEYCAAAfAAAAFBMQABwAAABHAgAAHgAAADUAAAAMAAAABAAAADYAAAAxAAAACAAAAAQAAAA3AAAAOAAAABAAAAAEAAAAOQAAADoAAAAxAAAACAAAAAQAAAA7AAAAPAAAAD0AAAAEAAAABAAAAD4AAAA/AAAAQAAAAD0AAAAAAAAAAQAAAEEAAABsaWJyYXJ5L2FsbG9jL3NyYy9yYXdfdmVjLnJzY2FwYWNpdHkgb3ZlcmZsb3cAAADcExAAEQAAAMATEAAcAAAABQIAAAUAAABhIGZvcm1hdHRpbmcgdHJhaXQgaW1wbGVtZW50YXRpb24gcmV0dXJuZWQgYW4gZXJyb3JsaWJyYXJ5L2FsbG9jL3NyYy9mbXQucnMAOxQQABgAAABiAgAAHAAAACkgc2hvdWxkIGJlIDwgbGVuIChpcyApcmVtb3ZhbCBpbmRleCAoaXMgAAAAexQQABIAAABkFBAAFgAAAHoUEAABAAAAKS4uAKkUEAACAAAAaW5kZXggb3V0IG9mIGJvdW5kczogdGhlIGxlbiBpcyAgYnV0IHRoZSBpbmRleCBpcyAAALQUEAAgAAAA1BQQABIAAABjYWxsZWQgYE9wdGlvbjo6dW53cmFwKClgIG9uIGEgYE5vbmVgIHZhbHVlAEcAAAAAAAAAAQAAAEgAAACoFBAAAAAAAGA6IACoFBAAAAAAAD0VEAACAAAARwAAAAwAAAAEAAAASQAAAEoAAABLAAAAICAgICB7CiwKLCAgeyB9IH0oCigsCltdMHgwMDAxMDIwMzA0MDUwNjA3MDgwOTEwMTExMjEzMTQxNTE2MTcxODE5MjAyMTIyMjMyNDI1MjYyNzI4MjkzMDMxMzIzMzM0MzUzNjM3MzgzOTQwNDE0MjQzNDQ0NTQ2NDc0ODQ5NTA1MTUyNTM1NDU1NTY1NzU4NTk2MDYxNjI2MzY0NjU2NjY3Njg2OTcwNzE3MjczNzQ3NTc2Nzc3ODc5ODA4MTgyODM4NDg1ODY4Nzg4ODk5MDkxOTI5Mzk0OTU5Njk3OTg5OQAARwAAAAQAAAAEAAAATAAAAE0AAABOAAAAcmFuZ2Ugc3RhcnQgaW5kZXggIG91dCBvZiByYW5nZSBmb3Igc2xpY2Ugb2YgbGVuZ3RoIGQWEAASAAAAdhYQACIAAABsaWJyYXJ5L2NvcmUvc3JjL3NsaWNlL2luZGV4LnJzAKgWEAAfAAAANAAAAAUAAAByYW5nZSBlbmQgaW5kZXgg2BYQABAAAAB2FhAAIgAAAKgWEAAfAAAASQAAAAUAAABzbGljZSBpbmRleCBzdGFydHMgYXQgIGJ1dCBlbmRzIGF0IAAIFxAAFgAAAB4XEAANAAAAqBYQAB8AAABcAAAABQAAAGxpYnJhcnkvY29yZS9zcmMvc3RyL21vZC5yc1suLi5dYnl0ZSBpbmRleCAgaXMgb3V0IG9mIGJvdW5kcyBvZiBgAAAAbBcQAAsAAAB3FxAAFgAAADwVEAABAAAATBcQABsAAABrAAAACQAAAGJlZ2luIDw9IGVuZCAoIDw9ICkgd2hlbiBzbGljaW5nIGAAALgXEAAOAAAAxhcQAAQAAADKFxAAEAAAADwVEAABAAAATBcQABsAAABvAAAABQAAAEwXEAAbAAAAfQAAAC0AAAAgaXMgbm90IGEgY2hhciBib3VuZGFyeTsgaXQgaXMgaW5zaWRlICAoYnl0ZXMgKSBvZiBgbBcQAAsAAAAcGBAAJgAAAEIYEAAIAAAAShgQAAYAAAA8FRAAAQAAAEwXEAAbAAAAfwAAAAUAAABsaWJyYXJ5L2NvcmUvc3JjL3VuaWNvZGUvcHJpbnRhYmxlLnJzAAAAiBgQACUAAAAaAAAANgAAAAABAwUFBgYCBwYIBwkRChwLGQwaDRAODQ8EEAMSEhMJFgEXBBgBGQMaBxsBHAIfFiADKwMtCy4BMAMxAjIBpwKpAqoEqwj6AvsF/QL+A/8JrXh5i42iMFdYi4yQHN0OD0tM+/wuLz9cXV/ihI2OkZKpsbq7xcbJyt7k5f8ABBESKTE0Nzo7PUlKXYSOkqmxtLq7xsrOz+TlAAQNDhESKTE0OjtFRklKXmRlhJGbncnOzw0RKTo7RUlXW1xeX2RljZGptLq7xcnf5OXwDRFFSWRlgISyvL6/1dfw8YOFi6Smvr/Fx87P2ttImL3Nxs7PSU5PV1leX4mOj7G2t7/BxsfXERYXW1z29/7/gG1x3t8OH25vHB1ffX6ur3+7vBYXHh9GR05PWFpcXn5/tcXU1dzw8fVyc490dZYmLi+nr7e/x8/X35pAl5gwjx/S1M7/Tk9aWwcIDxAnL+7vbm83PT9CRZCRU2d1yMnQ0djZ5/7/ACBfIoLfBIJECBsEBhGBrA6AqwUfCYEbAxkIAQQvBDQEBwMBBwYHEQpQDxIHVQcDBBwKCQMIAwcDAgMDAwwEBQMLBgEOFQVOBxsHVwcCBhYNUARDAy0DAQQRBg8MOgQdJV8gbQRqJYDIBYKwAxoGgv0DWQcWCRgJFAwUDGoGCgYaBlkHKwVGCiwEDAQBAzELLAQaBgsDgKwGCgYvMU0DgKQIPAMPAzwHOAgrBYL/ERgILxEtAyEPIQ+AjASClxkLFYiUBS8FOwcCDhgJgL4idAyA1hoMBYD/BYDfDPKdAzcJgVwUgLgIgMsFChg7AwoGOAhGCAwGdAseA1oEWQmAgxgcChYJTASAigarpAwXBDGhBIHaJgcMBQWAphCB9QcBICoGTASAjQSAvgMbAw8NAAYBAQMBBAIFBwcCCAgJAgoFCwIOBBABEQISBRMRFAEVAhcCGQ0cBR0IJAFqBGsCrwO8As8C0QLUDNUJ1gLXAtoB4AXhAucE6ALuIPAE+AL6AvsBDCc7Pk5Pj56en3uLk5aisrqGsQYHCTY9Plbz0NEEFBg2N1ZXf6qur7014BKHiY6eBA0OERIpMTQ6RUZJSk5PZGVctrcbHAcICgsUFzY5Oqip2NkJN5CRqAcKOz5maY+Sb1+/7u9aYvT8/5qbLi8nKFWdoKGjpKeorbq8xAYLDBUdOj9FUaanzM2gBxkaIiU+P+fs7//FxgQgIyUmKDM4OkhKTFBTVVZYWlxeYGNlZmtzeH1/iqSqr7DA0K6vbm+TXiJ7BQMELQNmAwEvLoCCHQMxDxwEJAkeBSsFRAQOKoCqBiQEJAQoCDQLTkOBNwkWCggYO0U5A2MICTAWBSEDGwUBQDgESwUvBAoHCQdAICcEDAk2AzoFGgcEDAdQSTczDTMHLggKgSZSTigIKhYaJhwUFwlOBCQJRA0ZBwoGSAgnCXULP0EqBjsFCgZRBgEFEAMFgItiHkgICoCmXiJFCwoGDRM6Bgo2LAQXgLk8ZFMMSAkKRkUbSAhTDUmBB0YKHQNHSTcDDggKBjkHCoE2GYC3AQ8yDYObZnULgMSKTGMNhC+P0YJHobmCOQcqBFwGJgpGCigFE4KwW2VLBDkHEUAFCwIOl/gIhNYqCaLngTMtAxEECIGMiQRrBQ0DCQcQkmBHCXQ8gPYKcwhwFUaAmhQMVwkZgIeBRwOFQg8VhFAfgOErgNUtAxoEAoFAHxE6BQGE4ID3KUwECgQCgxFETD2AwjwGAQRVBRs0AoEOLARkDFYKgK44HQ0sBAkHAg4GgJqD2AUQAw0DdAxZBwwEAQ8MBDgICgYoCCJOgVQMFQMFAwcJHQMLBQYKCgYICAcJgMslCoQGbGlicmFyeS9jb3JlL3NyYy91bmljb2RlL3VuaWNvZGVfZGF0YS5ycwAAACkeEAAoAAAASwAAACgAAAApHhAAKAAAAFcAAAAWAAAAKR4QACgAAABSAAAAPgAAAEVycm9yAAAAAAMAAIMEIACRBWAAXROgABIXIB8MIGAf7yygKyowICxvpuAsAqhgLR77YC4A/iA2nv9gNv0B4TYBCiE3JA3hN6sOYTkvGKE5MBzhR/MeIUzwauFPT28hUJ28oVAAz2FRZdGhUQDaIVIA4OFTMOFhVa7ioVbQ6OFWIABuV/AB/1cAcAAHAC0BAQECAQIBAUgLMBUQAWUHAgYCAgEEIwEeG1sLOgkJARgEAQkBAwEFKwM8CCoYASA3AQEBBAgEAQMHCgIdAToBAQECBAgBCQEKAhoBAgI5AQQCBAICAwMBHgIDAQsCOQEEBQECBAEUAhYGAQE6AQECAQQIAQcDCgIeATsBAQEMAQkBKAEDATcBAQMFAwEEBwILAh0BOgECAQIBAwEFAgcCCwIcAjkCAQECBAgBCQEKAh0BSAEEAQIDAQEIAVEBAgcMCGIBAgkLBkoCGwEBAQEBNw4BBQECBQsBJAkBZgQBBgECAgIZAgQDEAQNAQICBgEPAQADAAMdAh4CHgJAAgEHCAECCwkBLQMBAXUCIgF2AwQCCQEGA9sCAgE6AQEHAQEBAQIIBgoCATAfMQQwBwEBBQEoCQwCIAQCAgEDOAEBAgMBAQM6CAICmAMBDQEHBAEGAQMCxkAAAcMhAAONAWAgAAZpAgAEAQogAlACAAEDAQQBGQIFAZcCGhINASYIGQsuAzABAgQCAicBQwYCAgICDAEIAS8BMwEBAwICBQIBASoCCAHuAQIBBAEAAQAQEBAAAgAB4gGVBQADAQIFBCgDBAGlAgAEAAKZCzEEewE2DykBAgIKAzEEAgIHAT0DJAUBCD4BDAI0CQoEAgFfAwIBAQIGAaABAwgVAjkCAQEBARYBDgcDBcMIAgMBARcBUQECBgEBAgEBAgEC6wECBAYCAQIbAlUIAgEBAmoBAQECBgEBZQMCBAEFAAkBAvUBCgIBAQQBkAQCAgQBIAooBgIECAEJBgIDLg0BAgAHAQYBAVIWAgcBAgECegYDAQECAQcBAUgCAwEBAQACAAU7BwABPwRRAQACAC4CFwABAQMEBQgIAgceBJQDADcEMggBDgEWBQEPAAcBEQIHAQIBBQAHAAE9BAAHbQcAYIDwAHsJcHJvZHVjZXJzAghsYW5ndWFnZQEEUnVzdAAMcHJvY2Vzc2VkLWJ5AwVydXN0Yx0xLjYyLjAgKGE4MzE0ZWY3ZCAyMDIyLTA2LTI3KQZ3YWxydXMGMC4xOS4wDHdhc20tYmluZGdlbhIwLjIuODAgKDRjYWE5ODE2NSk=");

// liberty-web/charliberty.js
var wasm;
var WASM_VECTOR_LEN = 0;
var cachegetUint8Memory0 = null;
function getUint8Memory0() {
  if (cachegetUint8Memory0 === null || cachegetUint8Memory0.buffer !== wasm.memory.buffer) {
    cachegetUint8Memory0 = new Uint8Array(wasm.memory.buffer);
  }
  return cachegetUint8Memory0;
}
var cachedTextEncoder = new TextEncoder("utf-8");
var encodeString = typeof cachedTextEncoder.encodeInto === "function" ? function(arg, view) {
  return cachedTextEncoder.encodeInto(arg, view);
} : function(arg, view) {
  const buf = cachedTextEncoder.encode(arg);
  view.set(buf);
  return {
    read: arg.length,
    written: buf.length
  };
};
function passStringToWasm0(arg, malloc, realloc) {
  if (realloc === void 0) {
    const buf = cachedTextEncoder.encode(arg);
    const ptr2 = malloc(buf.length);
    getUint8Memory0().subarray(ptr2, ptr2 + buf.length).set(buf);
    WASM_VECTOR_LEN = buf.length;
    return ptr2;
  }
  let len = arg.length;
  let ptr = malloc(len);
  const mem = getUint8Memory0();
  let offset = 0;
  for (; offset < len; offset++) {
    const code = arg.charCodeAt(offset);
    if (code > 127)
      break;
    mem[ptr + offset] = code;
  }
  if (offset !== len) {
    if (offset !== 0) {
      arg = arg.slice(offset);
    }
    ptr = realloc(ptr, len, len = offset + arg.length * 3);
    const view = getUint8Memory0().subarray(ptr + offset, ptr + len);
    const ret = encodeString(arg, view);
    offset += ret.written;
  }
  WASM_VECTOR_LEN = offset;
  return ptr;
}
var cachegetInt32Memory0 = null;
function getInt32Memory0() {
  if (cachegetInt32Memory0 === null || cachegetInt32Memory0.buffer !== wasm.memory.buffer) {
    cachegetInt32Memory0 = new Int32Array(wasm.memory.buffer);
  }
  return cachegetInt32Memory0;
}
var cachedTextDecoder = new TextDecoder("utf-8", { ignoreBOM: true, fatal: true });
cachedTextDecoder.decode();
function getStringFromWasm0(ptr, len) {
  return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len));
}
function formatLine(line) {
  try {
    const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
    const ptr0 = passStringToWasm0(line, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    const len0 = WASM_VECTOR_LEN;
    wasm.formatLine(retptr, ptr0, len0);
    var r0 = getInt32Memory0()[retptr / 4 + 0];
    var r1 = getInt32Memory0()[retptr / 4 + 1];
    return getStringFromWasm0(r0, r1);
  } finally {
    wasm.__wbindgen_add_to_stack_pointer(16);
    wasm.__wbindgen_free(r0, r1);
  }
}
var cachegetUint32Memory0 = null;
function getUint32Memory0() {
  if (cachegetUint32Memory0 === null || cachegetUint32Memory0.buffer !== wasm.memory.buffer) {
    cachegetUint32Memory0 = new Uint32Array(wasm.memory.buffer);
  }
  return cachegetUint32Memory0;
}
function getArrayU32FromWasm0(ptr, len) {
  return getUint32Memory0().subarray(ptr / 4, ptr / 4 + len);
}
function getBlockRanges(line, cursor_pos) {
  try {
    const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
    const ptr0 = passStringToWasm0(line, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    const len0 = WASM_VECTOR_LEN;
    wasm.getBlockRanges(retptr, ptr0, len0, cursor_pos);
    var r0 = getInt32Memory0()[retptr / 4 + 0];
    var r1 = getInt32Memory0()[retptr / 4 + 1];
    var v1 = getArrayU32FromWasm0(r0, r1).slice();
    wasm.__wbindgen_free(r0, r1 * 4);
    return v1;
  } finally {
    wasm.__wbindgen_add_to_stack_pointer(16);
  }
}
function load(module2, imports) {
  return __async(this, null, function* () {
    if (typeof Response === "function" && module2 instanceof Response) {
      if (typeof WebAssembly.instantiateStreaming === "function") {
        try {
          return yield WebAssembly.instantiateStreaming(module2, imports);
        } catch (e) {
          if (module2.headers.get("Content-Type") != "application/wasm") {
            console.warn("`WebAssembly.instantiateStreaming` failed because your server does not serve wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\n", e);
          } else {
            throw e;
          }
        }
      }
      const bytes = yield module2.arrayBuffer();
      return yield WebAssembly.instantiate(bytes, imports);
    } else {
      const instance = yield WebAssembly.instantiate(module2, imports);
      if (instance instanceof WebAssembly.Instance) {
        return { instance, module: module2 };
      } else {
        return instance;
      }
    }
  });
}
function init(input) {
  return __async(this, null, function* () {
    if (typeof input === "undefined") {
      input = new URL("charliberty_bg.wasm", "");
    }
    const imports = {};
    if (typeof input === "string" || typeof Request === "function" && input instanceof Request || typeof URL === "function" && input instanceof URL) {
      input = fetch(input);
    }
    const { instance, module: module2 } = yield load(yield input, imports);
    wasm = instance.exports;
    init.__wbindgen_wasm_module = module2;
    return wasm;
  });
}
var charliberty_default = init;

// src/const.ts
var FW;
((FW2) => {
  FW2.DOT = "\xB7";
  FW2.MONEY = "\uFFE5";
  FW2.FULLSTOP = "\u3002";
  FW2.LT = "\u300A";
  FW2.GT = "\u300B";
  FW2.SLASH = "\u3001";
  FW2.LEFTQUO = "\u201C";
  FW2.RIGHTQUO = "\u201D";
  FW2.LEFTPAREN = "\uFF08";
  FW2.RIGHTPAREN = "\uFF09";
})(FW || (FW = {}));
var SW;
((SW2) => {
  SW2.DOT = "`";
  SW2.MONEY = "$";
  SW2.FULLSTOP = ".";
  SW2.LT = "<";
  SW2.GT = ">";
  SW2.SLASH = "/";
  SW2.LEFTQUO = '"';
  SW2.RIGHTQUO = '"';
  SW2.LEFTPAREN = "(";
  SW2.RIGHTPAREN = ")";
})(SW || (SW = {}));
var PUNCTS = new Set(" \uFF0C\u3002\uFF1A\uFF1F,.:?");
var DEFAULT_RULES = String.raw`# Converting Rules
# ---------------------------------------------

# line head converting. 
# Note: this rule can't apply to the very first line of the document
'\n|' -> '\n>|'
'\n|' -> '\n/|'

# CN symbols to EN
'|' -> '.|'
'|' -> '>|'
'|' -> '/|'
'|' -> ';|'
'|' -> ',|'

# auto pair and convert
'|' -> '<|' # this one take higer priority than the next line
'|'     -> '|'
'|' -> '(|)'
'|'     -> '|'

# auto code block
'|'  -> '\`|\`' # inline block
'\`|\`' -> '\`\`\`|\n\`\`\`'

# have fun converting!
# 'dpx|' -> 'don\'t panic|'


# Selection Insert Rules
# ---------------------------------------------
''  -> '\`' + '\`'
''  -> '$' + '$'
''  -> '' + ''
'<'  -> '<' + '>'
`.replaceAll("\\`", "`");

// src/utils.ts
var config;
function initLog(cfg) {
  config = cfg;
}
function log(format, ...parts) {
  if (config != void 0 && config.debug) {
    parts.forEach((v, idx) => {
      if (typeof v === "string" || v instanceof String) {
        parts[idx] = JSON.stringify(v);
      }
    });
    console.log(format, ...parts);
  }
}

// src/ext_convert.ts
var EOF = "EOF";
var ANCHOR = "\xA6";
var ParseResult = class {
  constructor(value, error) {
    this.value = value;
    this.error = error;
  }
  get isOk() {
    return this.error == "";
  }
};
function Ok(val) {
  return new ParseResult(val, "");
}
function Err(err) {
  return new ParseResult(null, err);
}
function findOnlyAnchor(s) {
  let res = -1, idx = 0;
  for (const ch of s) {
    if (ch === ANCHOR) {
      if (res == -1) {
        res = idx;
      } else {
        return -1;
      }
    }
    idx++;
  }
  return res;
}
function prefixOf(s1, s2) {
  if (s1.length > s2.length)
    return false;
  for (let i = 1; i < s1.length; i++) {
    if (s1[i] != s2[i])
      return false;
  }
  return true;
}
function suffixOf(s1, s2) {
  if (s1.length > s2.length)
    return false;
  for (let i = s1.length - 1, j = s2.length - 1; i > -1; i--, j--) {
    if (s1[i] != s2[j])
      return false;
  }
  return true;
}
var Rule = class {
};
var SideRule = class {
  constructor(trig, left, right) {
    this.trig = trig;
    this.left = left;
    this.right = right;
  }
  get isValid() {
    return this.trig.length === 1;
  }
};
var ConvRule = class {
  constructor(left, right) {
    this.left = Array.from(left);
    this.right = Array.from(right);
    this.lanchor = findOnlyAnchor(this.left);
    this.ranchor = findOnlyAnchor(this.right);
    this.trig = this.left[this.lanchor - 1];
    this.replace = this.right.slice(0, this.ranchor).join("") + this.right.slice(this.ranchor + 1).join("");
  }
  get isValid() {
    return this.lanchor > 0 && this.ranchor > 0;
  }
  canConvert(inputS, insChr, insPosBaseHead) {
    const input = Array.from(inputS);
    if (!this.isValid || insChr != this.trig)
      return false;
    const { left, lanchor } = this;
    const matchRight = prefixOf(left.slice(lanchor + 1), input.slice(insPosBaseHead));
    const matchLeft = suffixOf(left.slice(0, lanchor - 1), input.slice(0, insPosBaseHead));
    return matchLeft && matchRight;
  }
  mapToChanges(pos) {
    const { left, lanchor, ranchor } = this;
    const from = pos + 1 - lanchor;
    const to = from + left.length - 2;
    const newPos = pos + (ranchor - lanchor + 1);
    return {
      changes: { from, to, insert: this.replace },
      selection: { anchor: newPos, head: newPos }
    };
  }
};
var RuleParser = class {
  constructor(input) {
    this.idx = 0;
    this.input = Array.from(input);
    this.convRules = [];
    this.sideRules = /* @__PURE__ */ new Map();
    this.errors = [];
  }
  peek() {
    const { idx, input } = this;
    if (idx == input.length) {
      return EOF;
    }
    return input[idx];
  }
  eat() {
    const { idx, input } = this;
    if (idx == input.length) {
      return EOF;
    }
    return input[this.idx++];
  }
  rewind() {
    this.idx--;
  }
  ignoreSpace() {
    while (this.peek() === " ") {
      this.eat();
    }
  }
  parseString() {
    this.ignoreSpace();
    if (this.peek() != "'") {
      return Err("expect a rule string starting with ', found " + this.peek());
    }
    this.eat();
    const result = [];
    let ch;
    while (true) {
      ch = this.eat();
      switch (ch) {
        case "\\":
          switch (this.peek()) {
            case "'":
              result.push(this.eat());
              break;
            case "n":
              this.eat();
              result.push("\n");
              break;
            default:
              result.push(ch);
              break;
          }
          break;
        case "'":
          return Ok(result.join(""));
        case EOF:
          return Err("expect a rule string, found EOF");
        default:
          result.push(ch);
          break;
      }
    }
  }
  parseMapArrow() {
    this.ignoreSpace();
    const first = this.eat(), second = this.eat();
    if (first != "-" || second != ">") {
      return Err(`expect ->, found ${first}${second}`);
    }
    return Ok("->");
  }
  parseComment() {
    this.ignoreSpace();
    let ch = this.peek();
    if (ch === "#") {
      while (ch != "\n" && ch != EOF) {
        ch = this.eat();
      }
      if (ch === "\n") {
        this.rewind();
      }
    }
    if (ch != "\n" && ch != EOF) {
      return Err("Expect one rule ending with newline or EOF, found " + ch);
    }
    return Ok("#no content#");
  }
  isSideRule() {
    this.ignoreSpace();
    const ch = this.peek();
    if (ch != "+") {
      return false;
    } else {
      this.eat();
      return true;
    }
  }
  parseOne() {
    const r1 = this.parseString();
    if (!r1.isOk) {
      return Err(r1.error);
    }
    const r2 = this.parseMapArrow();
    if (!r2.isOk) {
      return Err(r2.error);
    }
    const r3 = this.parseString();
    if (!r3.isOk) {
      return Err(r3.error);
    }
    const rule = new Rule();
    if (this.isSideRule()) {
      const rightInsert = this.parseString();
      if (!rightInsert.isOk) {
        return Err(rightInsert.error);
      }
      const sideRule = new SideRule(r1.value, r3.value, rightInsert.value);
      if (!sideRule.isValid) {
        return Err("the trigger of a side insert rule should be a single char");
      }
      rule.type = 1 /* SideRule */;
      rule.side = sideRule;
    } else {
      const convRule = new ConvRule(r1.value, r3.value);
      if (!convRule.isValid) {
        return Err("rule shuold has one and only one non-heading |");
      }
      rule.type = 0 /* ConvRule */;
      rule.conv = convRule;
    }
    const r4 = this.parseComment();
    if (!r4.isOk) {
      return Err(r4.error);
    }
    return Ok(rule);
  }
  parse() {
    let line = 1;
    while (true) {
      const r = this.parseComment();
      if (!r.isOk) {
        const rRes = this.parseOne();
        if (!rRes.isOk) {
          this.errors.push(`error: line ${line}: ` + rRes.error);
        } else if (rRes.value.type === 0 /* ConvRule */) {
          this.convRules.push(rRes.value.conv);
        } else {
          const s = rRes.value.side;
          this.sideRules.set(s.trig, { l: s.left, r: s.right });
        }
      }
      const ch = this.eat();
      if (ch === "\n") {
        line++;
      } else {
        break;
      }
    }
  }
};
var Rules = class {
  constructor(ruletxt) {
    const unescapedTxt = ruletxt.replaceAll("\\|", "{0v0}").replaceAll("|", ANCHOR).replaceAll("{0v0}", "|");
    const parser2 = new RuleParser(unescapedTxt);
    parser2.parse();
    this.rules = [];
    this.trigSet = /* @__PURE__ */ new Set();
    this.lmax = this.rmax = 0;
    this.errors = parser2.errors;
    if (this.errors.length > 0)
      return;
    this.rules = parser2.convRules;
    this.sideInsertMap = parser2.sideRules;
    let lmax = 0, rmax = 0;
    for (const r of this.rules) {
      this.trigSet.add(r.trig);
      const lmax_ = r.lanchor - 1, rmax_ = r.left.length - 1 - r.lanchor;
      if (lmax_ > lmax)
        lmax = lmax_;
      if (rmax_ > rmax)
        rmax = rmax_;
    }
    this.lmax = lmax;
    this.rmax = rmax;
  }
  match(input, insChar, insPosBaseLineHead) {
    for (const rule of this.rules) {
      if (rule.canConvert(input, insChar, insPosBaseLineHead)) {
        return rule;
      }
    }
    return null;
  }
};

// src/ext_libertyzone.ts
var import_view = require("@codemirror/view");
function libertyZone(zonespotter) {
  return import_view.ViewPlugin.fromClass(class {
    constructor(_) {
      this.decorations = import_view.Decoration.none;
      this.cleanTimer = -1;
    }
    get isTimerActive() {
      return this.cleanTimer >= 0;
    }
    tryRemoveTimer() {
      if (this.isTimerActive) {
        window.clearTimeout(this.cleanTimer);
        this.cleanTimer = -1;
      }
    }
    update(update) {
      const range = zonespotter(update);
      if (range === void 0 || update.state.doc.lineAt(range.from).from == range.from) {
        this.tryRemoveTimer();
        this.cleanTimer = window.setTimeout(() => {
          if (this.decorations.size) {
            this.decorations = import_view.Decoration.none;
          }
        }, 1e3);
        return;
      }
      this.decorations = import_view.Decoration.set(import_view.Decoration.widget({
        widget: new MarkWidget(15),
        side: 1
      }).range(range.from));
      this.tryRemoveTimer();
    }
  }, {
    decorations: (v) => v.decorations
  });
}
var MarkWidget = class extends import_view.WidgetType {
  constructor(lineHeight) {
    super();
    this.lineHeight = lineHeight;
  }
  toDOM() {
    const mark = document.createElement("span");
    mark.style.position = "relative";
    mark.style.top = `-${this.lineHeight}px`;
    mark.innerText = "\u2B50\uFE0F";
    const wrapper = document.createElement("div");
    wrapper.style.display = "inline-block";
    wrapper.style.position = "absolute";
    wrapper.append(mark);
    return wrapper;
  }
  ignoreEvent() {
    return false;
  }
};

// src/settings.ts
var import_obsidian = require("obsidian");
var import_state = require("@codemirror/state");
var import_view2 = require("@codemirror/view");
var import_language2 = require("@codemirror/language");

// node_modules/@lezer/common/dist/index.js
var DefaultBufferLength = 1024;
var nextPropID = 0;
var Range = class {
  constructor(from, to) {
    this.from = from;
    this.to = to;
  }
};
var NodeProp = class {
  constructor(config3 = {}) {
    this.id = nextPropID++;
    this.perNode = !!config3.perNode;
    this.deserialize = config3.deserialize || (() => {
      throw new Error("This node type doesn't define a deserialize function");
    });
  }
  add(match) {
    if (this.perNode)
      throw new RangeError("Can't add per-node props to node types");
    if (typeof match != "function")
      match = NodeType.match(match);
    return (type) => {
      let result = match(type);
      return result === void 0 ? null : [this, result];
    };
  }
};
NodeProp.closedBy = new NodeProp({ deserialize: (str) => str.split(" ") });
NodeProp.openedBy = new NodeProp({ deserialize: (str) => str.split(" ") });
NodeProp.group = new NodeProp({ deserialize: (str) => str.split(" ") });
NodeProp.contextHash = new NodeProp({ perNode: true });
NodeProp.lookAhead = new NodeProp({ perNode: true });
NodeProp.mounted = new NodeProp({ perNode: true });
var noProps = /* @__PURE__ */ Object.create(null);
var NodeType = class {
  constructor(name2, props, id2, flags = 0) {
    this.name = name2;
    this.props = props;
    this.id = id2;
    this.flags = flags;
  }
  static define(spec) {
    let props = spec.props && spec.props.length ? /* @__PURE__ */ Object.create(null) : noProps;
    let flags = (spec.top ? 1 : 0) | (spec.skipped ? 2 : 0) | (spec.error ? 4 : 0) | (spec.name == null ? 8 : 0);
    let type = new NodeType(spec.name || "", props, spec.id, flags);
    if (spec.props)
      for (let src of spec.props) {
        if (!Array.isArray(src))
          src = src(type);
        if (src) {
          if (src[0].perNode)
            throw new RangeError("Can't store a per-node prop on a node type");
          props[src[0].id] = src[1];
        }
      }
    return type;
  }
  prop(prop) {
    return this.props[prop.id];
  }
  get isTop() {
    return (this.flags & 1) > 0;
  }
  get isSkipped() {
    return (this.flags & 2) > 0;
  }
  get isError() {
    return (this.flags & 4) > 0;
  }
  get isAnonymous() {
    return (this.flags & 8) > 0;
  }
  is(name2) {
    if (typeof name2 == "string") {
      if (this.name == name2)
        return true;
      let group = this.prop(NodeProp.group);
      return group ? group.indexOf(name2) > -1 : false;
    }
    return this.id == name2;
  }
  static match(map) {
    let direct = /* @__PURE__ */ Object.create(null);
    for (let prop in map)
      for (let name2 of prop.split(" "))
        direct[name2] = map[prop];
    return (node) => {
      for (let groups = node.prop(NodeProp.group), i = -1; i < (groups ? groups.length : 0); i++) {
        let found = direct[i < 0 ? node.name : groups[i]];
        if (found)
          return found;
      }
    };
  }
};
NodeType.none = new NodeType("", /* @__PURE__ */ Object.create(null), 0, 8);
var NodeSet = class {
  constructor(types) {
    this.types = types;
    for (let i = 0; i < types.length; i++)
      if (types[i].id != i)
        throw new RangeError("Node type ids should correspond to array positions when creating a node set");
  }
  extend(...props) {
    let newTypes = [];
    for (let type of this.types) {
      let newProps = null;
      for (let source of props) {
        let add = source(type);
        if (add) {
          if (!newProps)
            newProps = Object.assign({}, type.props);
          newProps[add[0].id] = add[1];
        }
      }
      newTypes.push(newProps ? new NodeType(type.name, newProps, type.id, type.flags) : type);
    }
    return new NodeSet(newTypes);
  }
};
var CachedNode = /* @__PURE__ */ new WeakMap();
var CachedInnerNode = /* @__PURE__ */ new WeakMap();
var IterMode;
(function(IterMode2) {
  IterMode2[IterMode2["ExcludeBuffers"] = 1] = "ExcludeBuffers";
  IterMode2[IterMode2["IncludeAnonymous"] = 2] = "IncludeAnonymous";
  IterMode2[IterMode2["IgnoreMounts"] = 4] = "IgnoreMounts";
  IterMode2[IterMode2["IgnoreOverlays"] = 8] = "IgnoreOverlays";
})(IterMode || (IterMode = {}));
var Tree = class {
  constructor(type, children, positions, length, props) {
    this.type = type;
    this.children = children;
    this.positions = positions;
    this.length = length;
    this.props = null;
    if (props && props.length) {
      this.props = /* @__PURE__ */ Object.create(null);
      for (let [prop, value] of props)
        this.props[typeof prop == "number" ? prop : prop.id] = value;
    }
  }
  toString() {
    let mounted = this.prop(NodeProp.mounted);
    if (mounted && !mounted.overlay)
      return mounted.tree.toString();
    let children = "";
    for (let ch of this.children) {
      let str = ch.toString();
      if (str) {
        if (children)
          children += ",";
        children += str;
      }
    }
    return !this.type.name ? children : (/\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) + (children.length ? "(" + children + ")" : "");
  }
  cursor(mode = 0) {
    return new TreeCursor(this.topNode, mode);
  }
  cursorAt(pos, side = 0, mode = 0) {
    let scope = CachedNode.get(this) || this.topNode;
    let cursor = new TreeCursor(scope);
    cursor.moveTo(pos, side);
    CachedNode.set(this, cursor._tree);
    return cursor;
  }
  get topNode() {
    return new TreeNode(this, 0, 0, null);
  }
  resolve(pos, side = 0) {
    let node = resolveNode(CachedNode.get(this) || this.topNode, pos, side, false);
    CachedNode.set(this, node);
    return node;
  }
  resolveInner(pos, side = 0) {
    let node = resolveNode(CachedInnerNode.get(this) || this.topNode, pos, side, true);
    CachedInnerNode.set(this, node);
    return node;
  }
  iterate(spec) {
    let { enter, leave, from = 0, to = this.length } = spec;
    for (let c = this.cursor((spec.mode || 0) | IterMode.IncludeAnonymous); ; ) {
      let entered = false;
      if (c.from <= to && c.to >= from && (c.type.isAnonymous || enter(c) !== false)) {
        if (c.firstChild())
          continue;
        entered = true;
      }
      for (; ; ) {
        if (entered && leave && !c.type.isAnonymous)
          leave(c);
        if (c.nextSibling())
          break;
        if (!c.parent())
          return;
        entered = true;
      }
    }
  }
  prop(prop) {
    return !prop.perNode ? this.type.prop(prop) : this.props ? this.props[prop.id] : void 0;
  }
  get propValues() {
    let result = [];
    if (this.props)
      for (let id2 in this.props)
        result.push([+id2, this.props[id2]]);
    return result;
  }
  balance(config3 = {}) {
    return this.children.length <= 8 ? this : balanceRange(NodeType.none, this.children, this.positions, 0, this.children.length, 0, this.length, (children, positions, length) => new Tree(this.type, children, positions, length, this.propValues), config3.makeTree || ((children, positions, length) => new Tree(NodeType.none, children, positions, length)));
  }
  static build(data) {
    return buildTree(data);
  }
};
Tree.empty = new Tree(NodeType.none, [], [], 0);
var FlatBufferCursor = class {
  constructor(buffer, index) {
    this.buffer = buffer;
    this.index = index;
  }
  get id() {
    return this.buffer[this.index - 4];
  }
  get start() {
    return this.buffer[this.index - 3];
  }
  get end() {
    return this.buffer[this.index - 2];
  }
  get size() {
    return this.buffer[this.index - 1];
  }
  get pos() {
    return this.index;
  }
  next() {
    this.index -= 4;
  }
  fork() {
    return new FlatBufferCursor(this.buffer, this.index);
  }
};
var TreeBuffer = class {
  constructor(buffer, length, set) {
    this.buffer = buffer;
    this.length = length;
    this.set = set;
  }
  get type() {
    return NodeType.none;
  }
  toString() {
    let result = [];
    for (let index = 0; index < this.buffer.length; ) {
      result.push(this.childString(index));
      index = this.buffer[index + 3];
    }
    return result.join(",");
  }
  childString(index) {
    let id2 = this.buffer[index], endIndex = this.buffer[index + 3];
    let type = this.set.types[id2], result = type.name;
    if (/\W/.test(result) && !type.isError)
      result = JSON.stringify(result);
    index += 4;
    if (endIndex == index)
      return result;
    let children = [];
    while (index < endIndex) {
      children.push(this.childString(index));
      index = this.buffer[index + 3];
    }
    return result + "(" + children.join(",") + ")";
  }
  findChild(startIndex, endIndex, dir, pos, side) {
    let { buffer } = this, pick = -1;
    for (let i = startIndex; i != endIndex; i = buffer[i + 3]) {
      if (checkSide(side, pos, buffer[i + 1], buffer[i + 2])) {
        pick = i;
        if (dir > 0)
          break;
      }
    }
    return pick;
  }
  slice(startI, endI, from, to) {
    let b = this.buffer;
    let copy = new Uint16Array(endI - startI);
    for (let i = startI, j = 0; i < endI; ) {
      copy[j++] = b[i++];
      copy[j++] = b[i++] - from;
      copy[j++] = b[i++] - from;
      copy[j++] = b[i++] - startI;
    }
    return new TreeBuffer(copy, to - from, this.set);
  }
};
function checkSide(side, pos, from, to) {
  switch (side) {
    case -2:
      return from < pos;
    case -1:
      return to >= pos && from < pos;
    case 0:
      return from < pos && to > pos;
    case 1:
      return from <= pos && to > pos;
    case 2:
      return to > pos;
    case 4:
      return true;
  }
}
function enterUnfinishedNodesBefore(node, pos) {
  let scan = node.childBefore(pos);
  while (scan) {
    let last = scan.lastChild;
    if (!last || last.to != scan.to)
      break;
    if (last.type.isError && last.from == last.to) {
      node = scan;
      scan = last.prevSibling;
    } else {
      scan = last;
    }
  }
  return node;
}
function resolveNode(node, pos, side, overlays) {
  var _a;
  while (node.from == node.to || (side < 1 ? node.from >= pos : node.from > pos) || (side > -1 ? node.to <= pos : node.to < pos)) {
    let parent = !overlays && node instanceof TreeNode && node.index < 0 ? null : node.parent;
    if (!parent)
      return node;
    node = parent;
  }
  let mode = overlays ? 0 : IterMode.IgnoreOverlays;
  if (overlays)
    for (let scan = node, parent = scan.parent; parent; scan = parent, parent = scan.parent) {
      if (scan instanceof TreeNode && scan.index < 0 && ((_a = parent.enter(pos, side, mode)) === null || _a === void 0 ? void 0 : _a.from) != scan.from)
        node = parent;
    }
  for (; ; ) {
    let inner = node.enter(pos, side, mode);
    if (!inner)
      return node;
    node = inner;
  }
}
var TreeNode = class {
  constructor(_tree, from, index, _parent) {
    this._tree = _tree;
    this.from = from;
    this.index = index;
    this._parent = _parent;
  }
  get type() {
    return this._tree.type;
  }
  get name() {
    return this._tree.type.name;
  }
  get to() {
    return this.from + this._tree.length;
  }
  nextChild(i, dir, pos, side, mode = 0) {
    for (let parent = this; ; ) {
      for (let { children, positions } = parent._tree, e = dir > 0 ? children.length : -1; i != e; i += dir) {
        let next = children[i], start = positions[i] + parent.from;
        if (!checkSide(side, pos, start, start + next.length))
          continue;
        if (next instanceof TreeBuffer) {
          if (mode & IterMode.ExcludeBuffers)
            continue;
          let index = next.findChild(0, next.buffer.length, dir, pos - start, side);
          if (index > -1)
            return new BufferNode(new BufferContext(parent, next, i, start), null, index);
        } else if (mode & IterMode.IncludeAnonymous || (!next.type.isAnonymous || hasChild(next))) {
          let mounted;
          if (!(mode & IterMode.IgnoreMounts) && next.props && (mounted = next.prop(NodeProp.mounted)) && !mounted.overlay)
            return new TreeNode(mounted.tree, start, i, parent);
          let inner = new TreeNode(next, start, i, parent);
          return mode & IterMode.IncludeAnonymous || !inner.type.isAnonymous ? inner : inner.nextChild(dir < 0 ? next.children.length - 1 : 0, dir, pos, side);
        }
      }
      if (mode & IterMode.IncludeAnonymous || !parent.type.isAnonymous)
        return null;
      if (parent.index >= 0)
        i = parent.index + dir;
      else
        i = dir < 0 ? -1 : parent._parent._tree.children.length;
      parent = parent._parent;
      if (!parent)
        return null;
    }
  }
  get firstChild() {
    return this.nextChild(0, 1, 0, 4);
  }
  get lastChild() {
    return this.nextChild(this._tree.children.length - 1, -1, 0, 4);
  }
  childAfter(pos) {
    return this.nextChild(0, 1, pos, 2);
  }
  childBefore(pos) {
    return this.nextChild(this._tree.children.length - 1, -1, pos, -2);
  }
  enter(pos, side, mode = 0) {
    let mounted;
    if (!(mode & IterMode.IgnoreOverlays) && (mounted = this._tree.prop(NodeProp.mounted)) && mounted.overlay) {
      let rPos = pos - this.from;
      for (let { from, to } of mounted.overlay) {
        if ((side > 0 ? from <= rPos : from < rPos) && (side < 0 ? to >= rPos : to > rPos))
          return new TreeNode(mounted.tree, mounted.overlay[0].from + this.from, -1, this);
      }
    }
    return this.nextChild(0, 1, pos, side, mode);
  }
  nextSignificantParent() {
    let val = this;
    while (val.type.isAnonymous && val._parent)
      val = val._parent;
    return val;
  }
  get parent() {
    return this._parent ? this._parent.nextSignificantParent() : null;
  }
  get nextSibling() {
    return this._parent && this.index >= 0 ? this._parent.nextChild(this.index + 1, 1, 0, 4) : null;
  }
  get prevSibling() {
    return this._parent && this.index >= 0 ? this._parent.nextChild(this.index - 1, -1, 0, 4) : null;
  }
  cursor(mode = 0) {
    return new TreeCursor(this, mode);
  }
  get tree() {
    return this._tree;
  }
  toTree() {
    return this._tree;
  }
  resolve(pos, side = 0) {
    return resolveNode(this, pos, side, false);
  }
  resolveInner(pos, side = 0) {
    return resolveNode(this, pos, side, true);
  }
  enterUnfinishedNodesBefore(pos) {
    return enterUnfinishedNodesBefore(this, pos);
  }
  getChild(type, before = null, after = null) {
    let r = getChildren(this, type, before, after);
    return r.length ? r[0] : null;
  }
  getChildren(type, before = null, after = null) {
    return getChildren(this, type, before, after);
  }
  toString() {
    return this._tree.toString();
  }
  get node() {
    return this;
  }
  matchContext(context) {
    return matchNodeContext(this, context);
  }
};
function getChildren(node, type, before, after) {
  let cur = node.cursor(), result = [];
  if (!cur.firstChild())
    return result;
  if (before != null) {
    while (!cur.type.is(before))
      if (!cur.nextSibling())
        return result;
  }
  for (; ; ) {
    if (after != null && cur.type.is(after))
      return result;
    if (cur.type.is(type))
      result.push(cur.node);
    if (!cur.nextSibling())
      return after == null ? result : [];
  }
}
function matchNodeContext(node, context, i = context.length - 1) {
  for (let p = node.parent; i >= 0; p = p.parent) {
    if (!p)
      return false;
    if (!p.type.isAnonymous) {
      if (context[i] && context[i] != p.name)
        return false;
      i--;
    }
  }
  return true;
}
var BufferContext = class {
  constructor(parent, buffer, index, start) {
    this.parent = parent;
    this.buffer = buffer;
    this.index = index;
    this.start = start;
  }
};
var BufferNode = class {
  constructor(context, _parent, index) {
    this.context = context;
    this._parent = _parent;
    this.index = index;
    this.type = context.buffer.set.types[context.buffer.buffer[index]];
  }
  get name() {
    return this.type.name;
  }
  get from() {
    return this.context.start + this.context.buffer.buffer[this.index + 1];
  }
  get to() {
    return this.context.start + this.context.buffer.buffer[this.index + 2];
  }
  child(dir, pos, side) {
    let { buffer } = this.context;
    let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.context.start, side);
    return index < 0 ? null : new BufferNode(this.context, this, index);
  }
  get firstChild() {
    return this.child(1, 0, 4);
  }
  get lastChild() {
    return this.child(-1, 0, 4);
  }
  childAfter(pos) {
    return this.child(1, pos, 2);
  }
  childBefore(pos) {
    return this.child(-1, pos, -2);
  }
  enter(pos, side, mode = 0) {
    if (mode & IterMode.ExcludeBuffers)
      return null;
    let { buffer } = this.context;
    let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], side > 0 ? 1 : -1, pos - this.context.start, side);
    return index < 0 ? null : new BufferNode(this.context, this, index);
  }
  get parent() {
    return this._parent || this.context.parent.nextSignificantParent();
  }
  externalSibling(dir) {
    return this._parent ? null : this.context.parent.nextChild(this.context.index + dir, dir, 0, 4);
  }
  get nextSibling() {
    let { buffer } = this.context;
    let after = buffer.buffer[this.index + 3];
    if (after < (this._parent ? buffer.buffer[this._parent.index + 3] : buffer.buffer.length))
      return new BufferNode(this.context, this._parent, after);
    return this.externalSibling(1);
  }
  get prevSibling() {
    let { buffer } = this.context;
    let parentStart = this._parent ? this._parent.index + 4 : 0;
    if (this.index == parentStart)
      return this.externalSibling(-1);
    return new BufferNode(this.context, this._parent, buffer.findChild(parentStart, this.index, -1, 0, 4));
  }
  cursor(mode = 0) {
    return new TreeCursor(this, mode);
  }
  get tree() {
    return null;
  }
  toTree() {
    let children = [], positions = [];
    let { buffer } = this.context;
    let startI = this.index + 4, endI = buffer.buffer[this.index + 3];
    if (endI > startI) {
      let from = buffer.buffer[this.index + 1], to = buffer.buffer[this.index + 2];
      children.push(buffer.slice(startI, endI, from, to));
      positions.push(0);
    }
    return new Tree(this.type, children, positions, this.to - this.from);
  }
  resolve(pos, side = 0) {
    return resolveNode(this, pos, side, false);
  }
  resolveInner(pos, side = 0) {
    return resolveNode(this, pos, side, true);
  }
  enterUnfinishedNodesBefore(pos) {
    return enterUnfinishedNodesBefore(this, pos);
  }
  toString() {
    return this.context.buffer.childString(this.index);
  }
  getChild(type, before = null, after = null) {
    let r = getChildren(this, type, before, after);
    return r.length ? r[0] : null;
  }
  getChildren(type, before = null, after = null) {
    return getChildren(this, type, before, after);
  }
  get node() {
    return this;
  }
  matchContext(context) {
    return matchNodeContext(this, context);
  }
};
var TreeCursor = class {
  constructor(node, mode = 0) {
    this.mode = mode;
    this.buffer = null;
    this.stack = [];
    this.index = 0;
    this.bufferNode = null;
    if (node instanceof TreeNode) {
      this.yieldNode(node);
    } else {
      this._tree = node.context.parent;
      this.buffer = node.context;
      for (let n = node._parent; n; n = n._parent)
        this.stack.unshift(n.index);
      this.bufferNode = node;
      this.yieldBuf(node.index);
    }
  }
  get name() {
    return this.type.name;
  }
  yieldNode(node) {
    if (!node)
      return false;
    this._tree = node;
    this.type = node.type;
    this.from = node.from;
    this.to = node.to;
    return true;
  }
  yieldBuf(index, type) {
    this.index = index;
    let { start, buffer } = this.buffer;
    this.type = type || buffer.set.types[buffer.buffer[index]];
    this.from = start + buffer.buffer[index + 1];
    this.to = start + buffer.buffer[index + 2];
    return true;
  }
  yield(node) {
    if (!node)
      return false;
    if (node instanceof TreeNode) {
      this.buffer = null;
      return this.yieldNode(node);
    }
    this.buffer = node.context;
    return this.yieldBuf(node.index, node.type);
  }
  toString() {
    return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString();
  }
  enterChild(dir, pos, side) {
    if (!this.buffer)
      return this.yield(this._tree.nextChild(dir < 0 ? this._tree._tree.children.length - 1 : 0, dir, pos, side, this.mode));
    let { buffer } = this.buffer;
    let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.buffer.start, side);
    if (index < 0)
      return false;
    this.stack.push(this.index);
    return this.yieldBuf(index);
  }
  firstChild() {
    return this.enterChild(1, 0, 4);
  }
  lastChild() {
    return this.enterChild(-1, 0, 4);
  }
  childAfter(pos) {
    return this.enterChild(1, pos, 2);
  }
  childBefore(pos) {
    return this.enterChild(-1, pos, -2);
  }
  enter(pos, side, mode = this.mode) {
    if (!this.buffer)
      return this.yield(this._tree.enter(pos, side, mode));
    return mode & IterMode.ExcludeBuffers ? false : this.enterChild(1, pos, side);
  }
  parent() {
    if (!this.buffer)
      return this.yieldNode(this.mode & IterMode.IncludeAnonymous ? this._tree._parent : this._tree.parent);
    if (this.stack.length)
      return this.yieldBuf(this.stack.pop());
    let parent = this.mode & IterMode.IncludeAnonymous ? this.buffer.parent : this.buffer.parent.nextSignificantParent();
    this.buffer = null;
    return this.yieldNode(parent);
  }
  sibling(dir) {
    if (!this.buffer)
      return !this._tree._parent ? false : this.yield(this._tree.index < 0 ? null : this._tree._parent.nextChild(this._tree.index + dir, dir, 0, 4, this.mode));
    let { buffer } = this.buffer, d = this.stack.length - 1;
    if (dir < 0) {
      let parentStart = d < 0 ? 0 : this.stack[d] + 4;
      if (this.index != parentStart)
        return this.yieldBuf(buffer.findChild(parentStart, this.index, -1, 0, 4));
    } else {
      let after = buffer.buffer[this.index + 3];
      if (after < (d < 0 ? buffer.buffer.length : buffer.buffer[this.stack[d] + 3]))
        return this.yieldBuf(after);
    }
    return d < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + dir, dir, 0, 4, this.mode)) : false;
  }
  nextSibling() {
    return this.sibling(1);
  }
  prevSibling() {
    return this.sibling(-1);
  }
  atLastNode(dir) {
    let index, parent, { buffer } = this;
    if (buffer) {
      if (dir > 0) {
        if (this.index < buffer.buffer.buffer.length)
          return false;
      } else {
        for (let i = 0; i < this.index; i++)
          if (buffer.buffer.buffer[i + 3] < this.index)
            return false;
      }
      ({ index, parent } = buffer);
    } else {
      ({ index, _parent: parent } = this._tree);
    }
    for (; parent; { index, _parent: parent } = parent) {
      if (index > -1)
        for (let i = index + dir, e = dir < 0 ? -1 : parent._tree.children.length; i != e; i += dir) {
          let child = parent._tree.children[i];
          if (this.mode & IterMode.IncludeAnonymous || child instanceof TreeBuffer || !child.type.isAnonymous || hasChild(child))
            return false;
        }
    }
    return true;
  }
  move(dir, enter) {
    if (enter && this.enterChild(dir, 0, 4))
      return true;
    for (; ; ) {
      if (this.sibling(dir))
        return true;
      if (this.atLastNode(dir) || !this.parent())
        return false;
    }
  }
  next(enter = true) {
    return this.move(1, enter);
  }
  prev(enter = true) {
    return this.move(-1, enter);
  }
  moveTo(pos, side = 0) {
    while (this.from == this.to || (side < 1 ? this.from >= pos : this.from > pos) || (side > -1 ? this.to <= pos : this.to < pos))
      if (!this.parent())
        break;
    while (this.enterChild(1, pos, side)) {
    }
    return this;
  }
  get node() {
    if (!this.buffer)
      return this._tree;
    let cache = this.bufferNode, result = null, depth = 0;
    if (cache && cache.context == this.buffer) {
      scan:
        for (let index = this.index, d = this.stack.length; d >= 0; ) {
          for (let c = cache; c; c = c._parent)
            if (c.index == index) {
              if (index == this.index)
                return c;
              result = c;
              depth = d + 1;
              break scan;
            }
          index = this.stack[--d];
        }
    }
    for (let i = depth; i < this.stack.length; i++)
      result = new BufferNode(this.buffer, result, this.stack[i]);
    return this.bufferNode = new BufferNode(this.buffer, result, this.index);
  }
  get tree() {
    return this.buffer ? null : this._tree._tree;
  }
  iterate(enter, leave) {
    for (let depth = 0; ; ) {
      let mustLeave = false;
      if (this.type.isAnonymous || enter(this) !== false) {
        if (this.firstChild()) {
          depth++;
          continue;
        }
        if (!this.type.isAnonymous)
          mustLeave = true;
      }
      for (; ; ) {
        if (mustLeave && leave)
          leave(this);
        mustLeave = this.type.isAnonymous;
        if (this.nextSibling())
          break;
        if (!depth)
          return;
        this.parent();
        depth--;
        mustLeave = true;
      }
    }
  }
  matchContext(context) {
    if (!this.buffer)
      return matchNodeContext(this.node, context);
    let { buffer } = this.buffer, { types } = buffer.set;
    for (let i = context.length - 1, d = this.stack.length - 1; i >= 0; d--) {
      if (d < 0)
        return matchNodeContext(this.node, context, i);
      let type = types[buffer.buffer[this.stack[d]]];
      if (!type.isAnonymous) {
        if (context[i] && context[i] != type.name)
          return false;
        i--;
      }
    }
    return true;
  }
};
function hasChild(tree) {
  return tree.children.some((ch) => ch instanceof TreeBuffer || !ch.type.isAnonymous || hasChild(ch));
}
function buildTree(data) {
  var _a;
  let { buffer, nodeSet, maxBufferLength = DefaultBufferLength, reused = [], minRepeatType = nodeSet.types.length } = data;
  let cursor = Array.isArray(buffer) ? new FlatBufferCursor(buffer, buffer.length) : buffer;
  let types = nodeSet.types;
  let contextHash = 0, lookAhead = 0;
  function takeNode(parentStart, minPos, children2, positions2, inRepeat) {
    let { id: id2, start, end, size } = cursor;
    let lookAheadAtStart = lookAhead;
    while (size < 0) {
      cursor.next();
      if (size == -1) {
        let node2 = reused[id2];
        children2.push(node2);
        positions2.push(start - parentStart);
        return;
      } else if (size == -3) {
        contextHash = id2;
        return;
      } else if (size == -4) {
        lookAhead = id2;
        return;
      } else {
        throw new RangeError(`Unrecognized record size: ${size}`);
      }
    }
    let type = types[id2], node, buffer2;
    let startPos = start - parentStart;
    if (end - start <= maxBufferLength && (buffer2 = findBufferSize(cursor.pos - minPos, inRepeat))) {
      let data2 = new Uint16Array(buffer2.size - buffer2.skip);
      let endPos = cursor.pos - buffer2.size, index = data2.length;
      while (cursor.pos > endPos)
        index = copyToBuffer(buffer2.start, data2, index);
      node = new TreeBuffer(data2, end - buffer2.start, nodeSet);
      startPos = buffer2.start - parentStart;
    } else {
      let endPos = cursor.pos - size;
      cursor.next();
      let localChildren = [], localPositions = [];
      let localInRepeat = id2 >= minRepeatType ? id2 : -1;
      let lastGroup = 0, lastEnd = end;
      while (cursor.pos > endPos) {
        if (localInRepeat >= 0 && cursor.id == localInRepeat && cursor.size >= 0) {
          if (cursor.end <= lastEnd - maxBufferLength) {
            makeRepeatLeaf(localChildren, localPositions, start, lastGroup, cursor.end, lastEnd, localInRepeat, lookAheadAtStart);
            lastGroup = localChildren.length;
            lastEnd = cursor.end;
          }
          cursor.next();
        } else {
          takeNode(start, endPos, localChildren, localPositions, localInRepeat);
        }
      }
      if (localInRepeat >= 0 && lastGroup > 0 && lastGroup < localChildren.length)
        makeRepeatLeaf(localChildren, localPositions, start, lastGroup, start, lastEnd, localInRepeat, lookAheadAtStart);
      localChildren.reverse();
      localPositions.reverse();
      if (localInRepeat > -1 && lastGroup > 0) {
        let make = makeBalanced(type);
        node = balanceRange(type, localChildren, localPositions, 0, localChildren.length, 0, end - start, make, make);
      } else {
        node = makeTree(type, localChildren, localPositions, end - start, lookAheadAtStart - end);
      }
    }
    children2.push(node);
    positions2.push(startPos);
  }
  function makeBalanced(type) {
    return (children2, positions2, length2) => {
      let lookAhead2 = 0, lastI = children2.length - 1, last, lookAheadProp;
      if (lastI >= 0 && (last = children2[lastI]) instanceof Tree) {
        if (!lastI && last.type == type && last.length == length2)
          return last;
        if (lookAheadProp = last.prop(NodeProp.lookAhead))
          lookAhead2 = positions2[lastI] + last.length + lookAheadProp;
      }
      return makeTree(type, children2, positions2, length2, lookAhead2);
    };
  }
  function makeRepeatLeaf(children2, positions2, base, i, from, to, type, lookAhead2) {
    let localChildren = [], localPositions = [];
    while (children2.length > i) {
      localChildren.push(children2.pop());
      localPositions.push(positions2.pop() + base - from);
    }
    children2.push(makeTree(nodeSet.types[type], localChildren, localPositions, to - from, lookAhead2 - to));
    positions2.push(from - base);
  }
  function makeTree(type, children2, positions2, length2, lookAhead2 = 0, props) {
    if (contextHash) {
      let pair2 = [NodeProp.contextHash, contextHash];
      props = props ? [pair2].concat(props) : [pair2];
    }
    if (lookAhead2 > 25) {
      let pair2 = [NodeProp.lookAhead, lookAhead2];
      props = props ? [pair2].concat(props) : [pair2];
    }
    return new Tree(type, children2, positions2, length2, props);
  }
  function findBufferSize(maxSize, inRepeat) {
    let fork = cursor.fork();
    let size = 0, start = 0, skip = 0, minStart = fork.end - maxBufferLength;
    let result = { size: 0, start: 0, skip: 0 };
    scan:
      for (let minPos = fork.pos - maxSize; fork.pos > minPos; ) {
        let nodeSize2 = fork.size;
        if (fork.id == inRepeat && nodeSize2 >= 0) {
          result.size = size;
          result.start = start;
          result.skip = skip;
          skip += 4;
          size += 4;
          fork.next();
          continue;
        }
        let startPos = fork.pos - nodeSize2;
        if (nodeSize2 < 0 || startPos < minPos || fork.start < minStart)
          break;
        let localSkipped = fork.id >= minRepeatType ? 4 : 0;
        let nodeStart = fork.start;
        fork.next();
        while (fork.pos > startPos) {
          if (fork.size < 0) {
            if (fork.size == -3)
              localSkipped += 4;
            else
              break scan;
          } else if (fork.id >= minRepeatType) {
            localSkipped += 4;
          }
          fork.next();
        }
        start = nodeStart;
        size += nodeSize2;
        skip += localSkipped;
      }
    if (inRepeat < 0 || size == maxSize) {
      result.size = size;
      result.start = start;
      result.skip = skip;
    }
    return result.size > 4 ? result : void 0;
  }
  function copyToBuffer(bufferStart, buffer2, index) {
    let { id: id2, start, end, size } = cursor;
    cursor.next();
    if (size >= 0 && id2 < minRepeatType) {
      let startIndex = index;
      if (size > 4) {
        let endPos = cursor.pos - (size - 4);
        while (cursor.pos > endPos)
          index = copyToBuffer(bufferStart, buffer2, index);
      }
      buffer2[--index] = startIndex;
      buffer2[--index] = end - bufferStart;
      buffer2[--index] = start - bufferStart;
      buffer2[--index] = id2;
    } else if (size == -3) {
      contextHash = id2;
    } else if (size == -4) {
      lookAhead = id2;
    }
    return index;
  }
  let children = [], positions = [];
  while (cursor.pos > 0)
    takeNode(data.start || 0, data.bufferStart || 0, children, positions, -1);
  let length = (_a = data.length) !== null && _a !== void 0 ? _a : children.length ? positions[0] + children[0].length : 0;
  return new Tree(types[data.topID], children.reverse(), positions.reverse(), length);
}
var nodeSizeCache = /* @__PURE__ */ new WeakMap();
function nodeSize(balanceType, node) {
  if (!balanceType.isAnonymous || node instanceof TreeBuffer || node.type != balanceType)
    return 1;
  let size = nodeSizeCache.get(node);
  if (size == null) {
    size = 1;
    for (let child of node.children) {
      if (child.type != balanceType || !(child instanceof Tree)) {
        size = 1;
        break;
      }
      size += nodeSize(balanceType, child);
    }
    nodeSizeCache.set(node, size);
  }
  return size;
}
function balanceRange(balanceType, children, positions, from, to, start, length, mkTop, mkTree) {
  let total = 0;
  for (let i = from; i < to; i++)
    total += nodeSize(balanceType, children[i]);
  let maxChild = Math.ceil(total * 1.5 / 8);
  let localChildren = [], localPositions = [];
  function divide(children2, positions2, from2, to2, offset) {
    for (let i = from2; i < to2; ) {
      let groupFrom = i, groupStart = positions2[i], groupSize = nodeSize(balanceType, children2[i]);
      i++;
      for (; i < to2; i++) {
        let nextSize = nodeSize(balanceType, children2[i]);
        if (groupSize + nextSize >= maxChild)
          break;
        groupSize += nextSize;
      }
      if (i == groupFrom + 1) {
        if (groupSize > maxChild) {
          let only = children2[groupFrom];
          divide(only.children, only.positions, 0, only.children.length, positions2[groupFrom] + offset);
          continue;
        }
        localChildren.push(children2[groupFrom]);
      } else {
        let length2 = positions2[i - 1] + children2[i - 1].length - groupStart;
        localChildren.push(balanceRange(balanceType, children2, positions2, groupFrom, i, groupStart, length2, null, mkTree));
      }
      localPositions.push(groupStart + offset - start);
    }
  }
  divide(children, positions, from, to, 0);
  return (mkTop || mkTree)(localChildren, localPositions, length);
}
var Parser = class {
  startParse(input, fragments, ranges) {
    if (typeof input == "string")
      input = new StringInput(input);
    ranges = !ranges ? [new Range(0, input.length)] : ranges.length ? ranges.map((r) => new Range(r.from, r.to)) : [new Range(0, 0)];
    return this.createParse(input, fragments || [], ranges);
  }
  parse(input, fragments, ranges) {
    let parse = this.startParse(input, fragments, ranges);
    for (; ; ) {
      let done = parse.advance();
      if (done)
        return done;
    }
  }
};
var StringInput = class {
  constructor(string2) {
    this.string = string2;
  }
  get length() {
    return this.string.length;
  }
  chunk(from) {
    return this.string.slice(from);
  }
  get lineChunks() {
    return false;
  }
  read(from, to) {
    return this.string.slice(from, to);
  }
};
var stoppedInner = new NodeProp({ perNode: true });

// node_modules/@lezer/lr/dist/index.js
var Stack = class {
  constructor(p, stack, state, reducePos, pos, score, buffer, bufferBase, curContext, lookAhead = 0, parent) {
    this.p = p;
    this.stack = stack;
    this.state = state;
    this.reducePos = reducePos;
    this.pos = pos;
    this.score = score;
    this.buffer = buffer;
    this.bufferBase = bufferBase;
    this.curContext = curContext;
    this.lookAhead = lookAhead;
    this.parent = parent;
  }
  toString() {
    return `[${this.stack.filter((_, i) => i % 3 == 0).concat(this.state)}]@${this.pos}${this.score ? "!" + this.score : ""}`;
  }
  static start(p, state, pos = 0) {
    let cx = p.parser.context;
    return new Stack(p, [], state, pos, pos, 0, [], 0, cx ? new StackContext(cx, cx.start) : null, 0, null);
  }
  get context() {
    return this.curContext ? this.curContext.context : null;
  }
  pushState(state, start) {
    this.stack.push(this.state, start, this.bufferBase + this.buffer.length);
    this.state = state;
  }
  reduce(action) {
    let depth = action >> 19, type = action & 65535;
    let { parser: parser2 } = this.p;
    let dPrec = parser2.dynamicPrecedence(type);
    if (dPrec)
      this.score += dPrec;
    if (depth == 0) {
      this.pushState(parser2.getGoto(this.state, type, true), this.reducePos);
      if (type < parser2.minRepeatTerm)
        this.storeNode(type, this.reducePos, this.reducePos, 4, true);
      this.reduceContext(type, this.reducePos);
      return;
    }
    let base = this.stack.length - (depth - 1) * 3 - (action & 262144 ? 6 : 0);
    let start = this.stack[base - 2];
    let bufferBase = this.stack[base - 1], count = this.bufferBase + this.buffer.length - bufferBase;
    if (type < parser2.minRepeatTerm || action & 131072) {
      let pos = parser2.stateFlag(this.state, 1) ? this.pos : this.reducePos;
      this.storeNode(type, start, pos, count + 4, true);
    }
    if (action & 262144) {
      this.state = this.stack[base];
    } else {
      let baseStateID = this.stack[base - 3];
      this.state = parser2.getGoto(baseStateID, type, true);
    }
    while (this.stack.length > base)
      this.stack.pop();
    this.reduceContext(type, start);
  }
  storeNode(term, start, end, size = 4, isReduce = false) {
    if (term == 0 && (!this.stack.length || this.stack[this.stack.length - 1] < this.buffer.length + this.bufferBase)) {
      let cur = this, top = this.buffer.length;
      if (top == 0 && cur.parent) {
        top = cur.bufferBase - cur.parent.bufferBase;
        cur = cur.parent;
      }
      if (top > 0 && cur.buffer[top - 4] == 0 && cur.buffer[top - 1] > -1) {
        if (start == end)
          return;
        if (cur.buffer[top - 2] >= start) {
          cur.buffer[top - 2] = end;
          return;
        }
      }
    }
    if (!isReduce || this.pos == end) {
      this.buffer.push(term, start, end, size);
    } else {
      let index = this.buffer.length;
      if (index > 0 && this.buffer[index - 4] != 0)
        while (index > 0 && this.buffer[index - 2] > end) {
          this.buffer[index] = this.buffer[index - 4];
          this.buffer[index + 1] = this.buffer[index - 3];
          this.buffer[index + 2] = this.buffer[index - 2];
          this.buffer[index + 3] = this.buffer[index - 1];
          index -= 4;
          if (size > 4)
            size -= 4;
        }
      this.buffer[index] = term;
      this.buffer[index + 1] = start;
      this.buffer[index + 2] = end;
      this.buffer[index + 3] = size;
    }
  }
  shift(action, next, nextEnd) {
    let start = this.pos;
    if (action & 131072) {
      this.pushState(action & 65535, this.pos);
    } else if ((action & 262144) == 0) {
      let nextState = action, { parser: parser2 } = this.p;
      if (nextEnd > this.pos || next <= parser2.maxNode) {
        this.pos = nextEnd;
        if (!parser2.stateFlag(nextState, 1))
          this.reducePos = nextEnd;
      }
      this.pushState(nextState, start);
      this.shiftContext(next, start);
      if (next <= parser2.maxNode)
        this.buffer.push(next, start, nextEnd, 4);
    } else {
      this.pos = nextEnd;
      this.shiftContext(next, start);
      if (next <= this.p.parser.maxNode)
        this.buffer.push(next, start, nextEnd, 4);
    }
  }
  apply(action, next, nextEnd) {
    if (action & 65536)
      this.reduce(action);
    else
      this.shift(action, next, nextEnd);
  }
  useNode(value, next) {
    let index = this.p.reused.length - 1;
    if (index < 0 || this.p.reused[index] != value) {
      this.p.reused.push(value);
      index++;
    }
    let start = this.pos;
    this.reducePos = this.pos = start + value.length;
    this.pushState(next, start);
    this.buffer.push(index, start, this.reducePos, -1);
    if (this.curContext)
      this.updateContext(this.curContext.tracker.reuse(this.curContext.context, value, this, this.p.stream.reset(this.pos - value.length)));
  }
  split() {
    let parent = this;
    let off = parent.buffer.length;
    while (off > 0 && parent.buffer[off - 2] > parent.reducePos)
      off -= 4;
    let buffer = parent.buffer.slice(off), base = parent.bufferBase + off;
    while (parent && base == parent.bufferBase)
      parent = parent.parent;
    return new Stack(this.p, this.stack.slice(), this.state, this.reducePos, this.pos, this.score, buffer, base, this.curContext, this.lookAhead, parent);
  }
  recoverByDelete(next, nextEnd) {
    let isNode = next <= this.p.parser.maxNode;
    if (isNode)
      this.storeNode(next, this.pos, nextEnd, 4);
    this.storeNode(0, this.pos, nextEnd, isNode ? 8 : 4);
    this.pos = this.reducePos = nextEnd;
    this.score -= 190;
  }
  canShift(term) {
    for (let sim = new SimulatedStack(this); ; ) {
      let action = this.p.parser.stateSlot(sim.state, 4) || this.p.parser.hasAction(sim.state, term);
      if ((action & 65536) == 0)
        return true;
      if (action == 0)
        return false;
      sim.reduce(action);
    }
  }
  recoverByInsert(next) {
    if (this.stack.length >= 300)
      return [];
    let nextStates = this.p.parser.nextStates(this.state);
    if (nextStates.length > 4 << 1 || this.stack.length >= 120) {
      let best = [];
      for (let i = 0, s; i < nextStates.length; i += 2) {
        if ((s = nextStates[i + 1]) != this.state && this.p.parser.hasAction(s, next))
          best.push(nextStates[i], s);
      }
      if (this.stack.length < 120)
        for (let i = 0; best.length < 4 << 1 && i < nextStates.length; i += 2) {
          let s = nextStates[i + 1];
          if (!best.some((v, i2) => i2 & 1 && v == s))
            best.push(nextStates[i], s);
        }
      nextStates = best;
    }
    let result = [];
    for (let i = 0; i < nextStates.length && result.length < 4; i += 2) {
      let s = nextStates[i + 1];
      if (s == this.state)
        continue;
      let stack = this.split();
      stack.pushState(s, this.pos);
      stack.storeNode(0, stack.pos, stack.pos, 4, true);
      stack.shiftContext(nextStates[i], this.pos);
      stack.score -= 200;
      result.push(stack);
    }
    return result;
  }
  forceReduce() {
    let reduce = this.p.parser.stateSlot(this.state, 5);
    if ((reduce & 65536) == 0)
      return false;
    let { parser: parser2 } = this.p;
    if (!parser2.validAction(this.state, reduce)) {
      let depth = reduce >> 19, term = reduce & 65535;
      let target = this.stack.length - depth * 3;
      if (target < 0 || parser2.getGoto(this.stack[target], term, false) < 0)
        return false;
      this.storeNode(0, this.reducePos, this.reducePos, 4, true);
      this.score -= 100;
    }
    this.reducePos = this.pos;
    this.reduce(reduce);
    return true;
  }
  forceAll() {
    while (!this.p.parser.stateFlag(this.state, 2)) {
      if (!this.forceReduce()) {
        this.storeNode(0, this.pos, this.pos, 4, true);
        break;
      }
    }
    return this;
  }
  get deadEnd() {
    if (this.stack.length != 3)
      return false;
    let { parser: parser2 } = this.p;
    return parser2.data[parser2.stateSlot(this.state, 1)] == 65535 && !parser2.stateSlot(this.state, 4);
  }
  restart() {
    this.state = this.stack[0];
    this.stack.length = 0;
  }
  sameState(other) {
    if (this.state != other.state || this.stack.length != other.stack.length)
      return false;
    for (let i = 0; i < this.stack.length; i += 3)
      if (this.stack[i] != other.stack[i])
        return false;
    return true;
  }
  get parser() {
    return this.p.parser;
  }
  dialectEnabled(dialectID) {
    return this.p.parser.dialect.flags[dialectID];
  }
  shiftContext(term, start) {
    if (this.curContext)
      this.updateContext(this.curContext.tracker.shift(this.curContext.context, term, this, this.p.stream.reset(start)));
  }
  reduceContext(term, start) {
    if (this.curContext)
      this.updateContext(this.curContext.tracker.reduce(this.curContext.context, term, this, this.p.stream.reset(start)));
  }
  emitContext() {
    let last = this.buffer.length - 1;
    if (last < 0 || this.buffer[last] != -3)
      this.buffer.push(this.curContext.hash, this.reducePos, this.reducePos, -3);
  }
  emitLookAhead() {
    let last = this.buffer.length - 1;
    if (last < 0 || this.buffer[last] != -4)
      this.buffer.push(this.lookAhead, this.reducePos, this.reducePos, -4);
  }
  updateContext(context) {
    if (context != this.curContext.context) {
      let newCx = new StackContext(this.curContext.tracker, context);
      if (newCx.hash != this.curContext.hash)
        this.emitContext();
      this.curContext = newCx;
    }
  }
  setLookAhead(lookAhead) {
    if (lookAhead > this.lookAhead) {
      this.emitLookAhead();
      this.lookAhead = lookAhead;
    }
  }
  close() {
    if (this.curContext && this.curContext.tracker.strict)
      this.emitContext();
    if (this.lookAhead > 0)
      this.emitLookAhead();
  }
};
var StackContext = class {
  constructor(tracker, context) {
    this.tracker = tracker;
    this.context = context;
    this.hash = tracker.strict ? tracker.hash(context) : 0;
  }
};
var Recover;
(function(Recover2) {
  Recover2[Recover2["Insert"] = 200] = "Insert";
  Recover2[Recover2["Delete"] = 190] = "Delete";
  Recover2[Recover2["Reduce"] = 100] = "Reduce";
  Recover2[Recover2["MaxNext"] = 4] = "MaxNext";
  Recover2[Recover2["MaxInsertStackDepth"] = 300] = "MaxInsertStackDepth";
  Recover2[Recover2["DampenInsertStackDepth"] = 120] = "DampenInsertStackDepth";
})(Recover || (Recover = {}));
var SimulatedStack = class {
  constructor(start) {
    this.start = start;
    this.state = start.state;
    this.stack = start.stack;
    this.base = this.stack.length;
  }
  reduce(action) {
    let term = action & 65535, depth = action >> 19;
    if (depth == 0) {
      if (this.stack == this.start.stack)
        this.stack = this.stack.slice();
      this.stack.push(this.state, 0, 0);
      this.base += 3;
    } else {
      this.base -= (depth - 1) * 3;
    }
    let goto = this.start.p.parser.getGoto(this.stack[this.base - 3], term, true);
    this.state = goto;
  }
};
var StackBufferCursor = class {
  constructor(stack, pos, index) {
    this.stack = stack;
    this.pos = pos;
    this.index = index;
    this.buffer = stack.buffer;
    if (this.index == 0)
      this.maybeNext();
  }
  static create(stack, pos = stack.bufferBase + stack.buffer.length) {
    return new StackBufferCursor(stack, pos, pos - stack.bufferBase);
  }
  maybeNext() {
    let next = this.stack.parent;
    if (next != null) {
      this.index = this.stack.bufferBase - next.bufferBase;
      this.stack = next;
      this.buffer = next.buffer;
    }
  }
  get id() {
    return this.buffer[this.index - 4];
  }
  get start() {
    return this.buffer[this.index - 3];
  }
  get end() {
    return this.buffer[this.index - 2];
  }
  get size() {
    return this.buffer[this.index - 1];
  }
  next() {
    this.index -= 4;
    this.pos -= 4;
    if (this.index == 0)
      this.maybeNext();
  }
  fork() {
    return new StackBufferCursor(this.stack, this.pos, this.index);
  }
};
var CachedToken = class {
  constructor() {
    this.start = -1;
    this.value = -1;
    this.end = -1;
    this.extended = -1;
    this.lookAhead = 0;
    this.mask = 0;
    this.context = 0;
  }
};
var nullToken = new CachedToken();
var InputStream = class {
  constructor(input, ranges) {
    this.input = input;
    this.ranges = ranges;
    this.chunk = "";
    this.chunkOff = 0;
    this.chunk2 = "";
    this.chunk2Pos = 0;
    this.next = -1;
    this.token = nullToken;
    this.rangeIndex = 0;
    this.pos = this.chunkPos = ranges[0].from;
    this.range = ranges[0];
    this.end = ranges[ranges.length - 1].to;
    this.readNext();
  }
  resolveOffset(offset, assoc) {
    let range = this.range, index = this.rangeIndex;
    let pos = this.pos + offset;
    while (pos < range.from) {
      if (!index)
        return null;
      let next = this.ranges[--index];
      pos -= range.from - next.to;
      range = next;
    }
    while (assoc < 0 ? pos > range.to : pos >= range.to) {
      if (index == this.ranges.length - 1)
        return null;
      let next = this.ranges[++index];
      pos += next.from - range.to;
      range = next;
    }
    return pos;
  }
  peek(offset) {
    let idx = this.chunkOff + offset, pos, result;
    if (idx >= 0 && idx < this.chunk.length) {
      pos = this.pos + offset;
      result = this.chunk.charCodeAt(idx);
    } else {
      let resolved = this.resolveOffset(offset, 1);
      if (resolved == null)
        return -1;
      pos = resolved;
      if (pos >= this.chunk2Pos && pos < this.chunk2Pos + this.chunk2.length) {
        result = this.chunk2.charCodeAt(pos - this.chunk2Pos);
      } else {
        let i = this.rangeIndex, range = this.range;
        while (range.to <= pos)
          range = this.ranges[++i];
        this.chunk2 = this.input.chunk(this.chunk2Pos = pos);
        if (pos + this.chunk2.length > range.to)
          this.chunk2 = this.chunk2.slice(0, range.to - pos);
        result = this.chunk2.charCodeAt(0);
      }
    }
    if (pos >= this.token.lookAhead)
      this.token.lookAhead = pos + 1;
    return result;
  }
  acceptToken(token, endOffset = 0) {
    let end = endOffset ? this.resolveOffset(endOffset, -1) : this.pos;
    if (end == null || end < this.token.start)
      throw new RangeError("Token end out of bounds");
    this.token.value = token;
    this.token.end = end;
  }
  getChunk() {
    if (this.pos >= this.chunk2Pos && this.pos < this.chunk2Pos + this.chunk2.length) {
      let { chunk, chunkPos } = this;
      this.chunk = this.chunk2;
      this.chunkPos = this.chunk2Pos;
      this.chunk2 = chunk;
      this.chunk2Pos = chunkPos;
      this.chunkOff = this.pos - this.chunkPos;
    } else {
      this.chunk2 = this.chunk;
      this.chunk2Pos = this.chunkPos;
      let nextChunk = this.input.chunk(this.pos);
      let end = this.pos + nextChunk.length;
      this.chunk = end > this.range.to ? nextChunk.slice(0, this.range.to - this.pos) : nextChunk;
      this.chunkPos = this.pos;
      this.chunkOff = 0;
    }
  }
  readNext() {
    if (this.chunkOff >= this.chunk.length) {
      this.getChunk();
      if (this.chunkOff == this.chunk.length)
        return this.next = -1;
    }
    return this.next = this.chunk.charCodeAt(this.chunkOff);
  }
  advance(n = 1) {
    this.chunkOff += n;
    while (this.pos + n >= this.range.to) {
      if (this.rangeIndex == this.ranges.length - 1)
        return this.setDone();
      n -= this.range.to - this.pos;
      this.range = this.ranges[++this.rangeIndex];
      this.pos = this.range.from;
    }
    this.pos += n;
    if (this.pos >= this.token.lookAhead)
      this.token.lookAhead = this.pos + 1;
    return this.readNext();
  }
  setDone() {
    this.pos = this.chunkPos = this.end;
    this.range = this.ranges[this.rangeIndex = this.ranges.length - 1];
    this.chunk = "";
    return this.next = -1;
  }
  reset(pos, token) {
    if (token) {
      this.token = token;
      token.start = pos;
      token.lookAhead = pos + 1;
      token.value = token.extended = -1;
    } else {
      this.token = nullToken;
    }
    if (this.pos != pos) {
      this.pos = pos;
      if (pos == this.end) {
        this.setDone();
        return this;
      }
      while (pos < this.range.from)
        this.range = this.ranges[--this.rangeIndex];
      while (pos >= this.range.to)
        this.range = this.ranges[++this.rangeIndex];
      if (pos >= this.chunkPos && pos < this.chunkPos + this.chunk.length) {
        this.chunkOff = pos - this.chunkPos;
      } else {
        this.chunk = "";
        this.chunkOff = 0;
      }
      this.readNext();
    }
    return this;
  }
  read(from, to) {
    if (from >= this.chunkPos && to <= this.chunkPos + this.chunk.length)
      return this.chunk.slice(from - this.chunkPos, to - this.chunkPos);
    if (from >= this.chunk2Pos && to <= this.chunk2Pos + this.chunk2.length)
      return this.chunk2.slice(from - this.chunk2Pos, to - this.chunk2Pos);
    if (from >= this.range.from && to <= this.range.to)
      return this.input.read(from, to);
    let result = "";
    for (let r of this.ranges) {
      if (r.from >= to)
        break;
      if (r.to > from)
        result += this.input.read(Math.max(r.from, from), Math.min(r.to, to));
    }
    return result;
  }
};
var TokenGroup = class {
  constructor(data, id2) {
    this.data = data;
    this.id = id2;
  }
  token(input, stack) {
    readToken(this.data, input, stack, this.id);
  }
};
TokenGroup.prototype.contextual = TokenGroup.prototype.fallback = TokenGroup.prototype.extend = false;
var ExternalTokenizer = class {
  constructor(token, options = {}) {
    this.token = token;
    this.contextual = !!options.contextual;
    this.fallback = !!options.fallback;
    this.extend = !!options.extend;
  }
};
function readToken(data, input, stack, group) {
  let state = 0, groupMask = 1 << group, { parser: parser2 } = stack.p, { dialect } = parser2;
  scan:
    for (; ; ) {
      if ((groupMask & data[state]) == 0)
        break;
      let accEnd = data[state + 1];
      for (let i = state + 3; i < accEnd; i += 2)
        if ((data[i + 1] & groupMask) > 0) {
          let term = data[i];
          if (dialect.allows(term) && (input.token.value == -1 || input.token.value == term || parser2.overrides(term, input.token.value))) {
            input.acceptToken(term);
            break;
          }
        }
      let next = input.next, low = 0, high = data[state + 2];
      if (input.next < 0 && high > low && data[accEnd + high * 3 - 3] == 65535) {
        state = data[accEnd + high * 3 - 1];
        continue scan;
      }
      for (; low < high; ) {
        let mid = low + high >> 1;
        let index = accEnd + mid + (mid << 1);
        let from = data[index], to = data[index + 1];
        if (next < from)
          high = mid;
        else if (next >= to)
          low = mid + 1;
        else {
          state = data[index + 2];
          input.advance();
          continue scan;
        }
      }
      break;
    }
}
function decodeArray(input, Type = Uint16Array) {
  if (typeof input != "string")
    return input;
  let array = null;
  for (let pos = 0, out = 0; pos < input.length; ) {
    let value = 0;
    for (; ; ) {
      let next = input.charCodeAt(pos++), stop = false;
      if (next == 126) {
        value = 65535;
        break;
      }
      if (next >= 92)
        next--;
      if (next >= 34)
        next--;
      let digit = next - 32;
      if (digit >= 46) {
        digit -= 46;
        stop = true;
      }
      value += digit;
      if (stop)
        break;
      value *= 46;
    }
    if (array)
      array[out++] = value;
    else
      array = new Type(value);
  }
  return array;
}
var verbose = typeof process != "undefined" && process.env && /\bparse\b/.test(process.env.LOG);
var stackIDs = null;
var Safety;
(function(Safety2) {
  Safety2[Safety2["Margin"] = 25] = "Margin";
})(Safety || (Safety = {}));
function cutAt(tree, pos, side) {
  let cursor = tree.cursor(IterMode.IncludeAnonymous);
  cursor.moveTo(pos);
  for (; ; ) {
    if (!(side < 0 ? cursor.childBefore(pos) : cursor.childAfter(pos)))
      for (; ; ) {
        if ((side < 0 ? cursor.to < pos : cursor.from > pos) && !cursor.type.isError)
          return side < 0 ? Math.max(0, Math.min(cursor.to - 1, pos - 25)) : Math.min(tree.length, Math.max(cursor.from + 1, pos + 25));
        if (side < 0 ? cursor.prevSibling() : cursor.nextSibling())
          break;
        if (!cursor.parent())
          return side < 0 ? 0 : tree.length;
      }
  }
}
var FragmentCursor = class {
  constructor(fragments, nodeSet) {
    this.fragments = fragments;
    this.nodeSet = nodeSet;
    this.i = 0;
    this.fragment = null;
    this.safeFrom = -1;
    this.safeTo = -1;
    this.trees = [];
    this.start = [];
    this.index = [];
    this.nextFragment();
  }
  nextFragment() {
    let fr = this.fragment = this.i == this.fragments.length ? null : this.fragments[this.i++];
    if (fr) {
      this.safeFrom = fr.openStart ? cutAt(fr.tree, fr.from + fr.offset, 1) - fr.offset : fr.from;
      this.safeTo = fr.openEnd ? cutAt(fr.tree, fr.to + fr.offset, -1) - fr.offset : fr.to;
      while (this.trees.length) {
        this.trees.pop();
        this.start.pop();
        this.index.pop();
      }
      this.trees.push(fr.tree);
      this.start.push(-fr.offset);
      this.index.push(0);
      this.nextStart = this.safeFrom;
    } else {
      this.nextStart = 1e9;
    }
  }
  nodeAt(pos) {
    if (pos < this.nextStart)
      return null;
    while (this.fragment && this.safeTo <= pos)
      this.nextFragment();
    if (!this.fragment)
      return null;
    for (; ; ) {
      let last = this.trees.length - 1;
      if (last < 0) {
        this.nextFragment();
        return null;
      }
      let top = this.trees[last], index = this.index[last];
      if (index == top.children.length) {
        this.trees.pop();
        this.start.pop();
        this.index.pop();
        continue;
      }
      let next = top.children[index];
      let start = this.start[last] + top.positions[index];
      if (start > pos) {
        this.nextStart = start;
        return null;
      }
      if (next instanceof Tree) {
        if (start == pos) {
          if (start < this.safeFrom)
            return null;
          let end = start + next.length;
          if (end <= this.safeTo) {
            let lookAhead = next.prop(NodeProp.lookAhead);
            if (!lookAhead || end + lookAhead < this.fragment.to)
              return next;
          }
        }
        this.index[last]++;
        if (start + next.length >= Math.max(this.safeFrom, pos)) {
          this.trees.push(next);
          this.start.push(start);
          this.index.push(0);
        }
      } else {
        this.index[last]++;
        this.nextStart = start + next.length;
      }
    }
  }
};
var TokenCache = class {
  constructor(parser2, stream) {
    this.stream = stream;
    this.tokens = [];
    this.mainToken = null;
    this.actions = [];
    this.tokens = parser2.tokenizers.map((_) => new CachedToken());
  }
  getActions(stack) {
    let actionIndex = 0;
    let main = null;
    let { parser: parser2 } = stack.p, { tokenizers } = parser2;
    let mask = parser2.stateSlot(stack.state, 3);
    let context = stack.curContext ? stack.curContext.hash : 0;
    let lookAhead = 0;
    for (let i = 0; i < tokenizers.length; i++) {
      if ((1 << i & mask) == 0)
        continue;
      let tokenizer = tokenizers[i], token = this.tokens[i];
      if (main && !tokenizer.fallback)
        continue;
      if (tokenizer.contextual || token.start != stack.pos || token.mask != mask || token.context != context) {
        this.updateCachedToken(token, tokenizer, stack);
        token.mask = mask;
        token.context = context;
      }
      if (token.lookAhead > token.end + 25)
        lookAhead = Math.max(token.lookAhead, lookAhead);
      if (token.value != 0) {
        let startIndex = actionIndex;
        if (token.extended > -1)
          actionIndex = this.addActions(stack, token.extended, token.end, actionIndex);
        actionIndex = this.addActions(stack, token.value, token.end, actionIndex);
        if (!tokenizer.extend) {
          main = token;
          if (actionIndex > startIndex)
            break;
        }
      }
    }
    while (this.actions.length > actionIndex)
      this.actions.pop();
    if (lookAhead)
      stack.setLookAhead(lookAhead);
    if (!main && stack.pos == this.stream.end) {
      main = new CachedToken();
      main.value = stack.p.parser.eofTerm;
      main.start = main.end = stack.pos;
      actionIndex = this.addActions(stack, main.value, main.end, actionIndex);
    }
    this.mainToken = main;
    return this.actions;
  }
  getMainToken(stack) {
    if (this.mainToken)
      return this.mainToken;
    let main = new CachedToken(), { pos, p } = stack;
    main.start = pos;
    main.end = Math.min(pos + 1, p.stream.end);
    main.value = pos == p.stream.end ? p.parser.eofTerm : 0;
    return main;
  }
  updateCachedToken(token, tokenizer, stack) {
    tokenizer.token(this.stream.reset(stack.pos, token), stack);
    if (token.value > -1) {
      let { parser: parser2 } = stack.p;
      for (let i = 0; i < parser2.specialized.length; i++)
        if (parser2.specialized[i] == token.value) {
          let result = parser2.specializers[i](this.stream.read(token.start, token.end), stack);
          if (result >= 0 && stack.p.parser.dialect.allows(result >> 1)) {
            if ((result & 1) == 0)
              token.value = result >> 1;
            else
              token.extended = result >> 1;
            break;
          }
        }
    } else {
      token.value = 0;
      token.end = Math.min(stack.p.stream.end, stack.pos + 1);
    }
  }
  putAction(action, token, end, index) {
    for (let i = 0; i < index; i += 3)
      if (this.actions[i] == action)
        return index;
    this.actions[index++] = action;
    this.actions[index++] = token;
    this.actions[index++] = end;
    return index;
  }
  addActions(stack, token, end, index) {
    let { state } = stack, { parser: parser2 } = stack.p, { data } = parser2;
    for (let set = 0; set < 2; set++) {
      for (let i = parser2.stateSlot(state, set ? 2 : 1); ; i += 3) {
        if (data[i] == 65535) {
          if (data[i + 1] == 1) {
            i = pair(data, i + 2);
          } else {
            if (index == 0 && data[i + 1] == 2)
              index = this.putAction(pair(data, i + 2), token, end, index);
            break;
          }
        }
        if (data[i] == token)
          index = this.putAction(pair(data, i + 1), token, end, index);
      }
    }
    return index;
  }
};
var Rec;
(function(Rec2) {
  Rec2[Rec2["Distance"] = 5] = "Distance";
  Rec2[Rec2["MaxRemainingPerStep"] = 3] = "MaxRemainingPerStep";
  Rec2[Rec2["MinBufferLengthPrune"] = 500] = "MinBufferLengthPrune";
  Rec2[Rec2["ForceReduceLimit"] = 10] = "ForceReduceLimit";
  Rec2[Rec2["CutDepth"] = 15e3] = "CutDepth";
  Rec2[Rec2["CutTo"] = 9e3] = "CutTo";
})(Rec || (Rec = {}));
var Parse = class {
  constructor(parser2, input, fragments, ranges) {
    this.parser = parser2;
    this.input = input;
    this.ranges = ranges;
    this.recovering = 0;
    this.nextStackID = 9812;
    this.minStackPos = 0;
    this.reused = [];
    this.stoppedAt = null;
    this.stream = new InputStream(input, ranges);
    this.tokens = new TokenCache(parser2, this.stream);
    this.topTerm = parser2.top[1];
    let { from } = ranges[0];
    this.stacks = [Stack.start(this, parser2.top[0], from)];
    this.fragments = fragments.length && this.stream.end - from > parser2.bufferLength * 4 ? new FragmentCursor(fragments, parser2.nodeSet) : null;
  }
  get parsedPos() {
    return this.minStackPos;
  }
  advance() {
    let stacks = this.stacks, pos = this.minStackPos;
    let newStacks = this.stacks = [];
    let stopped, stoppedTokens;
    for (let i = 0; i < stacks.length; i++) {
      let stack = stacks[i];
      for (; ; ) {
        this.tokens.mainToken = null;
        if (stack.pos > pos) {
          newStacks.push(stack);
        } else if (this.advanceStack(stack, newStacks, stacks)) {
          continue;
        } else {
          if (!stopped) {
            stopped = [];
            stoppedTokens = [];
          }
          stopped.push(stack);
          let tok = this.tokens.getMainToken(stack);
          stoppedTokens.push(tok.value, tok.end);
        }
        break;
      }
    }
    if (!newStacks.length) {
      let finished = stopped && findFinished(stopped);
      if (finished)
        return this.stackToTree(finished);
      if (this.parser.strict) {
        if (verbose && stopped)
          console.log("Stuck with token " + (this.tokens.mainToken ? this.parser.getName(this.tokens.mainToken.value) : "none"));
        throw new SyntaxError("No parse at " + pos);
      }
      if (!this.recovering)
        this.recovering = 5;
    }
    if (this.recovering && stopped) {
      let finished = this.stoppedAt != null && stopped[0].pos > this.stoppedAt ? stopped[0] : this.runRecovery(stopped, stoppedTokens, newStacks);
      if (finished)
        return this.stackToTree(finished.forceAll());
    }
    if (this.recovering) {
      let maxRemaining = this.recovering == 1 ? 1 : this.recovering * 3;
      if (newStacks.length > maxRemaining) {
        newStacks.sort((a, b) => b.score - a.score);
        while (newStacks.length > maxRemaining)
          newStacks.pop();
      }
      if (newStacks.some((s) => s.reducePos > pos))
        this.recovering--;
    } else if (newStacks.length > 1) {
      outer:
        for (let i = 0; i < newStacks.length - 1; i++) {
          let stack = newStacks[i];
          for (let j = i + 1; j < newStacks.length; j++) {
            let other = newStacks[j];
            if (stack.sameState(other) || stack.buffer.length > 500 && other.buffer.length > 500) {
              if ((stack.score - other.score || stack.buffer.length - other.buffer.length) > 0) {
                newStacks.splice(j--, 1);
              } else {
                newStacks.splice(i--, 1);
                continue outer;
              }
            }
          }
        }
    }
    this.minStackPos = newStacks[0].pos;
    for (let i = 1; i < newStacks.length; i++)
      if (newStacks[i].pos < this.minStackPos)
        this.minStackPos = newStacks[i].pos;
    return null;
  }
  stopAt(pos) {
    if (this.stoppedAt != null && this.stoppedAt < pos)
      throw new RangeError("Can't move stoppedAt forward");
    this.stoppedAt = pos;
  }
  advanceStack(stack, stacks, split) {
    let start = stack.pos, { parser: parser2 } = this;
    let base = verbose ? this.stackID(stack) + " -> " : "";
    if (this.stoppedAt != null && start > this.stoppedAt)
      return stack.forceReduce() ? stack : null;
    if (this.fragments) {
      let strictCx = stack.curContext && stack.curContext.tracker.strict, cxHash = strictCx ? stack.curContext.hash : 0;
      for (let cached = this.fragments.nodeAt(start); cached; ) {
        let match = this.parser.nodeSet.types[cached.type.id] == cached.type ? parser2.getGoto(stack.state, cached.type.id) : -1;
        if (match > -1 && cached.length && (!strictCx || (cached.prop(NodeProp.contextHash) || 0) == cxHash)) {
          stack.useNode(cached, match);
          if (verbose)
            console.log(base + this.stackID(stack) + ` (via reuse of ${parser2.getName(cached.type.id)})`);
          return true;
        }
        if (!(cached instanceof Tree) || cached.children.length == 0 || cached.positions[0] > 0)
          break;
        let inner = cached.children[0];
        if (inner instanceof Tree && cached.positions[0] == 0)
          cached = inner;
        else
          break;
      }
    }
    let defaultReduce = parser2.stateSlot(stack.state, 4);
    if (defaultReduce > 0) {
      stack.reduce(defaultReduce);
      if (verbose)
        console.log(base + this.stackID(stack) + ` (via always-reduce ${parser2.getName(defaultReduce & 65535)})`);
      return true;
    }
    if (stack.stack.length >= 15e3) {
      while (stack.stack.length > 9e3 && stack.forceReduce()) {
      }
    }
    let actions = this.tokens.getActions(stack);
    for (let i = 0; i < actions.length; ) {
      let action = actions[i++], term = actions[i++], end = actions[i++];
      let last = i == actions.length || !split;
      let localStack = last ? stack : stack.split();
      localStack.apply(action, term, end);
      if (verbose)
        console.log(base + this.stackID(localStack) + ` (via ${(action & 65536) == 0 ? "shift" : `reduce of ${parser2.getName(action & 65535)}`} for ${parser2.getName(term)} @ ${start}${localStack == stack ? "" : ", split"})`);
      if (last)
        return true;
      else if (localStack.pos > start)
        stacks.push(localStack);
      else
        split.push(localStack);
    }
    return false;
  }
  advanceFully(stack, newStacks) {
    let pos = stack.pos;
    for (; ; ) {
      if (!this.advanceStack(stack, null, null))
        return false;
      if (stack.pos > pos) {
        pushStackDedup(stack, newStacks);
        return true;
      }
    }
  }
  runRecovery(stacks, tokens, newStacks) {
    let finished = null, restarted = false;
    for (let i = 0; i < stacks.length; i++) {
      let stack = stacks[i], token = tokens[i << 1], tokenEnd = tokens[(i << 1) + 1];
      let base = verbose ? this.stackID(stack) + " -> " : "";
      if (stack.deadEnd) {
        if (restarted)
          continue;
        restarted = true;
        stack.restart();
        if (verbose)
          console.log(base + this.stackID(stack) + " (restarted)");
        let done = this.advanceFully(stack, newStacks);
        if (done)
          continue;
      }
      let force = stack.split(), forceBase = base;
      for (let j = 0; force.forceReduce() && j < 10; j++) {
        if (verbose)
          console.log(forceBase + this.stackID(force) + " (via force-reduce)");
        let done = this.advanceFully(force, newStacks);
        if (done)
          break;
        if (verbose)
          forceBase = this.stackID(force) + " -> ";
      }
      for (let insert of stack.recoverByInsert(token)) {
        if (verbose)
          console.log(base + this.stackID(insert) + " (via recover-insert)");
        this.advanceFully(insert, newStacks);
      }
      if (this.stream.end > stack.pos) {
        if (tokenEnd == stack.pos) {
          tokenEnd++;
          token = 0;
        }
        stack.recoverByDelete(token, tokenEnd);
        if (verbose)
          console.log(base + this.stackID(stack) + ` (via recover-delete ${this.parser.getName(token)})`);
        pushStackDedup(stack, newStacks);
      } else if (!finished || finished.score < stack.score) {
        finished = stack;
      }
    }
    return finished;
  }
  stackToTree(stack) {
    stack.close();
    return Tree.build({
      buffer: StackBufferCursor.create(stack),
      nodeSet: this.parser.nodeSet,
      topID: this.topTerm,
      maxBufferLength: this.parser.bufferLength,
      reused: this.reused,
      start: this.ranges[0].from,
      length: stack.pos - this.ranges[0].from,
      minRepeatType: this.parser.minRepeatTerm
    });
  }
  stackID(stack) {
    let id2 = (stackIDs || (stackIDs = /* @__PURE__ */ new WeakMap())).get(stack);
    if (!id2)
      stackIDs.set(stack, id2 = String.fromCodePoint(this.nextStackID++));
    return id2 + stack;
  }
};
function pushStackDedup(stack, newStacks) {
  for (let i = 0; i < newStacks.length; i++) {
    let other = newStacks[i];
    if (other.pos == stack.pos && other.sameState(stack)) {
      if (newStacks[i].score < stack.score)
        newStacks[i] = stack;
      return;
    }
  }
  newStacks.push(stack);
}
var Dialect = class {
  constructor(source, flags, disabled) {
    this.source = source;
    this.flags = flags;
    this.disabled = disabled;
  }
  allows(term) {
    return !this.disabled || this.disabled[term] == 0;
  }
};
var id = (x) => x;
var ContextTracker = class {
  constructor(spec) {
    this.start = spec.start;
    this.shift = spec.shift || id;
    this.reduce = spec.reduce || id;
    this.reuse = spec.reuse || id;
    this.hash = spec.hash || (() => 0);
    this.strict = spec.strict !== false;
  }
};
var LRParser = class extends Parser {
  constructor(spec) {
    super();
    this.wrappers = [];
    if (spec.version != 14)
      throw new RangeError(`Parser version (${spec.version}) doesn't match runtime version (${14})`);
    let nodeNames = spec.nodeNames.split(" ");
    this.minRepeatTerm = nodeNames.length;
    for (let i = 0; i < spec.repeatNodeCount; i++)
      nodeNames.push("");
    let topTerms = Object.keys(spec.topRules).map((r) => spec.topRules[r][1]);
    let nodeProps = [];
    for (let i = 0; i < nodeNames.length; i++)
      nodeProps.push([]);
    function setProp(nodeID, prop, value) {
      nodeProps[nodeID].push([prop, prop.deserialize(String(value))]);
    }
    if (spec.nodeProps)
      for (let propSpec of spec.nodeProps) {
        let prop = propSpec[0];
        if (typeof prop == "string")
          prop = NodeProp[prop];
        for (let i = 1; i < propSpec.length; ) {
          let next = propSpec[i++];
          if (next >= 0) {
            setProp(next, prop, propSpec[i++]);
          } else {
            let value = propSpec[i + -next];
            for (let j = -next; j > 0; j--)
              setProp(propSpec[i++], prop, value);
            i++;
          }
        }
      }
    this.nodeSet = new NodeSet(nodeNames.map((name2, i) => NodeType.define({
      name: i >= this.minRepeatTerm ? void 0 : name2,
      id: i,
      props: nodeProps[i],
      top: topTerms.indexOf(i) > -1,
      error: i == 0,
      skipped: spec.skippedNodes && spec.skippedNodes.indexOf(i) > -1
    })));
    if (spec.propSources)
      this.nodeSet = this.nodeSet.extend(...spec.propSources);
    this.strict = false;
    this.bufferLength = DefaultBufferLength;
    let tokenArray = decodeArray(spec.tokenData);
    this.context = spec.context;
    this.specialized = new Uint16Array(spec.specialized ? spec.specialized.length : 0);
    this.specializers = [];
    if (spec.specialized)
      for (let i = 0; i < spec.specialized.length; i++) {
        this.specialized[i] = spec.specialized[i].term;
        this.specializers[i] = spec.specialized[i].get;
      }
    this.states = decodeArray(spec.states, Uint32Array);
    this.data = decodeArray(spec.stateData);
    this.goto = decodeArray(spec.goto);
    this.maxTerm = spec.maxTerm;
    this.tokenizers = spec.tokenizers.map((value) => typeof value == "number" ? new TokenGroup(tokenArray, value) : value);
    this.topRules = spec.topRules;
    this.dialects = spec.dialects || {};
    this.dynamicPrecedences = spec.dynamicPrecedences || null;
    this.tokenPrecTable = spec.tokenPrec;
    this.termNames = spec.termNames || null;
    this.maxNode = this.nodeSet.types.length - 1;
    this.dialect = this.parseDialect();
    this.top = this.topRules[Object.keys(this.topRules)[0]];
  }
  createParse(input, fragments, ranges) {
    let parse = new Parse(this, input, fragments, ranges);
    for (let w of this.wrappers)
      parse = w(parse, input, fragments, ranges);
    return parse;
  }
  getGoto(state, term, loose = false) {
    let table = this.goto;
    if (term >= table[0])
      return -1;
    for (let pos = table[term + 1]; ; ) {
      let groupTag = table[pos++], last = groupTag & 1;
      let target = table[pos++];
      if (last && loose)
        return target;
      for (let end = pos + (groupTag >> 1); pos < end; pos++)
        if (table[pos] == state)
          return target;
      if (last)
        return -1;
    }
  }
  hasAction(state, terminal) {
    let data = this.data;
    for (let set = 0; set < 2; set++) {
      for (let i = this.stateSlot(state, set ? 2 : 1), next; ; i += 3) {
        if ((next = data[i]) == 65535) {
          if (data[i + 1] == 1)
            next = data[i = pair(data, i + 2)];
          else if (data[i + 1] == 2)
            return pair(data, i + 2);
          else
            break;
        }
        if (next == terminal || next == 0)
          return pair(data, i + 1);
      }
    }
    return 0;
  }
  stateSlot(state, slot) {
    return this.states[state * 6 + slot];
  }
  stateFlag(state, flag) {
    return (this.stateSlot(state, 0) & flag) > 0;
  }
  validAction(state, action) {
    if (action == this.stateSlot(state, 4))
      return true;
    for (let i = this.stateSlot(state, 1); ; i += 3) {
      if (this.data[i] == 65535) {
        if (this.data[i + 1] == 1)
          i = pair(this.data, i + 2);
        else
          return false;
      }
      if (action == pair(this.data, i + 1))
        return true;
    }
  }
  nextStates(state) {
    let result = [];
    for (let i = this.stateSlot(state, 1); ; i += 3) {
      if (this.data[i] == 65535) {
        if (this.data[i + 1] == 1)
          i = pair(this.data, i + 2);
        else
          break;
      }
      if ((this.data[i + 2] & 65536 >> 16) == 0) {
        let value = this.data[i + 1];
        if (!result.some((v, i2) => i2 & 1 && v == value))
          result.push(this.data[i], value);
      }
    }
    return result;
  }
  overrides(token, prev) {
    let iPrev = findOffset(this.data, this.tokenPrecTable, prev);
    return iPrev < 0 || findOffset(this.data, this.tokenPrecTable, token) < iPrev;
  }
  configure(config3) {
    let copy = Object.assign(Object.create(LRParser.prototype), this);
    if (config3.props)
      copy.nodeSet = this.nodeSet.extend(...config3.props);
    if (config3.top) {
      let info = this.topRules[config3.top];
      if (!info)
        throw new RangeError(`Invalid top rule name ${config3.top}`);
      copy.top = info;
    }
    if (config3.tokenizers)
      copy.tokenizers = this.tokenizers.map((t2) => {
        let found = config3.tokenizers.find((r) => r.from == t2);
        return found ? found.to : t2;
      });
    if (config3.specializers)
      copy.specializers = this.specializers.map((s) => {
        let found = config3.specializers.find((r) => r.from == s);
        return found ? found.to : s;
      });
    if (config3.contextTracker)
      copy.context = config3.contextTracker;
    if (config3.dialect)
      copy.dialect = this.parseDialect(config3.dialect);
    if (config3.strict != null)
      copy.strict = config3.strict;
    if (config3.wrap)
      copy.wrappers = copy.wrappers.concat(config3.wrap);
    if (config3.bufferLength != null)
      copy.bufferLength = config3.bufferLength;
    return copy;
  }
  hasWrappers() {
    return this.wrappers.length > 0;
  }
  getName(term) {
    return this.termNames ? this.termNames[term] : String(term <= this.maxNode && this.nodeSet.types[term].name || term);
  }
  get eofTerm() {
    return this.maxNode + 1;
  }
  get topNode() {
    return this.nodeSet.types[this.top[1]];
  }
  dynamicPrecedence(term) {
    let prec = this.dynamicPrecedences;
    return prec == null ? 0 : prec[term] || 0;
  }
  parseDialect(dialect) {
    let values = Object.keys(this.dialects), flags = values.map(() => false);
    if (dialect)
      for (let part of dialect.split(" ")) {
        let id2 = values.indexOf(part);
        if (id2 >= 0)
          flags[id2] = true;
      }
    let disabled = null;
    for (let i = 0; i < values.length; i++)
      if (!flags[i]) {
        for (let j = this.dialects[values[i]], id2; (id2 = this.data[j++]) != 65535; )
          (disabled || (disabled = new Uint8Array(this.maxTerm + 1)))[id2] = 1;
      }
    return new Dialect(dialect, flags, disabled);
  }
  static deserialize(spec) {
    return new LRParser(spec);
  }
};
function pair(data, off) {
  return data[off] | data[off + 1] << 16;
}
function findOffset(data, start, term) {
  for (let i = start, next; (next = data[i]) != 65535; i++)
    if (next == term)
      return i - start;
  return -1;
}
function findFinished(stacks) {
  let best = null;
  for (let stack of stacks) {
    let stopped = stack.p.stoppedAt;
    if ((stack.pos == stack.p.stream.end || stopped != null && stack.pos > stopped) && stack.p.parser.stateFlag(stack.state, 2) && (!best || best.score < stack.score))
      best = stack;
  }
  return best;
}

// node_modules/@lezer/highlight/dist/index.js
var nextTagID = 0;
var Tag = class {
  constructor(set, base, modified) {
    this.set = set;
    this.base = base;
    this.modified = modified;
    this.id = nextTagID++;
  }
  static define(parent) {
    if (parent === null || parent === void 0 ? void 0 : parent.base)
      throw new Error("Can not derive from a modified tag");
    let tag = new Tag([], null, []);
    tag.set.push(tag);
    if (parent)
      for (let t2 of parent.set)
        tag.set.push(t2);
    return tag;
  }
  static defineModifier() {
    let mod = new Modifier();
    return (tag) => {
      if (tag.modified.indexOf(mod) > -1)
        return tag;
      return Modifier.get(tag.base || tag, tag.modified.concat(mod).sort((a, b) => a.id - b.id));
    };
  }
};
var nextModifierID = 0;
var Modifier = class {
  constructor() {
    this.instances = [];
    this.id = nextModifierID++;
  }
  static get(base, mods) {
    if (!mods.length)
      return base;
    let exists = mods[0].instances.find((t2) => t2.base == base && sameArray(mods, t2.modified));
    if (exists)
      return exists;
    let set = [], tag = new Tag(set, base, mods);
    for (let m of mods)
      m.instances.push(tag);
    let configs = permute(mods);
    for (let parent of base.set)
      for (let config3 of configs)
        set.push(Modifier.get(parent, config3));
    return tag;
  }
};
function sameArray(a, b) {
  return a.length == b.length && a.every((x, i) => x == b[i]);
}
function permute(array) {
  let result = [array];
  for (let i = 0; i < array.length; i++) {
    for (let a of permute(array.slice(0, i).concat(array.slice(i + 1))))
      result.push(a);
  }
  return result;
}
function styleTags(spec) {
  let byName = /* @__PURE__ */ Object.create(null);
  for (let prop in spec) {
    let tags2 = spec[prop];
    if (!Array.isArray(tags2))
      tags2 = [tags2];
    for (let part of prop.split(" "))
      if (part) {
        let pieces = [], mode = 2, rest = part;
        for (let pos = 0; ; ) {
          if (rest == "..." && pos > 0 && pos + 3 == part.length) {
            mode = 1;
            break;
          }
          let m = /^"(?:[^"\\]|\\.)*?"|[^\/!]+/.exec(rest);
          if (!m)
            throw new RangeError("Invalid path: " + part);
          pieces.push(m[0] == "*" ? "" : m[0][0] == '"' ? JSON.parse(m[0]) : m[0]);
          pos += m[0].length;
          if (pos == part.length)
            break;
          let next = part[pos++];
          if (pos == part.length && next == "!") {
            mode = 0;
            break;
          }
          if (next != "/")
            throw new RangeError("Invalid path: " + part);
          rest = part.slice(pos);
        }
        let last = pieces.length - 1, inner = pieces[last];
        if (!inner)
          throw new RangeError("Invalid path: " + part);
        let rule = new Rule2(tags2, mode, last > 0 ? pieces.slice(0, last) : null);
        byName[inner] = rule.sort(byName[inner]);
      }
  }
  return ruleNodeProp.add(byName);
}
var ruleNodeProp = new NodeProp();
var Rule2 = class {
  constructor(tags2, mode, context, next) {
    this.tags = tags2;
    this.mode = mode;
    this.context = context;
    this.next = next;
  }
  sort(other) {
    if (!other || other.depth < this.depth) {
      this.next = other;
      return this;
    }
    other.next = this.sort(other.next);
    return other;
  }
  get depth() {
    return this.context ? this.context.length : 0;
  }
};
function tagHighlighter(tags2, options) {
  let map = /* @__PURE__ */ Object.create(null);
  for (let style of tags2) {
    if (!Array.isArray(style.tag))
      map[style.tag.id] = style.class;
    else
      for (let tag of style.tag)
        map[tag.id] = style.class;
  }
  let { scope, all = null } = options || {};
  return {
    style: (tags3) => {
      let cls = all;
      for (let tag of tags3) {
        for (let sub of tag.set) {
          let tagClass = map[sub.id];
          if (tagClass) {
            cls = cls ? cls + " " + tagClass : tagClass;
            break;
          }
        }
      }
      return cls;
    },
    scope
  };
}
var t = Tag.define;
var comment = t();
var name = t();
var typeName = t(name);
var propertyName = t(name);
var literal = t();
var string = t(literal);
var number = t(literal);
var content = t();
var heading = t(content);
var keyword = t();
var operator = t();
var punctuation = t();
var bracket = t(punctuation);
var meta = t();
var tags = {
  comment,
  lineComment: t(comment),
  blockComment: t(comment),
  docComment: t(comment),
  name,
  variableName: t(name),
  typeName,
  tagName: t(typeName),
  propertyName,
  attributeName: t(propertyName),
  className: t(name),
  labelName: t(name),
  namespace: t(name),
  macroName: t(name),
  literal,
  string,
  docString: t(string),
  character: t(string),
  attributeValue: t(string),
  number,
  integer: t(number),
  float: t(number),
  bool: t(literal),
  regexp: t(literal),
  escape: t(literal),
  color: t(literal),
  url: t(literal),
  keyword,
  self: t(keyword),
  null: t(keyword),
  atom: t(keyword),
  unit: t(keyword),
  modifier: t(keyword),
  operatorKeyword: t(keyword),
  controlKeyword: t(keyword),
  definitionKeyword: t(keyword),
  moduleKeyword: t(keyword),
  operator,
  derefOperator: t(operator),
  arithmeticOperator: t(operator),
  logicOperator: t(operator),
  bitwiseOperator: t(operator),
  compareOperator: t(operator),
  updateOperator: t(operator),
  definitionOperator: t(operator),
  typeOperator: t(operator),
  controlOperator: t(operator),
  punctuation,
  separator: t(punctuation),
  bracket,
  angleBracket: t(bracket),
  squareBracket: t(bracket),
  paren: t(bracket),
  brace: t(bracket),
  content,
  heading,
  heading1: t(heading),
  heading2: t(heading),
  heading3: t(heading),
  heading4: t(heading),
  heading5: t(heading),
  heading6: t(heading),
  contentSeparator: t(content),
  list: t(content),
  quote: t(content),
  emphasis: t(content),
  strong: t(content),
  link: t(content),
  monospace: t(content),
  strikethrough: t(content),
  inserted: t(),
  deleted: t(),
  changed: t(),
  invalid: t(),
  meta,
  documentMeta: t(meta),
  annotation: t(meta),
  processingInstruction: t(meta),
  definition: Tag.defineModifier(),
  constant: Tag.defineModifier(),
  function: Tag.defineModifier(),
  standard: Tag.defineModifier(),
  local: Tag.defineModifier(),
  special: Tag.defineModifier()
};
var classHighlighter = tagHighlighter([
  { tag: tags.link, class: "tok-link" },
  { tag: tags.heading, class: "tok-heading" },
  { tag: tags.emphasis, class: "tok-emphasis" },
  { tag: tags.strong, class: "tok-strong" },
  { tag: tags.keyword, class: "tok-keyword" },
  { tag: tags.atom, class: "tok-atom" },
  { tag: tags.bool, class: "tok-bool" },
  { tag: tags.url, class: "tok-url" },
  { tag: tags.labelName, class: "tok-labelName" },
  { tag: tags.inserted, class: "tok-inserted" },
  { tag: tags.deleted, class: "tok-deleted" },
  { tag: tags.literal, class: "tok-literal" },
  { tag: tags.string, class: "tok-string" },
  { tag: tags.number, class: "tok-number" },
  { tag: [tags.regexp, tags.escape, tags.special(tags.string)], class: "tok-string2" },
  { tag: tags.variableName, class: "tok-variableName" },
  { tag: tags.local(tags.variableName), class: "tok-variableName tok-local" },
  { tag: tags.definition(tags.variableName), class: "tok-variableName tok-definition" },
  { tag: tags.special(tags.variableName), class: "tok-variableName2" },
  { tag: tags.definition(tags.propertyName), class: "tok-propertyName tok-definition" },
  { tag: tags.typeName, class: "tok-typeName" },
  { tag: tags.namespace, class: "tok-namespace" },
  { tag: tags.className, class: "tok-className" },
  { tag: tags.macroName, class: "tok-macroName" },
  { tag: tags.propertyName, class: "tok-propertyName" },
  { tag: tags.operator, class: "tok-operator" },
  { tag: tags.comment, class: "tok-comment" },
  { tag: tags.meta, class: "tok-meta" },
  { tag: tags.invalid, class: "tok-invalid" },
  { tag: tags.punctuation, class: "tok-punctuation" }
]);

// node_modules/@lezer/python/dist/index.es.js
var printKeyword = 1;
var indent = 162;
var dedent = 163;
var newline$1 = 164;
var newlineBracketed = 165;
var newlineEmpty = 166;
var eof = 167;
var ParenL = 22;
var ParenthesizedExpression = 23;
var TupleExpression = 47;
var ComprehensionExpression = 48;
var BracketL = 53;
var ArrayExpression = 54;
var ArrayComprehensionExpression = 55;
var BraceL = 57;
var DictionaryExpression = 58;
var DictionaryComprehensionExpression = 59;
var SetExpression = 60;
var SetComprehensionExpression = 61;
var ArgList = 63;
var subscript = 203;
var FormatReplacement = 71;
var importList = 228;
var ParamList = 121;
var newline = 10;
var carriageReturn = 13;
var space = 32;
var tab = 9;
var hash = 35;
var parenOpen = 40;
var dot = 46;
var bracketed = [
  ParenthesizedExpression,
  TupleExpression,
  ComprehensionExpression,
  importList,
  ArgList,
  ParamList,
  ArrayExpression,
  ArrayComprehensionExpression,
  subscript,
  SetExpression,
  SetComprehensionExpression,
  DictionaryExpression,
  DictionaryComprehensionExpression,
  FormatReplacement
];
var newlines = new ExternalTokenizer((input, stack) => {
  if (input.next < 0) {
    input.acceptToken(eof);
  } else if (input.next != newline && input.next != carriageReturn)
    ;
  else if (stack.context.depth < 0) {
    input.acceptToken(newlineBracketed, 1);
  } else {
    input.advance();
    let spaces = 0;
    while (input.next == space || input.next == tab) {
      input.advance();
      spaces++;
    }
    let empty = input.next == newline || input.next == carriageReturn || input.next == hash;
    input.acceptToken(empty ? newlineEmpty : newline$1, -spaces);
  }
}, { contextual: true, fallback: true });
var indentation = new ExternalTokenizer((input, stack) => {
  let cDepth = stack.context.depth;
  if (cDepth < 0)
    return;
  let prev = input.peek(-1);
  if ((prev == newline || prev == carriageReturn) && stack.context.depth >= 0) {
    let depth = 0, chars = 0;
    for (; ; ) {
      if (input.next == space)
        depth++;
      else if (input.next == tab)
        depth += 8 - depth % 8;
      else
        break;
      input.advance();
      chars++;
    }
    if (depth != cDepth && input.next != newline && input.next != carriageReturn && input.next != hash) {
      if (depth < cDepth)
        input.acceptToken(dedent, -chars);
      else
        input.acceptToken(indent);
    }
  }
});
function IndentLevel(parent, depth) {
  this.parent = parent;
  this.depth = depth;
  this.hash = (parent ? parent.hash + parent.hash << 8 : 0) + depth + (depth << 4);
}
var topIndent = new IndentLevel(null, 0);
function countIndent(space2) {
  let depth = 0;
  for (let i = 0; i < space2.length; i++)
    depth += space2.charCodeAt(i) == tab ? 8 - depth % 8 : 1;
  return depth;
}
var trackIndent = new ContextTracker({
  start: topIndent,
  reduce(context, term) {
    return context.depth < 0 && bracketed.indexOf(term) > -1 ? context.parent : context;
  },
  shift(context, term, stack, input) {
    if (term == indent)
      return new IndentLevel(context, countIndent(input.read(input.pos, stack.pos)));
    if (term == dedent)
      return context.parent;
    if (term == ParenL || term == BracketL || term == BraceL)
      return new IndentLevel(context, -1);
    return context;
  },
  hash(context) {
    return context.hash;
  }
});
var legacyPrint = new ExternalTokenizer((input) => {
  for (let i = 0; i < 5; i++) {
    if (input.next != "print".charCodeAt(i))
      return;
    input.advance();
  }
  if (/\w/.test(String.fromCharCode(input.next)))
    return;
  for (let off = 0; ; off++) {
    let next = input.peek(off);
    if (next == space || next == tab)
      continue;
    if (next != parenOpen && next != dot && next != newline && next != carriageReturn && next != hash)
      input.acceptToken(printKeyword);
    return;
  }
});
var pythonHighlighting = styleTags({
  'async "*" "**" FormatConversion FormatSpec': tags.modifier,
  "for while if elif else try except finally return raise break continue with pass assert await yield": tags.controlKeyword,
  "in not and or is del": tags.operatorKeyword,
  "from def class global nonlocal lambda": tags.definitionKeyword,
  import: tags.moduleKeyword,
  "with as print": tags.keyword,
  Boolean: tags.bool,
  None: tags.null,
  VariableName: tags.variableName,
  "CallExpression/VariableName": tags.function(tags.variableName),
  "FunctionDefinition/VariableName": tags.function(tags.definition(tags.variableName)),
  "ClassDefinition/VariableName": tags.definition(tags.className),
  PropertyName: tags.propertyName,
  "CallExpression/MemberExpression/PropertyName": tags.function(tags.propertyName),
  Comment: tags.lineComment,
  Number: tags.number,
  String: tags.string,
  FormatString: tags.special(tags.string),
  UpdateOp: tags.updateOperator,
  ArithOp: tags.arithmeticOperator,
  BitOp: tags.bitwiseOperator,
  CompareOp: tags.compareOperator,
  AssignOp: tags.definitionOperator,
  Ellipsis: tags.punctuation,
  At: tags.meta,
  "( )": tags.paren,
  "[ ]": tags.squareBracket,
  "{ }": tags.brace,
  ".": tags.derefOperator,
  ", ;": tags.separator
});
var spec_identifier = { __proto__: null, await: 40, or: 50, and: 52, in: 56, not: 58, is: 60, if: 66, else: 68, lambda: 72, yield: 90, from: 92, async: 98, for: 100, None: 152, True: 154, False: 154, del: 168, pass: 172, break: 176, continue: 180, return: 184, raise: 192, import: 196, as: 198, global: 202, nonlocal: 204, assert: 208, elif: 218, while: 222, try: 228, except: 230, finally: 232, with: 236, def: 240, class: 250 };
var parser = LRParser.deserialize({
  version: 14,
  states: "!?pO`Q$IXOOO%cQ$I[O'#GaOOQ$IS'#Cm'#CmOOQ$IS'#Cn'#CnO'RQ$IWO'#ClO(tQ$I[O'#G`OOQ$IS'#Ga'#GaOOQ$IS'#DS'#DSOOQ$IS'#G`'#G`O)bQ$IWO'#CsO)rQ$IWO'#DdO*SQ$IWO'#DhOOQ$IS'#Ds'#DsO*gO`O'#DsO*oOpO'#DsO*wO!bO'#DtO+SO#tO'#DtO+_O&jO'#DtO+jO,UO'#DtO-lQ$I[O'#GQOOQ$IS'#GQ'#GQO'RQ$IWO'#GPO/OQ$I[O'#GPOOQ$IS'#E]'#E]O/gQ$IWO'#E^OOQ$IS'#GO'#GOO/qQ$IWO'#F}OOQ$IV'#F}'#F}O/|Q$IWO'#FPOOQ$IS'#Fr'#FrO0RQ$IWO'#FOOOQ$IV'#H]'#H]OOQ$IV'#F|'#F|OOQ$IT'#FR'#FRQ`Q$IXOOO'RQ$IWO'#CoO0aQ$IWO'#C{O0hQ$IWO'#DPO0vQ$IWO'#GeO1WQ$I[O'#EQO'RQ$IWO'#EROOQ$IS'#ET'#ETOOQ$IS'#EV'#EVOOQ$IS'#EX'#EXO1lQ$IWO'#EZO2SQ$IWO'#E_O/|Q$IWO'#EaO2gQ$I[O'#EaO/|Q$IWO'#EdO/gQ$IWO'#EgO/gQ$IWO'#EkO/gQ$IWO'#EnO2rQ$IWO'#EpO2yQ$IWO'#EuO3UQ$IWO'#EqO/gQ$IWO'#EuO/|Q$IWO'#EwO/|Q$IWO'#E|OOQ$IS'#Cc'#CcOOQ$IS'#Cd'#CdOOQ$IS'#Ce'#CeOOQ$IS'#Cf'#CfOOQ$IS'#Cg'#CgOOQ$IS'#Ch'#ChOOQ$IS'#Cj'#CjO'RQ$IWO,58|O'RQ$IWO,58|O'RQ$IWO,58|O'RQ$IWO,58|O'RQ$IWO,58|O'RQ$IWO,58|O3ZQ$IWO'#DmOOQ$IS,5:W,5:WO3nQ$IWO'#GoOOQ$IS,5:Z,5:ZO3{Q%1`O,5:ZO4QQ$I[O,59WO0aQ$IWO,59`O0aQ$IWO,59`O0aQ$IWO,59`O6pQ$IWO,59`O6uQ$IWO,59`O6|Q$IWO,59hO7TQ$IWO'#G`O8ZQ$IWO'#G_OOQ$IS'#G_'#G_OOQ$IS'#DY'#DYO8rQ$IWO,59_O'RQ$IWO,59_O9QQ$IWO,59_O9VQ$IWO,5:PO'RQ$IWO,5:POOQ$IS,5:O,5:OO9eQ$IWO,5:OO9jQ$IWO,5:VO'RQ$IWO,5:VO'RQ$IWO,5:TOOQ$IS,5:S,5:SO9{Q$IWO,5:SO:QQ$IWO,5:UOOOO'#FZ'#FZO:VO`O,5:_OOQ$IS,5:_,5:_OOOO'#F['#F[O:_OpO,5:_O:gQ$IWO'#DuOOOO'#F]'#F]O:wO!bO,5:`OOQ$IS,5:`,5:`OOOO'#F`'#F`O;SO#tO,5:`OOOO'#Fa'#FaO;_O&jO,5:`OOOO'#Fb'#FbO;jO,UO,5:`OOQ$IS'#Fc'#FcO;uQ$I[O,5:dO>gQ$I[O,5<kO?QQ%GlO,5<kO?qQ$I[O,5<kOOQ$IS,5:x,5:xO@YQ$IXO'#FkOAiQ$IWO,5;TOOQ$IV,5<i,5<iOAtQ$I[O'#HXOB]Q$IWO,5;kOOQ$IS-E9p-E9pOOQ$IV,5;j,5;jO3PQ$IWO'#EwOOQ$IT-E9P-E9POBeQ$I[O,59ZODlQ$I[O,59gOEVQ$IWO'#GbOEbQ$IWO'#GbO/|Q$IWO'#GbOEmQ$IWO'#DROEuQ$IWO,59kOEzQ$IWO'#GfO'RQ$IWO'#GfO/gQ$IWO,5=POOQ$IS,5=P,5=PO/gQ$IWO'#D|OOQ$IS'#D}'#D}OFiQ$IWO'#FeOFyQ$IWO,58zOFyQ$IWO,58zO)eQ$IWO,5:jOGXQ$I[O'#GhOOQ$IS,5:m,5:mOOQ$IS,5:u,5:uOGlQ$IWO,5:yOG}Q$IWO,5:{OOQ$IS'#Fh'#FhOH]Q$I[O,5:{OHkQ$IWO,5:{OHpQ$IWO'#H[OOQ$IS,5;O,5;OOIOQ$IWO'#HWOOQ$IS,5;R,5;RO3UQ$IWO,5;VO3UQ$IWO,5;YOIaQ$I[O'#H^O'RQ$IWO'#H^OIkQ$IWO,5;[O2rQ$IWO,5;[O/gQ$IWO,5;aO/|Q$IWO,5;cOIpQ$IXO'#ElOJyQ$IZO,5;]ON[Q$IWO'#H_O3UQ$IWO,5;aONgQ$IWO,5;cONlQ$IWO,5;hO!#aQ$I[O1G.hO!#hQ$I[O1G.hO!&XQ$I[O1G.hO!&cQ$I[O1G.hO!(|Q$I[O1G.hO!)aQ$I[O1G.hO!)tQ$IWO'#GnO!*SQ$I[O'#GQO/gQ$IWO'#GnO!*^Q$IWO'#GmOOQ$IS,5:X,5:XO!*fQ$IWO,5:XO!*kQ$IWO'#GpO!*vQ$IWO'#GpO!+ZQ$IWO,5=ZOOQ$IS'#Dq'#DqOOQ$IS1G/u1G/uOOQ$IS1G.z1G.zO!,ZQ$I[O1G.zO!,bQ$I[O1G.zO0aQ$IWO1G.zO!,}Q$IWO1G/SOOQ$IS'#DX'#DXO/gQ$IWO,59rOOQ$IS1G.y1G.yO!-UQ$IWO1G/cO!-fQ$IWO1G/cO!-nQ$IWO1G/dO'RQ$IWO'#GgO!-sQ$IWO'#GgO!-xQ$I[O1G.yO!.YQ$IWO,59gO!/`Q$IWO,5=VO!/pQ$IWO,5=VO!/xQ$IWO1G/kO!/}Q$I[O1G/kOOQ$IS1G/j1G/jO!0_Q$IWO,5=QO!1UQ$IWO,5=QO/gQ$IWO1G/oO!1sQ$IWO1G/qO!1xQ$I[O1G/qO!2YQ$I[O1G/oOOQ$IS1G/n1G/nOOQ$IS1G/p1G/pOOOO-E9X-E9XOOQ$IS1G/y1G/yOOOO-E9Y-E9YO!2jQ$IWO'#G{O/gQ$IWO'#G{O!2xQ$IWO,5:aOOOO-E9Z-E9ZOOQ$IS1G/z1G/zOOOO-E9^-E9^OOOO-E9_-E9_OOOO-E9`-E9`OOQ$IS-E9a-E9aO!3TQ%GlO1G2VO!3tQ$I[O1G2VO'RQ$IWO,5<OOOQ$IS,5<O,5<OOOQ$IS-E9b-E9bOOQ$IS,5<V,5<VOOQ$IS-E9i-E9iOOQ$IV1G0o1G0oO/|Q$IWO'#FgO!4]Q$I[O,5=sOOQ$IS1G1V1G1VO!4tQ$IWO1G1VOOQ$IS'#DT'#DTO/gQ$IWO,5<|OOQ$IS,5<|,5<|O!4yQ$IWO'#FSO!5UQ$IWO,59mO!5^Q$IWO1G/VO!5hQ$I[O,5=QOOQ$IS1G2k1G2kOOQ$IS,5:h,5:hO!6XQ$IWO'#GPOOQ$IS,5<P,5<POOQ$IS-E9c-E9cO!6jQ$IWO1G.fOOQ$IS1G0U1G0UO!6xQ$IWO,5=SO!7YQ$IWO,5=SO/gQ$IWO1G0eO/gQ$IWO1G0eO/|Q$IWO1G0gOOQ$IS-E9f-E9fO!7kQ$IWO1G0gO!7vQ$IWO1G0gO!7{Q$IWO,5=vO!8ZQ$IWO,5=vO!8iQ$IWO,5=rO!9PQ$IWO,5=rO!9bQ$IZO1G0qO!<pQ$IZO1G0tO!?{Q$IWO,5=xO!@VQ$IWO,5=xO!@_Q$I[O,5=xO/gQ$IWO1G0vO!@iQ$IWO1G0vO3UQ$IWO1G0{ONgQ$IWO1G0}OOQ$IV,5;W,5;WO!@nQ$IYO,5;WO!@sQ$IZO1G0wO!DUQ$IWO'#FoO3UQ$IWO1G0wO3UQ$IWO1G0wO!DcQ$IWO,5=yO!DpQ$IWO,5=yO/|Q$IWO,5=yOOQ$IV1G0{1G0{O!DxQ$IWO'#EyO!EZQ%1`O1G0}OOQ$IV1G1S1G1SO3UQ$IWO1G1SOOQ$IS,5=Y,5=YOOQ$IS'#Dn'#DnO/gQ$IWO,5=YO!EcQ$IWO,5=XO!EvQ$IWO,5=XOOQ$IS1G/s1G/sO!FOQ$IWO,5=[O!F`Q$IWO,5=[O!FhQ$IWO,5=[O!F{Q$IWO,5=[O!G]Q$IWO,5=[OOQ$IS1G2u1G2uOOQ$IS7+$f7+$fO!5^Q$IWO7+$nO!IOQ$IWO1G.zO!IVQ$IWO1G.zOOQ$IS1G/^1G/^OOQ$IS,5;p,5;pO'RQ$IWO,5;pOOQ$IS7+$}7+$}O!I^Q$IWO7+$}OOQ$IS-E9S-E9SOOQ$IS7+%O7+%OO!InQ$IWO,5=RO'RQ$IWO,5=ROOQ$IS7+$e7+$eO!IsQ$IWO7+$}O!I{Q$IWO7+%OO!JQQ$IWO1G2qOOQ$IS7+%V7+%VO!JbQ$IWO1G2qO!JjQ$IWO7+%VOOQ$IS,5;o,5;oO'RQ$IWO,5;oO!JoQ$IWO1G2lOOQ$IS-E9R-E9RO!KfQ$IWO7+%ZOOQ$IS7+%]7+%]O!KtQ$IWO1G2lO!LcQ$IWO7+%]O!LhQ$IWO1G2rO!LxQ$IWO1G2rO!MQQ$IWO7+%ZO!MVQ$IWO,5=gO!MmQ$IWO,5=gO!MmQ$IWO,5=gO!M{O!LQO'#DwO!NWOSO'#G|OOOO1G/{1G/{O!N]Q$IWO1G/{O!NeQ%GlO7+'qO# UQ$I[O1G1jP# oQ$IWO'#FdOOQ$IS,5<R,5<ROOQ$IS-E9e-E9eOOQ$IS7+&q7+&qOOQ$IS1G2h1G2hOOQ$IS,5;n,5;nOOQ$IS-E9Q-E9QOOQ$IS7+$q7+$qO# |Q$IWO,5<kO#!gQ$IWO,5<kO#!xQ$I[O,5;qO##]Q$IWO1G2nOOQ$IS-E9T-E9TOOQ$IS7+&P7+&PO##mQ$IWO7+&POOQ$IS7+&R7+&RO##{Q$IWO'#HZO/|Q$IWO'#HYO#$aQ$IWO7+&ROOQ$IS,5<U,5<UO#$lQ$IWO1G3bOOQ$IS-E9h-E9hOOQ$IS,5<Q,5<QO#$zQ$IWO1G3^OOQ$IS-E9d-E9dO#%bQ$IZO7+&]O!DUQ$IWO'#FmO3UQ$IWO7+&]O3UQ$IWO7+&`O#(pQ$I[O,5<YO'RQ$IWO,5<YO#(zQ$IWO1G3dOOQ$IS-E9l-E9lO#)UQ$IWO1G3dO3UQ$IWO7+&bO/gQ$IWO7+&bOOQ$IV7+&g7+&gO!EZQ%1`O7+&iO#)^Q$IXO1G0rOOQ$IV-E9m-E9mO3UQ$IWO7+&cO3UQ$IWO7+&cOOQ$IV,5<Z,5<ZO#+PQ$IWO,5<ZOOQ$IV7+&c7+&cO#+[Q$IZO7+&cO#.gQ$IWO,5<[O#.rQ$IWO1G3eOOQ$IS-E9n-E9nO#/PQ$IWO1G3eO#/XQ$IWO'#HaO#/gQ$IWO'#HaO/|Q$IWO'#HaOOQ$IS'#Ha'#HaO#/rQ$IWO'#H`OOQ$IS,5;e,5;eO#/zQ$IWO,5;eO/gQ$IWO'#E{OOQ$IV7+&i7+&iO3UQ$IWO7+&iOOQ$IV7+&n7+&nOOQ$IS1G2t1G2tOOQ$IS,5;s,5;sO#0PQ$IWO1G2sOOQ$IS-E9V-E9VO#0dQ$IWO,5;tO#0oQ$IWO,5;tO#1SQ$IWO1G2vOOQ$IS-E9W-E9WO#1dQ$IWO1G2vO#1lQ$IWO1G2vO#1|Q$IWO1G2vO#1dQ$IWO1G2vOOQ$IS<<HY<<HYO#2XQ$I[O1G1[OOQ$IS<<Hi<<HiP#2fQ$IWO'#FUO6|Q$IWO1G2mO#2sQ$IWO1G2mO#2xQ$IWO<<HiOOQ$IS<<Hj<<HjO#3YQ$IWO7+(]OOQ$IS<<Hq<<HqO#3jQ$I[O1G1ZP#4ZQ$IWO'#FTO#4hQ$IWO7+(^O#4xQ$IWO7+(^O#5QQ$IWO<<HuO#5VQ$IWO7+(WOOQ$IS<<Hw<<HwO#5|Q$IWO,5;rO'RQ$IWO,5;rOOQ$IS-E9U-E9UOOQ$IS<<Hu<<HuOOQ$IS,5;x,5;xO/gQ$IWO,5;xO#6RQ$IWO1G3ROOQ$IS-E9[-E9[O#6iQ$IWO1G3ROOOO'#F_'#F_O#6wO!LQO,5:cOOOO,5=h,5=hOOOO7+%g7+%gO#7SQ$IWO1G2VO#7mQ$IWO1G2VP'RQ$IWO'#FVO/gQ$IWO<<IkO#8OQ$IWO,5=uO#8aQ$IWO,5=uO/|Q$IWO,5=uO#8rQ$IWO,5=tOOQ$IS<<Im<<ImP/|Q$IWO'#FjP/gQ$IWO'#FfOOQ$IV-E9k-E9kO3UQ$IWO<<IwOOQ$IV,5<X,5<XO3UQ$IWO,5<XOOQ$IV<<Iw<<IwOOQ$IV<<Iz<<IzO#8wQ$I[O1G1tP#9RQ$IWO'#FnO#9YQ$IWO7+)OO#9dQ$IZO<<I|O3UQ$IWO<<I|OOQ$IV<<JT<<JTO3UQ$IWO<<JTOOQ$IV'#Fl'#FlO#<oQ$IZO7+&^OOQ$IV<<I}<<I}O#>hQ$IZO<<I}OOQ$IV1G1u1G1uO/|Q$IWO1G1uO3UQ$IWO<<I}O/|Q$IWO1G1vP/gQ$IWO'#FpO#AsQ$IWO7+)PO#BQQ$IWO7+)POOQ$IS'#Ez'#EzO/gQ$IWO,5={O#BYQ$IWO,5={OOQ$IS,5={,5={O#BeQ$IWO,5=zO#BvQ$IWO,5=zOOQ$IS1G1P1G1POOQ$IS,5;g,5;gP#COQ$IWO'#FXO#C`Q$IWO1G1`O#CsQ$IWO1G1`O#DTQ$IWO1G1`P#D`Q$IWO'#FYO#DmQ$IWO7+(bO#D}Q$IWO7+(bO#D}Q$IWO7+(bO#EVQ$IWO7+(bO#EgQ$IWO7+(XO6|Q$IWO7+(XOOQ$ISAN>TAN>TO#FQQ$IWO<<KxOOQ$ISAN>aAN>aO/gQ$IWO1G1^O#FbQ$I[O1G1^P#FlQ$IWO'#FWOOQ$IS1G1d1G1dP#FyQ$IWO'#F^O#GWQ$IWO7+(mOOOO-E9]-E9]O#GnQ$IWO7+'qOOQ$ISAN?VAN?VO#HXQ$IWO,5<TO#HmQ$IWO1G3aOOQ$IS-E9g-E9gO#IOQ$IWO1G3aOOQ$IS1G3`1G3`OOQ$IVAN?cAN?cOOQ$IV1G1s1G1sO3UQ$IWOAN?hO#IaQ$IZOAN?hOOQ$IVAN?oAN?oOOQ$IV-E9j-E9jOOQ$IV<<Ix<<IxO3UQ$IWOAN?iO3UQ$IWO7+'aOOQ$IVAN?iAN?iOOQ$IS7+'b7+'bO#LlQ$IWO<<LkOOQ$IS1G3g1G3gO/gQ$IWO1G3gOOQ$IS,5<],5<]O#LyQ$IWO1G3fOOQ$IS-E9o-E9oO#M[Q$IWO7+&zO#MlQ$IWO7+&zOOQ$IS7+&z7+&zO#MwQ$IWO<<K|O#NXQ$IWO<<K|O#NXQ$IWO<<K|O#NaQ$IWO'#GiOOQ$IS<<Ks<<KsO#NkQ$IWO<<KsOOQ$IS7+&x7+&xO/|Q$IWO1G1oP/|Q$IWO'#FiO$ UQ$IWO7+({O$ gQ$IWO7+({OOQ$IVG25SG25SO3UQ$IWOG25SOOQ$IVG25TG25TOOQ$IV<<J{<<J{OOQ$IS7+)R7+)RP$ xQ$IWO'#FqOOQ$IS<<Jf<<JfO$!WQ$IWO<<JfO$!hQ$IWOANAhO$!xQ$IWOANAhO$#QQ$IWO'#GjOOQ$IS'#Gj'#GjO0hQ$IWO'#DaO$#kQ$IWO,5=TOOQ$ISANA_ANA_OOQ$IS7+'Z7+'ZO$$SQ$IWO<<LgOOQ$IVLD*nLD*nOOQ$ISAN@QAN@QO$$eQ$IWOG27SO$$uQ$IWO,59{OOQ$IS1G2o1G2oO#NaQ$IWO1G/gOOQ$IS7+%R7+%RO6|Q$IWO'#C{O6|Q$IWO,59`O6|Q$IWO,59`O6|Q$IWO,59`O$$zQ$I[O,5<kO6|Q$IWO1G.zO/gQ$IWO1G/VO/gQ$IWO7+$nP$%_Q$IWO'#FdO'RQ$IWO'#GPO$%lQ$IWO,59`O$%qQ$IWO,59`O$%xQ$IWO,59kO$%}Q$IWO1G/SO0hQ$IWO'#DPO6|Q$IWO,59h",
  stateData: "$&e~O$oOS$lOS$kOSQOS~OPhOTeOdsOfXOmtOq!SOtuO}vO!O!PO!R!VO!S!UO!VYO!ZZO!fdO!mdO!ndO!odO!vxO!xyO!zzO!|{O#O|O#S}O#U!OO#X!QO#Y!QO#[!RO#c!TO#f!WO#j!XO#l!YO#q!ZO#tlO$jqO$zQO${QO%PRO%QVO%f[O%g]O%j^O%m_O%s`O%vaO%xbO~OT!aO]!aO_!bOf!iO!V!kO!d!mO$u![O$v!]O$w!^O$x!_O$y!_O$z!`O${!`O$|!aO$}!aO%O!aO~Oi%TXj%TXk%TXl%TXm%TXn%TXq%TXx%TXy%TX!s%TX#^%TX$j%TX$m%TX%V%TXe%TX!R%TX!S%TX%W%TX!U%TX!Y%TX!O%TX#V%TXr%TX!j%TX~P$_OdsOfXO!VYO!ZZO!fdO!mdO!ndO!odO$zQO${QO%PRO%QVO%f[O%g]O%j^O%m_O%s`O%vaO%xbO~Ox%SXy%SX#^%SX$j%SX$m%SX%V%SX~Oi!pOj!qOk!oOl!oOm!rOn!sOq!tO!s%SX~P(`OT!zOm-dOt-rO}vO~P'ROT!}Om-dOt-rO!U#OO~P'ROT#RO_#SOm-dOt-rO!Y#TO~P'RO%h#WO%i#YO~O%k#ZO%l#YO~O!Z#]O%n#^O%r#`O~O!Z#]O%t#aO%u#`O~O!Z#]O%i#`O%w#cO~O!Z#]O%l#`O%y#eO~OT$tX]$tX_$tXf$tXi$tXj$tXk$tXl$tXm$tXn$tXq$tXx$tX!V$tX!d$tX$u$tX$v$tX$w$tX$x$tX$y$tX$z$tX${$tX$|$tX$}$tX%O$tXe$tX!R$tX!S$tX~O%f[O%g]O%j^O%m_O%s`O%vaO%xbOy$tX!s$tX#^$tX$j$tX$m$tX%V$tX%W$tX!U$tX!Y$tX!O$tX#V$tXr$tX!j$tX~P+uOx#jOy$sX!s$sX#^$sX$j$sX$m$sX%V$sX~Om-dOt-rO~P'RO#^#mO$j#oO$m#oO~O%QVO~O!R#tO#l!YO#q!ZO#tlO~OmtO~P'ROT#yO_#zO%QVOyuP~OT$OOm-dOt-rO!O$PO~P'ROy$RO!s$WO%V$SO#^!tX$j!tX$m!tX~OT$OOm-dOt-rO#^!}X$j!}X$m!}X~P'ROm-dOt-rO#^#RX$j#RX$m#RX~P'RO!d$^O!m$^O%QVO~OT$hO~P'RO!S$jO#j$kO#l$lO~Oy$mO~OT${O_${Oe$}Om-dOt-rO~P'ROm-dOt-rOy%QO~P'RO%e%SO~O_!bOf!iO!V!kO!d!mOT`a]`ai`aj`ak`al`am`an`aq`ax`ay`a!s`a#^`a$j`a$m`a$u`a$v`a$w`a$x`a$y`a$z`a${`a$|`a$}`a%O`a%V`ae`a!R`a!S`a%W`a!U`a!Y`a!O`a#V`ar`a!j`a~Ol%XO~Om%XO~P'ROm-dO~P'ROi-fOj-gOk-eOl-eOm-nOn-oOq-sOe%SX!R%SX!S%SX%W%SX!U%SX!Y%SX!O%SX#V%SX!j%SX~P(`O%W%ZOe%RXx%RX!R%RX!S%RX!U%RXy%RX~Oe%]Ox%^O!R%bO!S%aO~Oe%]O~Ox%eO!R%bO!S%aO!U%_X~O!U%iO~Ox%jOy%lO!R%bO!S%aO!Y%YX~O!Y%pO~O!Y%qO~O%h#WO%i%sO~O%k#ZO%l%sO~OT%vOm-dOt-rO}vO~P'RO!Z#]O%n#^O%r%yO~O!Z#]O%t#aO%u%yO~O!Z#]O%i%yO%w#cO~O!Z#]O%l%yO%y#eO~OT!la]!la_!laf!lai!laj!lak!lal!lam!lan!laq!lax!lay!la!V!la!d!la!s!la#^!la$j!la$m!la$u!la$v!la$w!la$x!la$y!la$z!la${!la$|!la$}!la%O!la%V!lae!la!R!la!S!la%W!la!U!la!Y!la!O!la#V!lar!la!j!la~P#vOx&OOy$sa!s$sa#^$sa$j$sa$m$sa%V$sa~P$_OT&QOmtOtuOy$sa!s$sa#^$sa$j$sa$m$sa%V$sa~P'ROx&OOy$sa!s$sa#^$sa$j$sa$m$sa%V$sa~OPhOTeOmtOtuO}vO!O!PO!vxO!xyO!zzO!|{O#O|O#S}O#U!OO#X!QO#Y!QO#[!RO#^$_X$j$_X$m$_X~P'RO#^#mO$j&VO$m&VO~O!d&WOf%{X$j%{X#V%{X#^%{X$m%{X#U%{X~Of!iO$j&YO~Oicajcakcalcamcancaqcaxcayca!sca#^ca$jca$mca%Vcaeca!Rca!Sca%Wca!Uca!Yca!Oca#Vcarca!jca~P$_Oqoaxoayoa#^oa$joa$moa%Voa~Oi!pOj!qOk!oOl!oOm!rOn!sO!soa~PDTO%V&[Ox%UXy%UX~O%QVOx%UXy%UX~Ox&_OyuX~Oy&aO~Ox%jO#^%YX$j%YX$m%YXe%YXy%YX!Y%YX!j%YX%V%YX~OT-mOm-dOt-rO}vO~P'RO%V$SO#^Sa$jSa$mSa~Ox&jO#^%[X$j%[X$m%[Xl%[X~P$_Ox&mO!O&lO#^#Ra$j#Ra$m#Ra~O#V&nO#^#Ta$j#Ta$m#Ta~O!d$^O!m$^O#U&pO%QVO~O#U&pO~Ox&rO#^&OX$j&OX$m&OX~Ox&tO#^%zX$j%zX$m%zXy%zX~Ox&xOl&QX~P$_Ol&{O~OPhOTeOmtOtuO}vO!O!PO!vxO!xyO!zzO!|{O#O|O#S}O#U!OO#X!QO#Y!QO#[!RO$j'QO~P'ROr'UO#g'SO#h'TOP#eaT#ead#eaf#eam#eaq#eat#ea}#ea!O#ea!R#ea!S#ea!V#ea!Z#ea!f#ea!m#ea!n#ea!o#ea!v#ea!x#ea!z#ea!|#ea#O#ea#S#ea#U#ea#X#ea#Y#ea#[#ea#c#ea#f#ea#j#ea#l#ea#q#ea#t#ea$g#ea$j#ea$z#ea${#ea%P#ea%Q#ea%f#ea%g#ea%j#ea%m#ea%s#ea%v#ea%x#ea$i#ea$m#ea~Ox'VO#V'XOy&RX~Of'ZO~Of!iOy$mO~OT!aO]!aO_!bOf!iO!V!kO!d!mO$w!^O$x!_O$y!_O$z!`O${!`O$|!aO$}!aO%O!aOiUijUikUilUimUinUiqUixUiyUi!sUi#^Ui$jUi$mUi$uUi%VUieUi!RUi!SUi%WUi!UUi!YUi!OUi#VUirUi!jUi~O$v!]O~PNtO$vUi~PNtOT!aO]!aO_!bOf!iO!V!kO!d!mO$z!`O${!`O$|!aO$}!aO%O!aOiUijUikUilUimUinUiqUixUiyUi!sUi#^Ui$jUi$mUi$uUi$vUi$wUi%VUieUi!RUi!SUi%WUi!UUi!YUi!OUi#VUirUi!jUi~O$x!_O$y!_O~P!#oO$xUi$yUi~P!#oO_!bOf!iO!V!kO!d!mOiUijUikUilUimUinUiqUixUiyUi!sUi#^Ui$jUi$mUi$uUi$vUi$wUi$xUi$yUi$zUi${Ui%VUieUi!RUi!SUi%WUi!UUi!YUi!OUi#VUirUi!jUi~OT!aO]!aO$|!aO$}!aO%O!aO~P!&mOTUi]Ui$|Ui$}Ui%OUi~P!&mO!R%bO!S%aOe%bXx%bX~O%V'`O%W'`O~P+uOx'bOe%aX~Oe'dO~Ox'eOy'gO!U%dX~Om-dOt-rOx'eOy'hO!U%dX~P'RO!U'jO~Ok!oOl!oOm!rOn!sOihiqhixhiyhi!shi#^hi$jhi$mhi%Vhi~Oj!qO~P!+`Ojhi~P!+`Oi-fOj-gOk-eOl-eOm-nOn-oO~Or'lO~P!,iOT'qOe'rOm-dOt-rO~P'ROe'rOx'sO~Oe'uO~O!S'wO~Oe'xOx'sO!R%bO!S%aO~P$_Oi-fOj-gOk-eOl-eOm-nOn-oOeoa!Roa!Soa%Woa!Uoa!Yoa!Ooa#Voaroa!joa~PDTOT'qOm-dOt-rO!U%_a~P'ROx'{O!U%_a~O!U'|O~Ox'{O!R%bO!S%aO!U%_a~P$_OT(QOm-dOt-rO!Y%Ya#^%Ya$j%Ya$m%Yae%Yay%Ya!j%Ya%V%Ya~P'ROx(RO!Y%Ya#^%Ya$j%Ya$m%Yae%Yay%Ya!j%Ya%V%Ya~O!Y(UO~Ox(RO!R%bO!S%aO!Y%Ya~P$_Ox(XO!R%bO!S%aO!Y%`a~P$_Ox([Oy%oX!Y%oX!j%oX~Oy(_O!Y(aO!j(bO~OT&QOmtOtuOy$si!s$si#^$si$j$si$m$si%V$si~P'ROx(cOy$si!s$si#^$si$j$si$m$si%V$si~O!d&WOf%{a$j%{a#V%{a#^%{a$m%{a#U%{a~O$j(hO~OT#yO_#zO%QVO~Ox&_Oyua~OmtOtuO~P'ROx(RO#^%Ya$j%Ya$m%Yae%Yay%Ya!Y%Ya!j%Ya%V%Ya~P$_Ox(mO#^$sX$j$sX$m$sX%V$sX~O%V$SO#^Si$jSi$mSi~O#^%[a$j%[a$m%[al%[a~P'ROx(pO#^%[a$j%[a$m%[al%[a~OT(tOf(vO%QVO~O#U(wO~O%QVO#^&Oa$j&Oa$m&Oa~Ox(yO#^&Oa$j&Oa$m&Oa~Om-dOt-rO#^%za$j%za$m%zay%za~P'ROx(|O#^%za$j%za$m%zay%za~Or)QO#a)POP#_iT#_id#_if#_im#_iq#_it#_i}#_i!O#_i!R#_i!S#_i!V#_i!Z#_i!f#_i!m#_i!n#_i!o#_i!v#_i!x#_i!z#_i!|#_i#O#_i#S#_i#U#_i#X#_i#Y#_i#[#_i#c#_i#f#_i#j#_i#l#_i#q#_i#t#_i$g#_i$j#_i$z#_i${#_i%P#_i%Q#_i%f#_i%g#_i%j#_i%m#_i%s#_i%v#_i%x#_i$i#_i$m#_i~Or)ROP#biT#bid#bif#bim#biq#bit#bi}#bi!O#bi!R#bi!S#bi!V#bi!Z#bi!f#bi!m#bi!n#bi!o#bi!v#bi!x#bi!z#bi!|#bi#O#bi#S#bi#U#bi#X#bi#Y#bi#[#bi#c#bi#f#bi#j#bi#l#bi#q#bi#t#bi$g#bi$j#bi$z#bi${#bi%P#bi%Q#bi%f#bi%g#bi%j#bi%m#bi%s#bi%v#bi%x#bi$i#bi$m#bi~OT)TOl&Qa~P'ROx)UOl&Qa~Ox)UOl&Qa~P$_Ol)YO~O$h)]O~Or)`O#g'SO#h)_OP#eiT#eid#eif#eim#eiq#eit#ei}#ei!O#ei!R#ei!S#ei!V#ei!Z#ei!f#ei!m#ei!n#ei!o#ei!v#ei!x#ei!z#ei!|#ei#O#ei#S#ei#U#ei#X#ei#Y#ei#[#ei#c#ei#f#ei#j#ei#l#ei#q#ei#t#ei$g#ei$j#ei$z#ei${#ei%P#ei%Q#ei%f#ei%g#ei%j#ei%m#ei%s#ei%v#ei%x#ei$i#ei$m#ei~Om-dOt-rOy$mO~P'ROm-dOt-rOy&Ra~P'ROx)fOy&Ra~OT)jO_)kOe)nO$|)lO%QVO~Oy$mO&U)pO~OT${O_${Om-dOt-rOe%aa~P'ROx)vOe%aa~Om-dOt-rOy)yO!U%da~P'ROx)zO!U%da~Om-dOt-rOx)zOy)}O!U%da~P'ROm-dOt-rOx)zO!U%da~P'ROx)zOy)}O!U%da~Ok-eOl-eOm-nOn-oOehiihiqhixhi!Rhi!Shi%Whi!Uhiyhi!Yhi#^hi$jhi$mhi!Ohi#Vhirhi!jhi%Vhi~Oj-gO~P!GhOjhi~P!GhOT'qOe*SOm-dOt-rO~P'ROl*UO~Oe*SOx*WO~Oe*XO~OT'qOm-dOt-rO!U%_i~P'ROx*YO!U%_i~O!U*ZO~OT(QOm-dOt-rO!Y%Yi#^%Yi$j%Yi$m%Yie%Yiy%Yi!j%Yi%V%Yi~P'ROx*^O!R%bO!S%aO!Y%`i~Ox*aO!Y%Yi#^%Yi$j%Yi$m%Yie%Yiy%Yi!j%Yi%V%Yi~O!Y*bO~O_*dOm-dOt-rO!Y%`i~P'ROx*^O!Y%`i~O!Y*fO~OT*hOm-dOt-rOy%oa!Y%oa!j%oa~P'ROx*iOy%oa!Y%oa!j%oa~O!Z#]O%q*lO!Y!kX~O!Y*nO~Oy(_O!Y*oO~OT&QOmtOtuOy$sq!s$sq#^$sq$j$sq$m$sq%V$sq~P'ROx$Wiy$Wi!s$Wi#^$Wi$j$Wi$m$Wi%V$Wi~P$_OT&QOmtOtuO~P'ROT&QOm-dOt-rO#^$sa$j$sa$m$sa%V$sa~P'ROx*pO#^$sa$j$sa$m$sa%V$sa~Ox#ya#^#ya$j#ya$m#yal#ya~P$_O#^%[i$j%[i$m%[il%[i~P'ROx*sO#^#Rq$j#Rq$m#Rq~Ox*tO#V*vO#^%}X$j%}X$m%}Xe%}X~OT*xOf(vO%QVO~O%QVO#^&Oi$j&Oi$m&Oi~Om-dOt-rO#^%zi$j%zi$m%ziy%zi~P'ROr*|O#a)POP#_qT#_qd#_qf#_qm#_qq#_qt#_q}#_q!O#_q!R#_q!S#_q!V#_q!Z#_q!f#_q!m#_q!n#_q!o#_q!v#_q!x#_q!z#_q!|#_q#O#_q#S#_q#U#_q#X#_q#Y#_q#[#_q#c#_q#f#_q#j#_q#l#_q#q#_q#t#_q$g#_q$j#_q$z#_q${#_q%P#_q%Q#_q%f#_q%g#_q%j#_q%m#_q%s#_q%v#_q%x#_q$i#_q$m#_q~Ol$bax$ba~P$_OT)TOl&Qi~P'ROx+TOl&Qi~OPhOTeOmtOq!SOtuO}vO!O!PO!R!VO!S!UO!vxO!xyO!zzO!|{O#O|O#S}O#U!OO#X!QO#Y!QO#[!RO#c!TO#f!WO#j!XO#l!YO#q!ZO#tlO~P'ROx+_Oy$mO#V+_O~O#h+`OP#eqT#eqd#eqf#eqm#eqq#eqt#eq}#eq!O#eq!R#eq!S#eq!V#eq!Z#eq!f#eq!m#eq!n#eq!o#eq!v#eq!x#eq!z#eq!|#eq#O#eq#S#eq#U#eq#X#eq#Y#eq#[#eq#c#eq#f#eq#j#eq#l#eq#q#eq#t#eq$g#eq$j#eq$z#eq${#eq%P#eq%Q#eq%f#eq%g#eq%j#eq%m#eq%s#eq%v#eq%x#eq$i#eq$m#eq~O#V+aOx$day$da~Om-dOt-rOy&Ri~P'ROx+cOy&Ri~Oy$RO%V+eOe&TXx&TX~O%QVOe&TXx&TX~Ox+iOe&SX~Oe+kO~OT${O_${Om-dOt-rOe%ai~P'ROy+nOx#|a!U#|a~Om-dOt-rOy+oOx#|a!U#|a~P'ROm-dOt-rOy)yO!U%di~P'ROx+rO!U%di~Om-dOt-rOx+rO!U%di~P'ROx+rOy+uO!U%di~Oe#xix#xi!U#xi~P$_OT'qOm-dOt-rO~P'ROl+wO~OT'qOe+xOm-dOt-rO~P'ROT'qOm-dOt-rO!U%_q~P'ROx#wi!Y#wi#^#wi$j#wi$m#wie#wiy#wi!j#wi%V#wi~P$_OT(QOm-dOt-rO~P'RO_*dOm-dOt-rO!Y%`q~P'ROx+yO!Y%`q~O!Y+zO~OT(QOm-dOt-rO!Y%Yq#^%Yq$j%Yq$m%Yqe%Yqy%Yq!j%Yq%V%Yq~P'ROy+{O~OT*hOm-dOt-rOy%oi!Y%oi!j%oi~P'ROx,QOy%oi!Y%oi!j%oi~O!Z#]O%q*lO!Y!ka~OT&QOm-dOt-rO#^$si$j$si$m$si%V$si~P'ROx,SO#^$si$j$si$m$si%V$si~O%QVO#^%}a$j%}a$m%}ae%}a~Ox,VO#^%}a$j%}a$m%}ae%}a~Oe,YO~Ol$bix$bi~P$_OT)TO~P'ROT)TOl&Qq~P'ROr,]OP#dyT#dyd#dyf#dym#dyq#dyt#dy}#dy!O#dy!R#dy!S#dy!V#dy!Z#dy!f#dy!m#dy!n#dy!o#dy!v#dy!x#dy!z#dy!|#dy#O#dy#S#dy#U#dy#X#dy#Y#dy#[#dy#c#dy#f#dy#j#dy#l#dy#q#dy#t#dy$g#dy$j#dy$z#dy${#dy%P#dy%Q#dy%f#dy%g#dy%j#dy%m#dy%s#dy%v#dy%x#dy$i#dy$m#dy~OPhOTeOmtOq!SOtuO}vO!O!PO!R!VO!S!UO!vxO!xyO!zzO!|{O#O|O#S}O#U!OO#X!QO#Y!QO#[!RO#c!TO#f!WO#j!XO#l!YO#q!ZO#tlO$i,aO$m,aO~P'RO#h,bOP#eyT#eyd#eyf#eym#eyq#eyt#ey}#ey!O#ey!R#ey!S#ey!V#ey!Z#ey!f#ey!m#ey!n#ey!o#ey!v#ey!x#ey!z#ey!|#ey#O#ey#S#ey#U#ey#X#ey#Y#ey#[#ey#c#ey#f#ey#j#ey#l#ey#q#ey#t#ey$g#ey$j#ey$z#ey${#ey%P#ey%Q#ey%f#ey%g#ey%j#ey%m#ey%s#ey%v#ey%x#ey$i#ey$m#ey~Om-dOt-rOy&Rq~P'ROx,fOy&Rq~O%V+eOe&Tax&Ta~OT)jO_)kO$|)lO%QVOe&Sa~Ox,jOe&Sa~OT${O_${Om-dOt-rO~P'ROm-dOt-rOy,lOx#|i!U#|i~P'ROm-dOt-rOx#|i!U#|i~P'ROy,lOx#|i!U#|i~Om-dOt-rOy)yO~P'ROm-dOt-rOy)yO!U%dq~P'ROx,oO!U%dq~Om-dOt-rOx,oO!U%dq~P'ROq,rO!R%bO!S%aOe%Zq!U%Zq!Y%Zqx%Zq~P!,iO_*dOm-dOt-rO!Y%`y~P'ROx#zi!Y#zi~P$_O_*dOm-dOt-rO~P'ROT*hOm-dOt-rO~P'ROT*hOm-dOt-rOy%oq!Y%oq!j%oq~P'ROT&QOm-dOt-rO#^$sq$j$sq$m$sq%V$sq~P'RO#V,vOx$]a#^$]a$j$]a$m$]ae$]a~O%QVO#^%}i$j%}i$m%}ie%}i~Ox,xO#^%}i$j%}i$m%}ie%}i~Or,{OP#d!RT#d!Rd#d!Rf#d!Rm#d!Rq#d!Rt#d!R}#d!R!O#d!R!R#d!R!S#d!R!V#d!R!Z#d!R!f#d!R!m#d!R!n#d!R!o#d!R!v#d!R!x#d!R!z#d!R!|#d!R#O#d!R#S#d!R#U#d!R#X#d!R#Y#d!R#[#d!R#c#d!R#f#d!R#j#d!R#l#d!R#q#d!R#t#d!R$g#d!R$j#d!R$z#d!R${#d!R%P#d!R%Q#d!R%f#d!R%g#d!R%j#d!R%m#d!R%s#d!R%v#d!R%x#d!R$i#d!R$m#d!R~Om-dOt-rOy&Ry~P'ROT)jO_)kO$|)lO%QVOe&Si~Om-dOt-rOx#|q!U#|q~P'ROy-ROx#|q!U#|q~Om-dOt-rOy)yO!U%dy~P'ROx-SO!U%dy~Om-dOt-WO~P'ROq,rO!R%bO!S%aOe%Zy!U%Zy!Y%Zyx%Zy~P!,iO%QVO#^%}q$j%}q$m%}qe%}q~Ox-[O#^%}q$j%}q$m%}qe%}q~OT)jO_)kO$|)lO%QVO~Om-dOt-rOx#|y!U#|y~P'ROm-dOt-rOy)yO!U%d!R~P'ROx-_O!U%d!R~Oe%^Xq%^X!R%^X!S%^X!U%^X!Y%^Xx%^X~P!,iOq,rO!R%bO!S%aOe%]a!U%]a!Y%]ax%]a~O%QVO#^%}y$j%}y$m%}ye%}y~Om-dOt-rOy)yO!U%d!Z~P'ROy-bO~Ox*pO#^$sa$j$sa$m$sa%V$sa~P$_OT&QOm-dOt-rO~P'ROl-iO~Om-iO~P'ROy-jO~Or-kO~P!,iO%g%j%v%x%f!Z%n%t%w%y%m%s%m%Q~",
  goto: "!-g&UPPPP&VP&_)p*V*m+U+n,XP,sP&_-a-a&_PPP&_0rPPPPPP0r3bPP3bP5n5w:zPP:};];`PP&_&_PP;lPP&_&_PP&_&_&_&_&_;p<d&_P<gP<j<j@PP@e&_PPP@i@o&VP&V&VP&VP&VP&VP&VP&V&V&VP&VPP&VPP&VP@uP@|ASP@|P@|@|PPP@|PB{PCUC[CbB{P@|ChPCoCuC{DXDkDqD{EREoEuE{FRF]FcFiFoFuF{G_GiGoGuG{HVH]HcHiHoHyIPIZIaPPPPPPPPPIjIrI{JVJbPPPPPPPPPPPPNw! a!%o!({PP!)T!)c!)l!*b!*X!*k!*q!*t!*w!*z!+S!+pPPPPPPPPPP!+s!+vPPPPPPPPP!+|!,Y!,f!,l!,u!,x!-O!-U!-[!-_]iOr#m$m)]+Z'odOSXYZehrstvx|}!R!S!T!U!X!c!d!e!f!g!h!i!k!o!p!q!s!t!z!}#R#S#]#j#m$O$P$R$T$W$h$j$k$m${%Q%X%[%^%a%e%j%l%v&O&Q&]&a&j&l&m&t&x&{'S'V'a'b'e'g'h'l'q's'w'{(Q(R(X([(c(e(m(p(|)P)T)U)Y)])f)p)v)y)z)}*T*U*W*Y*]*^*a*d*h*i*p*r*s*z+S+T+Z+b+c+f+m+n+o+q+r+u+w+y+{+},P,Q,S,f,h,l,o,r-R-S-_-b-d-e-f-g-i-j-k-l-m-o-sw!cP#i#v$X$g%c%h%n%o&b&z(d(o)S*R*[+R+|-hy!dP#i#v$X$g$s%c%h%n%o&b&z(d(o)S*R*[+R+|-h{!eP#i#v$X$g$s$t%c%h%n%o&b&z(d(o)S*R*[+R+|-h}!fP#i#v$X$g$s$t$u%c%h%n%o&b&z(d(o)S*R*[+R+|-h!P!gP#i#v$X$g$s$t$u$v%c%h%n%o&b&z(d(o)S*R*[+R+|-h!R!hP#i#v$X$g$s$t$u$v$w%c%h%n%o&b&z(d(o)S*R*[+R+|-h!V!hP!n#i#v$X$g$s$t$u$v$w$x%c%h%n%o&b&z(d(o)S*R*[+R+|-h'oSOSXYZehrstvx|}!R!S!T!U!X!c!d!e!f!g!h!i!k!o!p!q!s!t!z!}#R#S#]#j#m$O$P$R$T$W$h$j$k$m${%Q%X%[%^%a%e%j%l%v&O&Q&]&a&j&l&m&t&x&{'S'V'a'b'e'g'h'l'q's'w'{(Q(R(X([(c(e(m(p(|)P)T)U)Y)])f)p)v)y)z)}*T*U*W*Y*]*^*a*d*h*i*p*r*s*z+S+T+Z+b+c+f+m+n+o+q+r+u+w+y+{+},P,Q,S,f,h,l,o,r-R-S-_-b-d-e-f-g-i-j-k-l-m-o-s&ZUOXYZhrtv|}!R!S!T!X!i!k!o!p!q!s!t#]#j#m$P$R$T$W$k$m${%Q%X%[%^%e%j%l%v&O&]&a&l&m&t&{'S'V'a'b'e'g'h'l's'{(R(X([(c(e(m(|)P)Y)])f)p)v)y)z)}*T*U*W*Y*]*^*a*h*i*p*s*z+Z+b+c+f+m+n+o+q+r+u+w+y+{+},P,Q,S,f,h,l,o,r-R-S-_-b-d-e-f-g-i-j-k-l-o-s%eWOXYZhrv|}!R!S!T!X!i!k#]#j#m$P$R$T$W$k$m${%Q%[%^%e%j%l%v&O&]&a&l&m&t&{'S'V'a'b'e'g'h'l's'{(R(X([(c(e(m(|)P)Y)])f)p)v)y)z)}*T*W*Y*]*^*a*h*i*p*s*z+Z+b+c+f+m+n+o+q+r+u+y+{+},P,Q,S,f,h,l,o-R-S-_-j-k-lQ#|uQ-`-WR-p-r'fdOSXYZehrstvx|}!R!S!T!U!X!c!d!e!f!g!h!k!o!p!q!s!t!z!}#R#S#]#j#m$O$P$R$T$W$h$j$k$m${%Q%X%[%^%a%e%j%l%v&O&Q&]&a&j&l&m&t&x&{'S'V'a'e'g'h'l'q's'w'{(Q(R(X([(c(e(m(p(|)P)T)U)Y)])f)p)y)z)}*T*U*W*Y*]*^*a*d*h*i*p*r*s*z+S+T+Z+b+c+f+n+o+q+r+u+w+y+{+},P,Q,S,f,h,l,o,r-R-S-_-b-d-e-f-g-i-j-k-l-m-o-sW#pl!O!P$_W#xu&_-W-rQ$a!QQ$q!YQ$r!ZW$z!i'b)v+mS&^#y#zQ'O$lQ(f&WQ(t&nU(u&p(v(wU(x&r(y*yQ)h'XW)i'Z+i,j-PS+h)j)kY,U*t,V,w,x-[Q,X*vQ,c+_Q,e+aR-Z,vR&]#xi!wXY!S!T%^%e's'{)P*T*W*YR%[!vQ!{XQ%w#]Q&f$TR&i$WT-V,r-b!U!jP!n#i#v$X$g$s$t$u$v$w$x%c%h%n%o&b&z(d(o)S*R*[+R+|-hQ&Z#qR'^$rR'a$zR%T!m'ncOSXYZehrstvx|}!R!S!T!U!X!c!d!e!f!g!h!i!k!o!p!q!s!t!z!}#R#S#]#j#m$O$P$R$T$W$h$j$k$m${%Q%X%[%^%a%e%j%l%v&O&Q&]&a&j&l&m&t&x&{'S'V'a'b'e'g'h'l'q's'w'{(Q(R(X([(c(e(m(p(|)P)T)U)Y)])f)p)v)y)z)}*T*U*W*Y*]*^*a*d*h*i*p*r*s*z+S+T+Z+b+c+f+m+n+o+q+r+u+w+y+{+},P,Q,S,f,h,l,o,r-R-S-_-b-d-e-f-g-i-j-k-l-m-o-sT#gc#hS#^_#_S#a`#bS#ca#dS#eb#fT*l(_*mT(`%w(bQ$VwR+g)iX$Tw$U$V&hZkOr$m)]+ZXoOr)]+ZQ$n!WQ&v$eQ&w$fQ'Y$pQ']$rQ)Z&}Q)a'SQ)c'TQ)d'UQ)q'[Q)s'^Q*})PQ+P)QQ+Q)RQ+U)XS+W)[)rQ+[)_Q+])`Q+^)bQ,Z*|Q,[+OQ,^+VQ,_+XQ,d+`Q,z,]Q,|,bQ,},cR-],{WoOr)]+ZR#snQ'[$qR)['OQ+f)iR,h+gQ)r'[R+X)[ZmOnr)]+ZQrOR#urQ&`#{R(k&`S%k#Q#}S(S%k(VT(V%n&bQ%_!yQ%f!|W't%_%f'y'}Q'y%cR'}%hQ&k$XR(q&kQ(Y%oQ*_(TT*e(Y*_Q'c$|R)w'cS'f%P%QY){'f)|+s,p-TU)|'g'h'iU+s)}*O*PS,p+t+uR-T,qQ#X]R%r#XQ#[^R%t#[Q#__R%x#_Q(]%uS*j(]*kR*k(^Q*m(_R,R*mQ#b`R%z#bQ#daR%{#dQ#fbR%|#fQ#hcR%}#hQ#kfQ&P#iW&S#k&P(n*qQ(n&eR*q-hQ$UwS&g$U&hR&h$VQ&u$cR(}&uQ&X#pR(g&XQ$_!PR&o$_Q*u(uS,W*u,yR,y,XQ&s$aR(z&sQ#njR&U#nQ+Z)]R,`+ZQ)O&vR*{)OQ&y$gS)V&y)WR)W&zQ'R$nR)^'RQ'W$oS)g'W+dR+d)hQ+j)mR,k+jWnOr)]+ZR#rnSqOrT+Y)]+ZWpOr)]+ZR'P$mYjOr$m)]+ZR&T#m[wOr#m$m)]+ZR&f$T&YPOXYZhrtv|}!R!S!T!X!i!k!o!p!q!s!t#]#j#m$P$R$T$W$k$m${%Q%X%[%^%e%j%l%v&O&]&a&l&m&t&{'S'V'a'b'e'g'h'l's'{(R(X([(c(e(m(|)P)Y)])f)p)v)y)z)}*T*U*W*Y*]*^*a*h*i*p*s*z+Z+b+c+f+m+n+o+q+r+u+w+y+{+},P,Q,S,f,h,l,o,r-R-S-_-b-d-e-f-g-i-j-k-l-o-sQ!nSQ#ieQ#vsU$Xx%a'wS$g!U$jQ$s!cQ$t!dQ$u!eQ$v!fQ$w!gQ$x!hQ%c!zQ%h!}Q%n#RQ%o#SQ&b$OQ&z$hQ(d&QU(o&j(p*rW)S&x)U+S+TQ*R'qQ*[(QQ+R)TQ+|*dR-h-mQ!yXQ!|YQ$e!SQ$f!T^'p%^%e's'{*T*W*YR+O)P[fOr#m$m)]+Zh!vXY!S!T%^%e's'{)P*T*W*YQ#QZQ#lhS#}v|Q$[}W$c!R$W&{)YS$o!X$kW$y!i'b)v+mQ%P!kQ%u#]`&R#j&O(c(e(m*p,S-lQ&c$PQ&d$RQ&e$TQ'_${Q'i%QQ'o%[W(P%j(R*]*aQ(T%lQ(^%vQ(i&]S(l&a-jQ(r&lQ(s&mU({&t(|*zQ)b'SY)e'V)f+b+c,fQ)t'a^)x'e)z+q+r,o-S-_Q*O'gQ*P'hS*Q'l-kW*c(X*^+y+}W*g([*i,P,QQ+l)pQ+p)yQ+t)}Q,O*hQ,T*sQ,g+fQ,m+nQ,n+oQ,q+uQ,u+{Q-O,hQ-Q,lR-^-RhTOr#j#m$m&O&a'l(c(e)]+Z$z!uXYZhv|}!R!S!T!X!i!k#]$P$R$T$W$k${%Q%[%^%e%j%l%v&]&l&m&t&{'S'V'a'b'e'g'h's'{(R(X([(m(|)P)Y)f)p)v)y)z)}*T*W*Y*]*^*a*h*i*p*s*z+b+c+f+m+n+o+q+r+u+y+{+},P,Q,S,f,h,l,o-R-S-_-j-k-lQ#wtW%U!o!s-e-oQ%V!pQ%W!qQ%Y!tQ%d-dS'k%X-iQ'm-fQ'n-gQ+v*UQ,t+wS-U,r-bR-q-sU#{u-W-rR(j&_[gOr#m$m)]+ZX!xX#]$T$WQ#VZQ$QvR$Z|Q%`!yQ%g!|Q%m#QQ'_$yQ'z%cQ(O%hQ(W%nQ(Z%oQ*`(TQ,s+vQ-Y,tR-a-XQ$YxQ'v%aR*V'wQ-X,rR-c-bR#PYR#UZR%O!iQ$|!iV)u'b)v+m!V!lP!n#i#v$X$g$s$t$u$v$w$x%c%h%n%o&b&z(d(o)S*R*[+R+|-hR%R!kR%w#]Q(a%wR*o(bQ$d!RQ&i$WQ)X&{R+V)YQ#qlQ$]!OQ$`!PR&q$_Q(t&pR*x(wQ(t&pQ*w(vR*x(wR$b!QXpOr)]+ZQ$i!UR&|$jQ$p!XR&}$kR)o'ZQ)m'ZV,i+i,j-P",
  nodeNames: "\u26A0 print Comment Script AssignStatement * BinaryExpression BitOp BitOp BitOp BitOp ArithOp ArithOp @ ArithOp ** UnaryExpression ArithOp BitOp AwaitExpression await ) ( ParenthesizedExpression BinaryExpression or and CompareOp in not is UnaryExpression ConditionalExpression if else LambdaExpression lambda ParamList VariableName AssignOp , : NamedExpression AssignOp YieldExpression yield from TupleExpression ComprehensionExpression async for LambdaExpression ] [ ArrayExpression ArrayComprehensionExpression } { DictionaryExpression DictionaryComprehensionExpression SetExpression SetComprehensionExpression CallExpression ArgList AssignOp MemberExpression . PropertyName Number String FormatString FormatReplacement FormatConversion FormatSpec ContinuedString Ellipsis None Boolean TypeDef AssignOp UpdateStatement UpdateOp ExpressionStatement DeleteStatement del PassStatement pass BreakStatement break ContinueStatement continue ReturnStatement return YieldStatement PrintStatement RaiseStatement raise ImportStatement import as ScopeStatement global nonlocal AssertStatement assert StatementGroup ; IfStatement Body elif WhileStatement while ForStatement TryStatement try except finally WithStatement with FunctionDefinition def ParamList AssignOp TypeDef ClassDefinition class DecoratedStatement Decorator At",
  maxTerm: 236,
  context: trackIndent,
  nodeProps: [
    ["group", -14, 4, 80, 82, 83, 85, 87, 89, 91, 93, 94, 95, 97, 100, 103, "Statement Statement", -22, 6, 16, 19, 23, 38, 47, 48, 54, 55, 58, 59, 60, 61, 62, 65, 68, 69, 70, 74, 75, 76, 77, "Expression", -9, 105, 107, 110, 112, 113, 117, 119, 124, 126, "Statement"],
    ["openedBy", 21, "(", 52, "[", 56, "{"],
    ["closedBy", 22, ")", 53, "]", 57, "}"]
  ],
  propSources: [pythonHighlighting],
  skippedNodes: [0, 2],
  repeatNodeCount: 32,
  tokenData: "&JdMgR!^OX$}XY!&]Y[$}[]!&]]p$}pq!&]qr!(grs!,^st!IYtu$}uv$5[vw$7nwx$8zxy%'vyz%(|z{%*S{|%,r|}%.O}!O%/U!O!P%1k!P!Q%<q!Q!R%?a!R![%Cc![!]%N_!]!^&!q!^!_&#w!_!`&&g!`!a&'s!a!b$}!b!c&*`!c!d&+n!d!e&-`!e!h&+n!h!i&7[!i!t&+n!t!u&@j!u!w&+n!w!x&5j!x!}&+n!}#O&Bt#O#P!'u#P#Q&Cz#Q#R&EQ#R#S&+n#S#T$}#T#U&+n#U#V&-`#V#Y&+n#Y#Z&7[#Z#f&+n#f#g&@j#g#i&+n#i#j&5j#j#o&+n#o#p&F^#p#q&GS#q#r&H`#r#s&I^#s$g$}$g~&+n<r%`Z%q7[%hS%kW%n`%tp%w!b%y#tOr$}rs&Rsw$}wxHsx#O$}#O#P!$R#P#o$}#o#p!%i#p#q$}#q#r!$g#r~$}<Q&^Z%q7[%hS%n`%w!bOr'PrsFisw'Pwx(Rx#O'P#O#PAe#P#o'P#o#pEu#p#q'P#q#rAy#r~'P<Q'`Z%q7[%hS%kW%n`%w!b%y#tOr'Prs&Rsw'Pwx(Rx#O'P#O#PAe#P#o'P#o#pEu#p#q'P#q#rAy#r~'P;p([Z%q7[%kW%y#tOr(}rs)}sw(}wx={x#O(}#O#P2]#P#o(}#o#p:X#p#q(}#q#r2q#r~(};p)[Z%q7[%hS%kW%w!b%y#tOr(}rs)}sw(}wx(Rx#O(}#O#P2]#P#o(}#o#p:X#p#q(}#q#r2q#r~(};p*WZ%q7[%hS%w!bOr(}rs*ysw(}wx(Rx#O(}#O#P2]#P#o(}#o#p:X#p#q(}#q#r2q#r~(};p+SZ%q7[%hS%w!bOr(}rs+usw(}wx(Rx#O(}#O#P2]#P#o(}#o#p:X#p#q(}#q#r2q#r~(}8r,OX%q7[%hS%w!bOw+uwx,kx#O+u#O#P.]#P#o+u#o#p0d#p#q+u#q#r.q#r~+u8r,pX%q7[Ow+uwx-]x#O+u#O#P.]#P#o+u#o#p0d#p#q+u#q#r.q#r~+u8r-bX%q7[Ow+uwx-}x#O+u#O#P.]#P#o+u#o#p0d#p#q+u#q#r.q#r~+u7[.SR%q7[O#o-}#p#q-}#r~-}8r.bT%q7[O#o+u#o#p.q#p#q+u#q#r.q#r~+u!f.xV%hS%w!bOw.qwx/_x#O.q#O#P0^#P#o.q#o#p0d#p~.q!f/bVOw.qwx/wx#O.q#O#P0^#P#o.q#o#p0d#p~.q!f/zUOw.qx#O.q#O#P0^#P#o.q#o#p0d#p~.q!f0aPO~.q!f0iV%hSOw1Owx1dx#O1O#O#P2V#P#o1O#o#p.q#p~1OS1TT%hSOw1Owx1dx#O1O#O#P2V#P~1OS1gTOw1Owx1vx#O1O#O#P2V#P~1OS1ySOw1Ox#O1O#O#P2V#P~1OS2YPO~1O;p2bT%q7[O#o(}#o#p2q#p#q(}#q#r2q#r~(}%d2|X%hS%kW%w!b%y#tOr2qrs3isw2qwx5Px#O2q#O#P:R#P#o2q#o#p:X#p~2q%d3pX%hS%w!bOr2qrs4]sw2qwx5Px#O2q#O#P:R#P#o2q#o#p:X#p~2q%d4dX%hS%w!bOr2qrs.qsw2qwx5Px#O2q#O#P:R#P#o2q#o#p:X#p~2q%d5WX%kW%y#tOr2qrs3isw2qwx5sx#O2q#O#P:R#P#o2q#o#p:X#p~2q%d5zX%kW%y#tOr2qrs3isw2qwx6gx#O2q#O#P:R#P#o2q#o#p:X#p~2q#|6nV%kW%y#tOr6grs7Ts#O6g#O#P8S#P#o6g#o#p8Y#p~6g#|7WVOr6grs7ms#O6g#O#P8S#P#o6g#o#p8Y#p~6g#|7pUOr6gs#O6g#O#P8S#P#o6g#o#p8Y#p~6g#|8VPO~6g#|8_V%kWOr8trs9Ys#O8t#O#P9{#P#o8t#o#p6g#p~8tW8yT%kWOr8trs9Ys#O8t#O#P9{#P~8tW9]TOr8trs9ls#O8t#O#P9{#P~8tW9oSOr8ts#O8t#O#P9{#P~8tW:OPO~8t%d:UPO~2q%d:`X%hS%kWOr:{rs;isw:{wx<ox#O:{#O#P=u#P#o:{#o#p2q#p~:{[;SV%hS%kWOr:{rs;isw:{wx<ox#O:{#O#P=u#P~:{[;nV%hSOr:{rs<Tsw:{wx<ox#O:{#O#P=u#P~:{[<YV%hSOr:{rs1Osw:{wx<ox#O:{#O#P=u#P~:{[<tV%kWOr:{rs;isw:{wx=Zx#O:{#O#P=u#P~:{[=`V%kWOr:{rs;isw:{wx8tx#O:{#O#P=u#P~:{[=xPO~:{;p>UZ%q7[%kW%y#tOr(}rs)}sw(}wx>wx#O(}#O#P2]#P#o(}#o#p:X#p#q(}#q#r2q#r~(}:Y?QX%q7[%kW%y#tOr>wrs?ms#O>w#O#PAP#P#o>w#o#p8Y#p#q>w#q#r6g#r~>w:Y?rX%q7[Or>wrs@_s#O>w#O#PAP#P#o>w#o#p8Y#p#q>w#q#r6g#r~>w:Y@dX%q7[Or>wrs-}s#O>w#O#PAP#P#o>w#o#p8Y#p#q>w#q#r6g#r~>w:YAUT%q7[O#o>w#o#p6g#p#q>w#q#r6g#r~>w<QAjT%q7[O#o'P#o#pAy#p#q'P#q#rAy#r~'P%tBWX%hS%kW%n`%w!b%y#tOrAyrsBsswAywx5Px#OAy#O#PEo#P#oAy#o#pEu#p~Ay%tB|X%hS%n`%w!bOrAyrsCiswAywx5Px#OAy#O#PEo#P#oAy#o#pEu#p~Ay%tCrX%hS%n`%w!bOrAyrsD_swAywx5Px#OAy#O#PEo#P#oAy#o#pEu#p~Ay!vDhV%hS%n`%w!bOwD_wx/_x#OD_#O#PD}#P#oD_#o#pET#p~D_!vEQPO~D_!vEYV%hSOw1Owx1dx#O1O#O#P2V#P#o1O#o#pD_#p~1O%tErPO~Ay%tE|X%hS%kWOr:{rs;isw:{wx<ox#O:{#O#P=u#P#o:{#o#pAy#p~:{<QFtZ%q7[%hS%n`%w!bOr'PrsGgsw'Pwx(Rx#O'P#O#PAe#P#o'P#o#pEu#p#q'P#q#rAy#r~'P9SGrX%q7[%hS%n`%w!bOwGgwx,kx#OGg#O#PH_#P#oGg#o#pET#p#qGg#q#rD_#r~Gg9SHdT%q7[O#oGg#o#pD_#p#qGg#q#rD_#r~Gg<bIOZ%q7[%kW%tp%y#tOrIqrs)}swIqwx! wx#OIq#O#PJs#P#oIq#o#p! T#p#qIq#q#rKX#r~Iq<bJQZ%q7[%hS%kW%tp%w!b%y#tOrIqrs)}swIqwxHsx#OIq#O#PJs#P#oIq#o#p! T#p#qIq#q#rKX#r~Iq<bJxT%q7[O#oIq#o#pKX#p#qIq#q#rKX#r~Iq&UKfX%hS%kW%tp%w!b%y#tOrKXrs3iswKXwxLRx#OKX#O#PN}#P#oKX#o#p! T#p~KX&UL[X%kW%tp%y#tOrKXrs3iswKXwxLwx#OKX#O#PN}#P#oKX#o#p! T#p~KX&UMQX%kW%tp%y#tOrKXrs3iswKXwxMmx#OKX#O#PN}#P#oKX#o#p! T#p~KX$nMvV%kW%tp%y#tOrMmrs7Ts#OMm#O#PN]#P#oMm#o#pNc#p~Mm$nN`PO~Mm$nNhV%kWOr8trs9Ys#O8t#O#P9{#P#o8t#o#pMm#p~8t&U! QPO~KX&U! [X%hS%kWOr:{rs;isw:{wx<ox#O:{#O#P=u#P#o:{#o#pKX#p~:{<b!!SZ%q7[%kW%tp%y#tOrIqrs)}swIqwx!!ux#OIq#O#PJs#P#oIq#o#p! T#p#qIq#q#rKX#r~Iq:z!#QX%q7[%kW%tp%y#tOr!!urs?ms#O!!u#O#P!#m#P#o!!u#o#pNc#p#q!!u#q#rMm#r~!!u:z!#rT%q7[O#o!!u#o#pMm#p#q!!u#q#rMm#r~!!u<r!$WT%q7[O#o$}#o#p!$g#p#q$}#q#r!$g#r~$}&f!$vX%hS%kW%n`%tp%w!b%y#tOr!$grsBssw!$gwxLRx#O!$g#O#P!%c#P#o!$g#o#p!%i#p~!$g&f!%fPO~!$g&f!%pX%hS%kWOr:{rs;isw:{wx<ox#O:{#O#P=u#P#o:{#o#p!$g#p~:{Mg!&pa%q7[%hS%kW$o1s%n`%tp%w!b%y#tOX$}XY!&]Y[$}[]!&]]p$}pq!&]qr$}rs&Rsw$}wxHsx#O$}#O#P!'u#P#o$}#o#p!%i#p#q$}#q#r!$g#r~$}Mg!'zX%q7[OY$}YZ!&]Z]$}]^!&]^#o$}#o#p!$g#p#q$}#q#r!$g#r~$}<u!(xb%q7[%hS%kW%n`%tp%w!b%y#tOr$}rs&Rsw$}wxHsx!_$}!_!`!*Q!`#O$}#O#P!$R#P#T$}#T#U!+W#U#f$}#f#g!+W#g#h!+W#h#o$}#o#p!%i#p#q$}#q#r!$g#r~$}<u!*eZkR%q7[%hS%kW%n`%tp%w!b%y#tOr$}rs&Rsw$}wxHsx#O$}#O#P!$R#P#o$}#o#p!%i#p#q$}#q#r!$g#r~$}<u!+kZ!jR%q7[%hS%kW%n`%tp%w!b%y#tOr$}rs&Rsw$}wxHsx#O$}#O#P!$R#P#o$}#o#p!%i#p#q$}#q#r!$g#r~$}G{!,m_%up%q7[%hS%f,X%n`%w!bOY!-lYZ'PZ]!-l]^'P^r!-lrs!G^sw!-lwx!/|x#O!-l#O#P!Cp#P#o!-l#o#p!F[#p#q!-l#q#r!DU#r~!-lGZ!-}_%q7[%hS%kW%f,X%n`%w!b%y#tOY!-lYZ'PZ]!-l]^'P^r!-lrs!.|sw!-lwx!/|x#O!-l#O#P!Cp#P#o!-l#o#p!F[#p#q!-l#q#r!DU#r~!-lGZ!/ZZ%q7[%hS%f,X%n`%w!bOr'PrsFisw'Pwx(Rx#O'P#O#PAe#P#o'P#o#pEu#p#q'P#q#rAy#r~'PFy!0X_%q7[%kW%f,X%y#tOY!1WYZ(}Z]!1W]^(}^r!1Wrs!2fsw!1Wwx!@Yx#O!1W#O#P!3d#P#o!1W#o#p!;t#p#q!1W#q#r!3x#r~!1WFy!1g_%q7[%hS%kW%f,X%w!b%y#tOY!1WYZ(}Z]!1W]^(}^r!1Wrs!2fsw!1Wwx!/|x#O!1W#O#P!3d#P#o!1W#o#p!;t#p#q!1W#q#r!3x#r~!1WFy!2qZ%q7[%hS%f,X%w!bOr(}rs*ysw(}wx(Rx#O(}#O#P2]#P#o(}#o#p:X#p#q(}#q#r2q#r~(}Fy!3iT%q7[O#o!1W#o#p!3x#p#q!1W#q#r!3x#r~!1W0m!4V]%hS%kW%f,X%w!b%y#tOY!3xYZ2qZ]!3x]^2q^r!3xrs!5Osw!3xwx!5tx#O!3x#O#P!;n#P#o!3x#o#p!;t#p~!3x0m!5XX%hS%f,X%w!bOr2qrs4]sw2qwx5Px#O2q#O#P:R#P#o2q#o#p:X#p~2q0m!5}]%kW%f,X%y#tOY!3xYZ2qZ]!3x]^2q^r!3xrs!5Osw!3xwx!6vx#O!3x#O#P!;n#P#o!3x#o#p!;t#p~!3x0m!7P]%kW%f,X%y#tOY!3xYZ2qZ]!3x]^2q^r!3xrs!5Osw!3xwx!7xx#O!3x#O#P!;n#P#o!3x#o#p!;t#p~!3x/V!8RZ%kW%f,X%y#tOY!7xYZ6gZ]!7x]^6g^r!7xrs!8ts#O!7x#O#P!9`#P#o!7x#o#p!9f#p~!7x/V!8yV%f,XOr6grs7ms#O6g#O#P8S#P#o6g#o#p8Y#p~6g/V!9cPO~!7x/V!9mZ%kW%f,XOY!:`YZ8tZ]!:`]^8t^r!:`rs!;Ss#O!:`#O#P!;h#P#o!:`#o#p!7x#p~!:`,a!:gX%kW%f,XOY!:`YZ8tZ]!:`]^8t^r!:`rs!;Ss#O!:`#O#P!;h#P~!:`,a!;XT%f,XOr8trs9ls#O8t#O#P9{#P~8t,a!;kPO~!:`0m!;qPO~!3x0m!;}]%hS%kW%f,XOY!<vYZ:{Z]!<v]^:{^r!<vrs!=rsw!<vwx!>`x#O!<v#O#P!@S#P#o!<v#o#p!3x#p~!<v,e!=PZ%hS%kW%f,XOY!<vYZ:{Z]!<v]^:{^r!<vrs!=rsw!<vwx!>`x#O!<v#O#P!@S#P~!<v,e!=yV%hS%f,XOr:{rs<Tsw:{wx<ox#O:{#O#P=u#P~:{,e!>gZ%kW%f,XOY!<vYZ:{Z]!<v]^:{^r!<vrs!=rsw!<vwx!?Yx#O!<v#O#P!@S#P~!<v,e!?aZ%kW%f,XOY!<vYZ:{Z]!<v]^:{^r!<vrs!=rsw!<vwx!:`x#O!<v#O#P!@S#P~!<v,e!@VPO~!<vFy!@e_%q7[%kW%f,X%y#tOY!1WYZ(}Z]!1W]^(}^r!1Wrs!2fsw!1Wwx!Adx#O!1W#O#P!3d#P#o!1W#o#p!;t#p#q!1W#q#r!3x#r~!1WEc!Ao]%q7[%kW%f,X%y#tOY!AdYZ>wZ]!Ad]^>w^r!Adrs!Bhs#O!Ad#O#P!C[#P#o!Ad#o#p!9f#p#q!Ad#q#r!7x#r~!AdEc!BoX%q7[%f,XOr>wrs@_s#O>w#O#PAP#P#o>w#o#p8Y#p#q>w#q#r6g#r~>wEc!CaT%q7[O#o!Ad#o#p!7x#p#q!Ad#q#r!7x#r~!AdGZ!CuT%q7[O#o!-l#o#p!DU#p#q!-l#q#r!DU#r~!-l0}!De]%hS%kW%f,X%n`%w!b%y#tOY!DUYZAyZ]!DU]^Ay^r!DUrs!E^sw!DUwx!5tx#O!DU#O#P!FU#P#o!DU#o#p!F[#p~!DU0}!EiX%hS%f,X%n`%w!bOrAyrsCiswAywx5Px#OAy#O#PEo#P#oAy#o#pEu#p~Ay0}!FXPO~!DU0}!Fe]%hS%kW%f,XOY!<vYZ:{Z]!<v]^:{^r!<vrs!=rsw!<vwx!>`x#O!<v#O#P!@S#P#o!<v#o#p!DU#p~!<vGZ!GkZ%q7[%hS%f,X%n`%w!bOr'Prs!H^sw'Pwx(Rx#O'P#O#PAe#P#o'P#o#pEu#p#q'P#q#rAy#r~'PGZ!HmX%l#|%q7[%hS%j,X%n`%w!bOwGgwx,kx#OGg#O#PH_#P#oGg#o#pET#p#qGg#q#rD_#r~GgMg!Im_Q1s%q7[%hS%kW%n`%tp%w!b%y#tOY!IYYZ$}Z]!IY]^$}^r!IYrs!Jlsw!IYwx$$[x#O!IY#O#P$1v#P#o!IY#o#p$4Y#p#q!IY#q#r$2j#r~!IYLu!Jy_Q1s%q7[%hS%n`%w!bOY!KxYZ'PZ]!Kx]^'P^r!Kxrs$ Usw!Kxwx!MYx#O!Kx#O#P#G^#P#o!Kx#o#p#NS#p#q!Kx#q#r#HQ#r~!KxLu!LZ_Q1s%q7[%hS%kW%n`%w!b%y#tOY!KxYZ'PZ]!Kx]^'P^r!Kxrs!Jlsw!Kxwx!MYx#O!Kx#O#P#G^#P#o!Kx#o#p#NS#p#q!Kx#q#r#HQ#r~!KxLe!Me_Q1s%q7[%kW%y#tOY!NdYZ(}Z]!Nd]^(}^r!Ndrs# rsw!Ndwx#B[x#O!Nd#O#P#/f#P#o!Nd#o#p#<b#p#q!Nd#q#r#0Y#r~!NdLe!Ns_Q1s%q7[%hS%kW%w!b%y#tOY!NdYZ(}Z]!Nd]^(}^r!Ndrs# rsw!Ndwx!MYx#O!Nd#O#P#/f#P#o!Nd#o#p#<b#p#q!Nd#q#r#0Y#r~!NdLe# }_Q1s%q7[%hS%w!bOY!NdYZ(}Z]!Nd]^(}^r!Ndrs#!|sw!Ndwx!MYx#O!Nd#O#P#/f#P#o!Nd#o#p#<b#p#q!Nd#q#r#0Y#r~!NdLe##X_Q1s%q7[%hS%w!bOY!NdYZ(}Z]!Nd]^(}^r!Ndrs#$Wsw!Ndwx!MYx#O!Nd#O#P#/f#P#o!Nd#o#p#<b#p#q!Nd#q#r#0Y#r~!NdIg#$c]Q1s%q7[%hS%w!bOY#$WYZ+uZ]#$W]^+u^w#$Wwx#%[x#O#$W#O#P#(^#P#o#$W#o#p#,Q#p#q#$W#q#r#)Q#r~#$WIg#%c]Q1s%q7[OY#$WYZ+uZ]#$W]^+u^w#$Wwx#&[x#O#$W#O#P#(^#P#o#$W#o#p#,Q#p#q#$W#q#r#)Q#r~#$WIg#&c]Q1s%q7[OY#$WYZ+uZ]#$W]^+u^w#$Wwx#'[x#O#$W#O#P#(^#P#o#$W#o#p#,Q#p#q#$W#q#r#)Q#r~#$WHP#'cXQ1s%q7[OY#'[YZ-}Z]#'[]^-}^#o#'[#o#p#(O#p#q#'[#q#r#(O#r~#'[1s#(TRQ1sOY#(OZ]#(O^~#(OIg#(eXQ1s%q7[OY#$WYZ+uZ]#$W]^+u^#o#$W#o#p#)Q#p#q#$W#q#r#)Q#r~#$W3Z#)ZZQ1s%hS%w!bOY#)QYZ.qZ]#)Q]^.q^w#)Qwx#)|x#O#)Q#O#P#+l#P#o#)Q#o#p#,Q#p~#)Q3Z#*RZQ1sOY#)QYZ.qZ]#)Q]^.q^w#)Qwx#*tx#O#)Q#O#P#+l#P#o#)Q#o#p#,Q#p~#)Q3Z#*yZQ1sOY#)QYZ.qZ]#)Q]^.q^w#)Qwx#(Ox#O#)Q#O#P#+l#P#o#)Q#o#p#,Q#p~#)Q3Z#+qTQ1sOY#)QYZ.qZ]#)Q]^.q^~#)Q3Z#,XZQ1s%hSOY#,zYZ1OZ]#,z]^1O^w#,zwx#-nx#O#,z#O#P#/Q#P#o#,z#o#p#)Q#p~#,z1w#-RXQ1s%hSOY#,zYZ1OZ]#,z]^1O^w#,zwx#-nx#O#,z#O#P#/Q#P~#,z1w#-sXQ1sOY#,zYZ1OZ]#,z]^1O^w#,zwx#.`x#O#,z#O#P#/Q#P~#,z1w#.eXQ1sOY#,zYZ1OZ]#,z]^1O^w#,zwx#(Ox#O#,z#O#P#/Q#P~#,z1w#/VTQ1sOY#,zYZ1OZ]#,z]^1O^~#,zLe#/mXQ1s%q7[OY!NdYZ(}Z]!Nd]^(}^#o!Nd#o#p#0Y#p#q!Nd#q#r#0Y#r~!Nd6X#0g]Q1s%hS%kW%w!b%y#tOY#0YYZ2qZ]#0Y]^2q^r#0Yrs#1`sw#0Ywx#3dx#O#0Y#O#P#;|#P#o#0Y#o#p#<b#p~#0Y6X#1i]Q1s%hS%w!bOY#0YYZ2qZ]#0Y]^2q^r#0Yrs#2bsw#0Ywx#3dx#O#0Y#O#P#;|#P#o#0Y#o#p#<b#p~#0Y6X#2k]Q1s%hS%w!bOY#0YYZ2qZ]#0Y]^2q^r#0Yrs#)Qsw#0Ywx#3dx#O#0Y#O#P#;|#P#o#0Y#o#p#<b#p~#0Y6X#3m]Q1s%kW%y#tOY#0YYZ2qZ]#0Y]^2q^r#0Yrs#1`sw#0Ywx#4fx#O#0Y#O#P#;|#P#o#0Y#o#p#<b#p~#0Y6X#4o]Q1s%kW%y#tOY#0YYZ2qZ]#0Y]^2q^r#0Yrs#1`sw#0Ywx#5hx#O#0Y#O#P#;|#P#o#0Y#o#p#<b#p~#0Y4q#5qZQ1s%kW%y#tOY#5hYZ6gZ]#5h]^6g^r#5hrs#6ds#O#5h#O#P#8S#P#o#5h#o#p#8h#p~#5h4q#6iZQ1sOY#5hYZ6gZ]#5h]^6g^r#5hrs#7[s#O#5h#O#P#8S#P#o#5h#o#p#8h#p~#5h4q#7aZQ1sOY#5hYZ6gZ]#5h]^6g^r#5hrs#(Os#O#5h#O#P#8S#P#o#5h#o#p#8h#p~#5h4q#8XTQ1sOY#5hYZ6gZ]#5h]^6g^~#5h4q#8oZQ1s%kWOY#9bYZ8tZ]#9b]^8t^r#9brs#:Us#O#9b#O#P#;h#P#o#9b#o#p#5h#p~#9b1{#9iXQ1s%kWOY#9bYZ8tZ]#9b]^8t^r#9brs#:Us#O#9b#O#P#;h#P~#9b1{#:ZXQ1sOY#9bYZ8tZ]#9b]^8t^r#9brs#:vs#O#9b#O#P#;h#P~#9b1{#:{XQ1sOY#9bYZ8tZ]#9b]^8t^r#9brs#(Os#O#9b#O#P#;h#P~#9b1{#;mTQ1sOY#9bYZ8tZ]#9b]^8t^~#9b6X#<RTQ1sOY#0YYZ2qZ]#0Y]^2q^~#0Y6X#<k]Q1s%hS%kWOY#=dYZ:{Z]#=d]^:{^r#=drs#>`sw#=dwx#@Sx#O#=d#O#P#Av#P#o#=d#o#p#0Y#p~#=d2P#=mZQ1s%hS%kWOY#=dYZ:{Z]#=d]^:{^r#=drs#>`sw#=dwx#@Sx#O#=d#O#P#Av#P~#=d2P#>gZQ1s%hSOY#=dYZ:{Z]#=d]^:{^r#=drs#?Ysw#=dwx#@Sx#O#=d#O#P#Av#P~#=d2P#?aZQ1s%hSOY#=dYZ:{Z]#=d]^:{^r#=drs#,zsw#=dwx#@Sx#O#=d#O#P#Av#P~#=d2P#@ZZQ1s%kWOY#=dYZ:{Z]#=d]^:{^r#=drs#>`sw#=dwx#@|x#O#=d#O#P#Av#P~#=d2P#ATZQ1s%kWOY#=dYZ:{Z]#=d]^:{^r#=drs#>`sw#=dwx#9bx#O#=d#O#P#Av#P~#=d2P#A{TQ1sOY#=dYZ:{Z]#=d]^:{^~#=dLe#Bg_Q1s%q7[%kW%y#tOY!NdYZ(}Z]!Nd]^(}^r!Ndrs# rsw!Ndwx#Cfx#O!Nd#O#P#/f#P#o!Nd#o#p#<b#p#q!Nd#q#r#0Y#r~!NdJ}#Cq]Q1s%q7[%kW%y#tOY#CfYZ>wZ]#Cf]^>w^r#Cfrs#Djs#O#Cf#O#P#Fj#P#o#Cf#o#p#8h#p#q#Cf#q#r#5h#r~#CfJ}#Dq]Q1s%q7[OY#CfYZ>wZ]#Cf]^>w^r#Cfrs#Ejs#O#Cf#O#P#Fj#P#o#Cf#o#p#8h#p#q#Cf#q#r#5h#r~#CfJ}#Eq]Q1s%q7[OY#CfYZ>wZ]#Cf]^>w^r#Cfrs#'[s#O#Cf#O#P#Fj#P#o#Cf#o#p#8h#p#q#Cf#q#r#5h#r~#CfJ}#FqXQ1s%q7[OY#CfYZ>wZ]#Cf]^>w^#o#Cf#o#p#5h#p#q#Cf#q#r#5h#r~#CfLu#GeXQ1s%q7[OY!KxYZ'PZ]!Kx]^'P^#o!Kx#o#p#HQ#p#q!Kx#q#r#HQ#r~!Kx6i#Ha]Q1s%hS%kW%n`%w!b%y#tOY#HQYZAyZ]#HQ]^Ay^r#HQrs#IYsw#HQwx#3dx#O#HQ#O#P#Mn#P#o#HQ#o#p#NS#p~#HQ6i#Ie]Q1s%hS%n`%w!bOY#HQYZAyZ]#HQ]^Ay^r#HQrs#J^sw#HQwx#3dx#O#HQ#O#P#Mn#P#o#HQ#o#p#NS#p~#HQ6i#Ji]Q1s%hS%n`%w!bOY#HQYZAyZ]#HQ]^Ay^r#HQrs#Kbsw#HQwx#3dx#O#HQ#O#P#Mn#P#o#HQ#o#p#NS#p~#HQ3k#KmZQ1s%hS%n`%w!bOY#KbYZD_Z]#Kb]^D_^w#Kbwx#)|x#O#Kb#O#P#L`#P#o#Kb#o#p#Lt#p~#Kb3k#LeTQ1sOY#KbYZD_Z]#Kb]^D_^~#Kb3k#L{ZQ1s%hSOY#,zYZ1OZ]#,z]^1O^w#,zwx#-nx#O#,z#O#P#/Q#P#o#,z#o#p#Kb#p~#,z6i#MsTQ1sOY#HQYZAyZ]#HQ]^Ay^~#HQ6i#N]]Q1s%hS%kWOY#=dYZ:{Z]#=d]^:{^r#=drs#>`sw#=dwx#@Sx#O#=d#O#P#Av#P#o#=d#o#p#HQ#p~#=dLu$ c_Q1s%q7[%hS%n`%w!bOY!KxYZ'PZ]!Kx]^'P^r!Kxrs$!bsw!Kxwx!MYx#O!Kx#O#P#G^#P#o!Kx#o#p#NS#p#q!Kx#q#r#HQ#r~!KxIw$!o]Q1s%q7[%hS%n`%w!bOY$!bYZGgZ]$!b]^Gg^w$!bwx#%[x#O$!b#O#P$#h#P#o$!b#o#p#Lt#p#q$!b#q#r#Kb#r~$!bIw$#oXQ1s%q7[OY$!bYZGgZ]$!b]^Gg^#o$!b#o#p#Kb#p#q$!b#q#r#Kb#r~$!bMV$$i_Q1s%q7[%kW%tp%y#tOY$%hYZIqZ]$%h]^Iq^r$%hrs# rsw$%hwx$.px#O$%h#O#P$&x#P#o$%h#o#p$-n#p#q$%h#q#r$'l#r~$%hMV$%y_Q1s%q7[%hS%kW%tp%w!b%y#tOY$%hYZIqZ]$%h]^Iq^r$%hrs# rsw$%hwx$$[x#O$%h#O#P$&x#P#o$%h#o#p$-n#p#q$%h#q#r$'l#r~$%hMV$'PXQ1s%q7[OY$%hYZIqZ]$%h]^Iq^#o$%h#o#p$'l#p#q$%h#q#r$'l#r~$%h6y$'{]Q1s%hS%kW%tp%w!b%y#tOY$'lYZKXZ]$'l]^KX^r$'lrs#1`sw$'lwx$(tx#O$'l#O#P$-Y#P#o$'l#o#p$-n#p~$'l6y$)P]Q1s%kW%tp%y#tOY$'lYZKXZ]$'l]^KX^r$'lrs#1`sw$'lwx$)xx#O$'l#O#P$-Y#P#o$'l#o#p$-n#p~$'l6y$*T]Q1s%kW%tp%y#tOY$'lYZKXZ]$'l]^KX^r$'lrs#1`sw$'lwx$*|x#O$'l#O#P$-Y#P#o$'l#o#p$-n#p~$'l5c$+XZQ1s%kW%tp%y#tOY$*|YZMmZ]$*|]^Mm^r$*|rs#6ds#O$*|#O#P$+z#P#o$*|#o#p$,`#p~$*|5c$,PTQ1sOY$*|YZMmZ]$*|]^Mm^~$*|5c$,gZQ1s%kWOY#9bYZ8tZ]#9b]^8t^r#9brs#:Us#O#9b#O#P#;h#P#o#9b#o#p$*|#p~#9b6y$-_TQ1sOY$'lYZKXZ]$'l]^KX^~$'l6y$-w]Q1s%hS%kWOY#=dYZ:{Z]#=d]^:{^r#=drs#>`sw#=dwx#@Sx#O#=d#O#P#Av#P#o#=d#o#p$'l#p~#=dMV$.}_Q1s%q7[%kW%tp%y#tOY$%hYZIqZ]$%h]^Iq^r$%hrs# rsw$%hwx$/|x#O$%h#O#P$&x#P#o$%h#o#p$-n#p#q$%h#q#r$'l#r~$%hKo$0Z]Q1s%q7[%kW%tp%y#tOY$/|YZ!!uZ]$/|]^!!u^r$/|rs#Djs#O$/|#O#P$1S#P#o$/|#o#p$,`#p#q$/|#q#r$*|#r~$/|Ko$1ZXQ1s%q7[OY$/|YZ!!uZ]$/|]^!!u^#o$/|#o#p$*|#p#q$/|#q#r$*|#r~$/|Mg$1}XQ1s%q7[OY!IYYZ$}Z]!IY]^$}^#o!IY#o#p$2j#p#q!IY#q#r$2j#r~!IY7Z$2{]Q1s%hS%kW%n`%tp%w!b%y#tOY$2jYZ!$gZ]$2j]^!$g^r$2jrs#IYsw$2jwx$(tx#O$2j#O#P$3t#P#o$2j#o#p$4Y#p~$2j7Z$3yTQ1sOY$2jYZ!$gZ]$2j]^!$g^~$2j7Z$4c]Q1s%hS%kWOY#=dYZ:{Z]#=d]^:{^r#=drs#>`sw#=dwx#@Sx#O#=d#O#P#Av#P#o#=d#o#p$2j#p~#=dGz$5o]$}Q%q7[%hS%kW%n`%tp%w!b%y#tOr$}rs&Rsw$}wxHsx!_$}!_!`$6h!`#O$}#O#P!$R#P#o$}#o#p!%i#p#q$}#q#r!$g#r~$}Gz$6{Z!s,W%q7[%hS%kW%n`%tp%w!b%y#tOr$}rs&Rsw$}wxHsx#O$}#O#P!$R#P#o$}#o#p!%i#p#q$}#q#r!$g#r~$}Gz$8R]$wQ%q7[%hS%kW%n`%tp%w!b%y#tOr$}rs&Rsw$}wxHsx!_$}!_!`$6h!`#O$}#O#P!$R#P#o$}#o#p!%i#p#q$}#q#r!$g#r~$}G{$9Z_%r`%q7[%kW%f,X%tp%y#tOY$:YYZIqZ]$:Y]^Iq^r$:Yrs$;jsw$:Ywx%%zx#O$:Y#O#P%!^#P#o$:Y#o#p%$x#p#q$:Y#q#r%!r#r~$:YGk$:k_%q7[%hS%kW%f,X%tp%w!b%y#tOY$:YYZIqZ]$:Y]^Iq^r$:Yrs$;jsw$:Ywx% ^x#O$:Y#O#P%!^#P#o$:Y#o#p%$x#p#q$:Y#q#r%!r#r~$:YFy$;u_%q7[%hS%f,X%w!bOY$<tYZ(}Z]$<t]^(}^r$<trs$Kvsw$<twx$>Sx#O$<t#O#P$?Q#P#o$<t#o#p$Gb#p#q$<t#q#r$?f#r~$<tFy$=T_%q7[%hS%kW%f,X%w!b%y#tOY$<tYZ(}Z]$<t]^(}^r$<trs$;jsw$<twx$>Sx#O$<t#O#P$?Q#P#o$<t#o#p$Gb#p#q$<t#q#r$?f#r~$<tFy$>_Z%q7[%kW%f,X%y#tOr(}rs)}sw(}wx={x#O(}#O#P2]#P#o(}#o#p:X#p#q(}#q#r2q#r~(}Fy$?VT%q7[O#o$<t#o#p$?f#p#q$<t#q#r$?f#r~$<t0m$?s]%hS%kW%f,X%w!b%y#tOY$?fYZ2qZ]$?f]^2q^r$?frs$@lsw$?fwx$Ffx#O$?f#O#P$G[#P#o$?f#o#p$Gb#p~$?f0m$@u]%hS%f,X%w!bOY$?fYZ2qZ]$?f]^2q^r$?frs$Answ$?fwx$Ffx#O$?f#O#P$G[#P#o$?f#o#p$Gb#p~$?f0m$Aw]%hS%f,X%w!bOY$?fYZ2qZ]$?f]^2q^r$?frs$Bpsw$?fwx$Ffx#O$?f#O#P$G[#P#o$?f#o#p$Gb#p~$?f-o$ByZ%hS%f,X%w!bOY$BpYZ.qZ]$Bp]^.q^w$Bpwx$Clx#O$Bp#O#P$DW#P#o$Bp#o#p$D^#p~$Bp-o$CqV%f,XOw.qwx/wx#O.q#O#P0^#P#o.q#o#p0d#p~.q-o$DZPO~$Bp-o$DeZ%hS%f,XOY$EWYZ1OZ]$EW]^1O^w$EWwx$Ezx#O$EW#O#P$F`#P#o$EW#o#p$Bp#p~$EW,]$E_X%hS%f,XOY$EWYZ1OZ]$EW]^1O^w$EWwx$Ezx#O$EW#O#P$F`#P~$EW,]$FPT%f,XOw1Owx1vx#O1O#O#P2V#P~1O,]$FcPO~$EW0m$FoX%kW%f,X%y#tOr2qrs3isw2qwx5sx#O2q#O#P:R#P#o2q#o#p:X#p~2q0m$G_PO~$?f0m$Gk]%hS%kW%f,XOY$HdYZ:{Z]$Hd]^:{^r$Hdrs$I`sw$Hdwx$KSx#O$Hd#O#P$Kp#P#o$Hd#o#p$?f#p~$Hd,e$HmZ%hS%kW%f,XOY$HdYZ:{Z]$Hd]^:{^r$Hdrs$I`sw$Hdwx$KSx#O$Hd#O#P$Kp#P~$Hd,e$IgZ%hS%f,XOY$HdYZ:{Z]$Hd]^:{^r$Hdrs$JYsw$Hdwx$KSx#O$Hd#O#P$Kp#P~$Hd,e$JaZ%hS%f,XOY$HdYZ:{Z]$Hd]^:{^r$Hdrs$EWsw$Hdwx$KSx#O$Hd#O#P$Kp#P~$Hd,e$KZV%kW%f,XOr:{rs;isw:{wx=Zx#O:{#O#P=u#P~:{,e$KsPO~$HdFy$LR_%q7[%hS%f,X%w!bOY$<tYZ(}Z]$<t]^(}^r$<trs$MQsw$<twx$>Sx#O$<t#O#P$?Q#P#o$<t#o#p$Gb#p#q$<t#q#r$?f#r~$<tC{$M]]%q7[%hS%f,X%w!bOY$MQYZ+uZ]$MQ]^+u^w$MQwx$NUx#O$MQ#O#P$Nx#P#o$MQ#o#p$D^#p#q$MQ#q#r$Bp#r~$MQC{$N]X%q7[%f,XOw+uwx-]x#O+u#O#P.]#P#o+u#o#p0d#p#q+u#q#r.q#r~+uC{$N}T%q7[O#o$MQ#o#p$Bp#p#q$MQ#q#r$Bp#r~$MQGk% kZ%q7[%kW%f,X%tp%y#tOrIqrs)}swIqwx! wx#OIq#O#PJs#P#oIq#o#p! T#p#qIq#q#rKX#r~IqGk%!cT%q7[O#o$:Y#o#p%!r#p#q$:Y#q#r%!r#r~$:Y1_%#R]%hS%kW%f,X%tp%w!b%y#tOY%!rYZKXZ]%!r]^KX^r%!rrs$@lsw%!rwx%#zx#O%!r#O#P%$r#P#o%!r#o#p%$x#p~%!r1_%$VX%kW%f,X%tp%y#tOrKXrs3iswKXwxLwx#OKX#O#PN}#P#oKX#o#p! T#p~KX1_%$uPO~%!r1_%%R]%hS%kW%f,XOY$HdYZ:{Z]$Hd]^:{^r$Hdrs$I`sw$Hdwx$KSx#O$Hd#O#P$Kp#P#o$Hd#o#p%!r#p~$HdGk%&XZ%q7[%kW%f,X%tp%y#tOrIqrs)}swIqwx%&zx#OIq#O#PJs#P#oIq#o#p! T#p#qIq#q#rKX#r~IqGk%'ZX%i!f%q7[%kW%g,X%tp%y#tOr!!urs?ms#O!!u#O#P!#m#P#o!!u#o#pNc#p#q!!u#q#rMm#r~!!uG{%(ZZf,X%q7[%hS%kW%n`%tp%w!b%y#tOr$}rs&Rsw$}wxHsx#O$}#O#P!$R#P#o$}#o#p!%i#p#q$}#q#r!$g#r~$}<u%)aZeR%q7[%hS%kW%n`%tp%w!b%y#tOr$}rs&Rsw$}wxHsx#O$}#O#P!$R#P#o$}#o#p!%i#p#q$}#q#r!$g#r~$}G{%*g_T,X%q7[%hS%kW%n`%tp%w!b%y#tOr$}rs&Rsw$}wxHsxz$}z{%+f{!_$}!_!`$6h!`#O$}#O#P!$R#P#o$}#o#p!%i#p#q$}#q#r!$g#r~$}G{%+y]_R%q7[%hS%kW%n`%tp%w!b%y#tOr$}rs&Rsw$}wxHsx!_$}!_!`$6h!`#O$}#O#P!$R#P#o$}#o#p!%i#p#q$}#q#r!$g#r~$}G{%-V]$z,X%q7[%hS%kW%n`%tp%w!b%y#tOr$}rs&Rsw$}wxHsx!_$}!_!`$6h!`#O$}#O#P!$R#P#o$}#o#p!%i#p#q$}#q#r!$g#r~$}<u%.cZxR%q7[%hS%kW%n`%tp%w!b%y#tOr$}rs&Rsw$}wxHsx#O$}#O#P!$R#P#o$}#o#p!%i#p#q$}#q#r!$g#r~$}Mg%/i^${,X%q7[%hS%kW%n`%tp%w!b%y#tOr$}rs&Rsw$}wxHsx!_$}!_!`$6h!`!a%0e!a#O$}#O#P!$R#P#o$}#o#p!%i#p#q$}#q#r!$g#r~$}B^%0xZ&U&j%q7[%hS%kW%n`%tp%w!b%y#tOr$}rs&Rsw$}wxHsx#O$}#O#P!$R#P#o$}#o#p!%i#p#q$}#q#r!$g#r~$}G{%2O_!dQ%q7[%hS%kW%n`%tp%w!b%y#tOr$}rs&Rsw$}wxHsx!O$}!O!P%2}!P!Q$}!Q![%5_![#O$}#O#P!$R#P#o$}#o#p!%i#p#q$}#q#r!$g#r~$}G{%3`]%q7[%hS%kW%n`%tp%w!b%y#tOr$}rs&Rsw$}wxHsx!O$}!O!P%4X!P#O$}#O#P!$R#P#o$}#o#p!%i#p#q$}#q#r!$g#r~$}G{%4lZ!m,X%q7[%hS%kW%n`%tp%w!b%y#tOr$}rs&Rsw$}wxHsx#O$}#O#P!$R#P#o$}#o#p!%i#p#q$}#q#r!$g#r~$}Gy%5rg!f,V%q7[%hS%kW%n`%tp%w!b%y#tOr$}rs&Rsw$}wxHsx!Q$}!Q![%5_![!g$}!g!h%7Z!h!l$}!l!m%;k!m#O$}#O#P!$R#P#R$}#R#S%5_#S#X$}#X#Y%7Z#Y#^$}#^#_%;k#_#o$}#o#p!%i#p#q$}#q#r!$g#r~$}Gy%7la%q7[%hS%kW%n`%tp%w!b%y#tOr$}rs&Rsw$}wxHsx{$}{|%8q|}$}}!O%8q!O!Q$}!Q![%9{![#O$}#O#P!$R#P#o$}#o#p!%i#p#q$}#q#r!$g#r~$}Gy%9S]%q7[%hS%kW%n`%tp%w!b%y#tOr$}rs&Rsw$}wxHsx!Q$}!Q![%9{![#O$}#O#P!$R#P#o$}#o#p!%i#p#q$}#q#r!$g#r~$}Gy%:`c!f,V%q7[%hS%kW%n`%tp%w!b%y#tOr$}rs&Rsw$}wxHsx!Q$}!Q![%9{![!l$}!l!m%;k!m#O$}#O#P!$R#P#R$}#R#S%9{#S#^$}#^#_%;k#_#o$}#o#p!%i#p#q$}#q#r!$g#r~$}Gy%<OZ!f,V%q7[%hS%kW%n`%tp%w!b%y#tOr$}rs&Rsw$}wxHsx#O$}#O#P!$R#P#o$}#o#p!%i#p#q$}#q#r!$g#r~$}G{%=U_$|R%q7[%hS%kW%n`%tp%w!b%y#tOr$}rs&Rsw$}wxHsx!P$}!P!Q%>T!Q!_$}!_!`$6h!`#O$}#O#P!$R#P#o$}#o#p!%i#p#q$}#q#r!$g#r~$}Gz%>h]%OQ%q7[%hS%kW%n`%tp%w!b%y#tOr$}rs&Rsw$}wxHsx!_$}!_!`$6h!`#O$}#O#P!$R#P#o$}#o#p!%i#p#q$}#q#r!$g#r~$}Gy%?tu!f,V%q7[%hS%kW%n`%tp%w!b%y#tOr$}rs&Rsw$}wxHsx!O$}!O!P%BX!P!Q$}!Q![%Cc![!d$}!d!e%Ee!e!g$}!g!h%7Z!h!l$}!l!m%;k!m!q$}!q!r%H_!r!z$}!z!{%KR!{#O$}#O#P!$R#P#R$}#R#S%Cc#S#U$}#U#V%Ee#V#X$}#X#Y%7Z#Y#^$}#^#_%;k#_#c$}#c#d%H_#d#l$}#l#m%KR#m#o$}#o#p!%i#p#q$}#q#r!$g#r~$}Gy%Bj]%q7[%hS%kW%n`%tp%w!b%y#tOr$}rs&Rsw$}wxHsx!Q$}!Q![%5_![#O$}#O#P!$R#P#o$}#o#p!%i#p#q$}#q#r!$g#r~$}Gy%Cvi!f,V%q7[%hS%kW%n`%tp%w!b%y#tOr$}rs&Rsw$}wxHsx!O$}!O!P%BX!P!Q$}!Q![%Cc![!g$}!g!h%7Z!h!l$}!l!m%;k!m#O$}#O#P!$R#P#R$}#R#S%Cc#S#X$}#X#Y%7Z#Y#^$}#^#_%;k#_#o$}#o#p!%i#p#q$}#q#r!$g#r~$}Gy%Ev`%q7[%hS%kW%n`%tp%w!b%y#tOr$}rs&Rsw$}wxHsx!Q$}!Q!R%Fx!R!S%Fx!S#O$}#O#P!$R#P#R$}#R#S%Fx#S#o$}#o#p!%i#p#q$}#q#r!$g#r~$}Gy%G]`!f,V%q7[%hS%kW%n`%tp%w!b%y#tOr$}rs&Rsw$}wxHsx!Q$}!Q!R%Fx!R!S%Fx!S#O$}#O#P!$R#P#R$}#R#S%Fx#S#o$}#o#p!%i#p#q$}#q#r!$g#r~$}Gy%Hp_%q7[%hS%kW%n`%tp%w!b%y#tOr$}rs&Rsw$}wxHsx!Q$}!Q!Y%Io!Y#O$}#O#P!$R#P#R$}#R#S%Io#S#o$}#o#p!%i#p#q$}#q#r!$g#r~$}Gy%JS_!f,V%q7[%hS%kW%n`%tp%w!b%y#tOr$}rs&Rsw$}wxHsx!Q$}!Q!Y%Io!Y#O$}#O#P!$R#P#R$}#R#S%Io#S#o$}#o#p!%i#p#q$}#q#r!$g#r~$}Gy%Kdc%q7[%hS%kW%n`%tp%w!b%y#tOr$}rs&Rsw$}wxHsx!Q$}!Q![%Lo![!c$}!c!i%Lo!i#O$}#O#P!$R#P#R$}#R#S%Lo#S#T$}#T#Z%Lo#Z#o$}#o#p!%i#p#q$}#q#r!$g#r~$}Gy%MSc!f,V%q7[%hS%kW%n`%tp%w!b%y#tOr$}rs&Rsw$}wxHsx!Q$}!Q![%Lo![!c$}!c!i%Lo!i#O$}#O#P!$R#P#R$}#R#S%Lo#S#T$}#T#Z%Lo#Z#o$}#o#p!%i#p#q$}#q#r!$g#r~$}Mg%Nr]y1s%q7[%hS%kW%n`%tp%w!b%y#tOr$}rs&Rsw$}wxHsx!_$}!_!`& k!`#O$}#O#P!$R#P#o$}#o#p!%i#p#q$}#q#r!$g#r~$}<u&!OZ%WR%q7[%hS%kW%n`%tp%w!b%y#tOr$}rs&Rsw$}wxHsx#O$}#O#P!$R#P#o$}#o#p!%i#p#q$}#q#r!$g#r~$}G{&#UZ#^,X%q7[%hS%kW%n`%tp%w!b%y#tOr$}rs&Rsw$}wxHsx#O$}#O#P!$R#P#o$}#o#p!%i#p#q$}#q#r!$g#r~$}G{&$[_kR%q7[%hS%kW%n`%tp%w!b%y#tOr$}rs&Rsw$}wxHsx!^$}!^!_&%Z!_!`!*Q!`!a!*Q!a#O$}#O#P!$R#P#o$}#o#p!%i#p#q$}#q#r!$g#r~$}Gz&%n]$xQ%q7[%hS%kW%n`%tp%w!b%y#tOr$}rs&Rsw$}wxHsx!_$}!_!`$6h!`#O$}#O#P!$R#P#o$}#o#p!%i#p#q$}#q#r!$g#r~$}G{&&z]%V,X%q7[%hS%kW%n`%tp%w!b%y#tOr$}rs&Rsw$}wxHsx!_$}!_!`!*Q!`#O$}#O#P!$R#P#o$}#o#p!%i#p#q$}#q#r!$g#r~$}G{&(W^kR%q7[%hS%kW%n`%tp%w!b%y#tOr$}rs&Rsw$}wxHsx!_$}!_!`!*Q!`!a&)S!a#O$}#O#P!$R#P#o$}#o#p!%i#p#q$}#q#r!$g#r~$}Gz&)g]$yQ%q7[%hS%kW%n`%tp%w!b%y#tOr$}rs&Rsw$}wxHsx!_$}!_!`$6h!`#O$}#O#P!$R#P#o$}#o#p!%i#p#q$}#q#r!$g#r~$}G{&*u]]Q#tP%q7[%hS%kW%n`%tp%w!b%y#tOr$}rs&Rsw$}wxHsx!_$}!_!`$6h!`#O$}#O#P!$R#P#o$}#o#p!%i#p#q$}#q#r!$g#r~$}Mg&,Tc%q7[%hS%kW%e&j%n`%tp%w!b%y#t%Q,XOr$}rs&Rsw$}wxHsx!Q$}!Q![&+n![!c$}!c!}&+n!}#O$}#O#P!$R#P#R$}#R#S&+n#S#T$}#T#o&+n#o#p!%i#p#q$}#q#r!$g#r$g$}$g~&+nMg&-ug%q7[%hS%kW%e&j%n`%tp%w!b%y#t%Q,XOr$}rs&/^sw$}wx&2dx!Q$}!Q![&+n![!c$}!c!t&+n!t!u&5j!u!}&+n!}#O$}#O#P!$R#P#R$}#R#S&+n#S#T$}#T#f&+n#f#g&5j#g#o&+n#o#p!%i#p#q$}#q#r!$g#r$g$}$g~&+nGZ&/k_%q7[%hS%f,X%n`%w!bOY!-lYZ'PZ]!-l]^'P^r!-lrs&0jsw!-lwx!/|x#O!-l#O#P!Cp#P#o!-l#o#p!F[#p#q!-l#q#r!DU#r~!-lGZ&0wZ%q7[%hS%f,X%n`%w!bOr'Prs&1jsw'Pwx(Rx#O'P#O#PAe#P#o'P#o#pEu#p#q'P#q#rAy#r~'PD]&1wX%q7[%hS%j,X%n`%w!bOwGgwx,kx#OGg#O#PH_#P#oGg#o#pET#p#qGg#q#rD_#r~GgGk&2q_%q7[%kW%f,X%tp%y#tOY$:YYZIqZ]$:Y]^Iq^r$:Yrs$;jsw$:Ywx&3px#O$:Y#O#P%!^#P#o$:Y#o#p%$x#p#q$:Y#q#r%!r#r~$:YGk&3}Z%q7[%kW%f,X%tp%y#tOrIqrs)}swIqwx&4px#OIq#O#PJs#P#oIq#o#p! T#p#qIq#q#rKX#r~IqFT&4}X%q7[%kW%g,X%tp%y#tOr!!urs?ms#O!!u#O#P!#m#P#o!!u#o#pNc#p#q!!u#q#rMm#r~!!uMg&6Pc%q7[%hS%kW%e&j%n`%tp%w!b%y#t%Q,XOr$}rs&/^sw$}wx&2dx!Q$}!Q![&+n![!c$}!c!}&+n!}#O$}#O#P!$R#P#R$}#R#S&+n#S#T$}#T#o&+n#o#p!%i#p#q$}#q#r!$g#r$g$}$g~&+nMg&7qg%q7[%hS%kW%e&j%n`%tp%w!b%y#t%Q,XOr$}rs&9Ysw$}wx&<Qx!Q$}!Q![&+n![!c$}!c!t&+n!t!u&>x!u!}&+n!}#O$}#O#P!$R#P#R$}#R#S&+n#S#T$}#T#f&+n#f#g&>x#g#o&+n#o#p!%i#p#q$}#q#r!$g#r$g$}$g~&+nGZ&9gZ%q7[%hS%n`%w!b%s,XOr'Prs&:Ysw'Pwx(Rx#O'P#O#PAe#P#o'P#o#pEu#p#q'P#q#rAy#r~'PGZ&:eZ%q7[%hS%n`%w!bOr'Prs&;Wsw'Pwx(Rx#O'P#O#PAe#P#o'P#o#pEu#p#q'P#q#rAy#r~'PD]&;eX%q7[%hS%x,X%n`%w!bOwGgwx,kx#OGg#O#PH_#P#oGg#o#pET#p#qGg#q#rD_#r~GgGk&<_Z%q7[%kW%tp%y#t%m,XOrIqrs)}swIqwx&=Qx#OIq#O#PJs#P#oIq#o#p! T#p#qIq#q#rKX#r~IqGk&=]Z%q7[%kW%tp%y#tOrIqrs)}swIqwx&>Ox#OIq#O#PJs#P#oIq#o#p! T#p#qIq#q#rKX#r~IqFT&>]X%q7[%kW%v,X%tp%y#tOr!!urs?ms#O!!u#O#P!#m#P#o!!u#o#pNc#p#q!!u#q#rMm#r~!!uMg&?_c%q7[%hS%kW%e&j%n`%tp%w!b%y#t%Q,XOr$}rs&9Ysw$}wx&<Qx!Q$}!Q![&+n![!c$}!c!}&+n!}#O$}#O#P!$R#P#R$}#R#S&+n#S#T$}#T#o&+n#o#p!%i#p#q$}#q#r!$g#r$g$}$g~&+nMg&APk%q7[%hS%kW%e&j%n`%tp%w!b%y#t%Q,XOr$}rs&/^sw$}wx&2dx!Q$}!Q![&+n![!c$}!c!h&+n!h!i&>x!i!t&+n!t!u&5j!u!}&+n!}#O$}#O#P!$R#P#R$}#R#S&+n#S#T$}#T#U&+n#U#V&5j#V#Y&+n#Y#Z&>x#Z#o&+n#o#p!%i#p#q$}#q#r!$g#r$g$}$g~&+nG{&CXZ!V,X%q7[%hS%kW%n`%tp%w!b%y#tOr$}rs&Rsw$}wxHsx#O$}#O#P!$R#P#o$}#o#p!%i#p#q$}#q#r!$g#r~$}<u&D_Z!UR%q7[%hS%kW%n`%tp%w!b%y#tOr$}rs&Rsw$}wxHsx#O$}#O#P!$R#P#o$}#o#p!%i#p#q$}#q#r!$g#r~$}Gz&Ee]$vQ%q7[%hS%kW%n`%tp%w!b%y#tOr$}rs&Rsw$}wxHsx!_$}!_!`$6h!`#O$}#O#P!$R#P#o$}#o#p!%i#p#q$}#q#r!$g#r~$}Gy&FgX%hS%kW!ZGmOr:{rs;isw:{wx<ox#O:{#O#P=u#P#o:{#o#p!$g#p~:{Gz&Gg]$uQ%q7[%hS%kW%n`%tp%w!b%y#tOr$}rs&Rsw$}wxHsx!_$}!_!`$6h!`#O$}#O#P!$R#P#o$}#o#p!%i#p#q$}#q#r!$g#r~$}<u&HqX!Y7_%hS%kW%n`%tp%w!b%y#tOr!$grsBssw!$gwxLRx#O!$g#O#P!%c#P#o!$g#o#p!%i#p~!$gGy&IqZ%P,V%q7[%hS%kW%n`%tp%w!b%y#tOr$}rs&Rsw$}wxHsx#O$}#O#P!$R#P#o$}#o#p!%i#p#q$}#q#r!$g#r~$}",
  tokenizers: [legacyPrint, indentation, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, newlines],
  topRules: { "Script": [0, 3] },
  specialized: [{ term: 186, get: (value) => spec_identifier[value] || -1 }],
  tokenPrec: 6584
});

// node_modules/@codemirror/lang-python/dist/index.js
var import_language = require("@codemirror/language");
function indentBody(context, node) {
  let base = context.lineIndent(node.from);
  let line = context.lineAt(context.pos, -1), to = line.from + line.text.length;
  if (!/\S/.test(line.text) && context.node.to < to + 100 && !/\S/.test(context.state.sliceDoc(to, context.node.to)) && context.lineIndent(context.pos, -1) <= base)
    return null;
  if (/^\s*(else:|elif |except |finally:)/.test(context.textAfter) && context.lineIndent(context.pos, -1) > base)
    return null;
  return base + context.unit;
}
var pythonLanguage = /* @__PURE__ */ import_language.LRLanguage.define({
  parser: /* @__PURE__ */ parser.configure({
    props: [
      /* @__PURE__ */ import_language.indentNodeProp.add({
        Body: (context) => {
          var _a;
          return (_a = indentBody(context, context.node)) !== null && _a !== void 0 ? _a : context.continue();
        },
        IfStatement: (cx) => /^\s*(else:|elif )/.test(cx.textAfter) ? cx.baseIndent : cx.continue(),
        TryStatement: (cx) => /^\s*(except |finally:)/.test(cx.textAfter) ? cx.baseIndent : cx.continue(),
        "TupleExpression ComprehensionExpression ParamList ArgList ParenthesizedExpression": /* @__PURE__ */ (0, import_language.delimitedIndent)({ closing: ")" }),
        "DictionaryExpression DictionaryComprehensionExpression SetExpression SetComprehensionExpression": /* @__PURE__ */ (0, import_language.delimitedIndent)({ closing: "}" }),
        "ArrayExpression ArrayComprehensionExpression": /* @__PURE__ */ (0, import_language.delimitedIndent)({ closing: "]" }),
        Script: (context) => {
          if (context.pos + /\s*/.exec(context.textAfter)[0].length >= context.node.to) {
            let endBody = null;
            for (let cur = context.node, to = cur.to; ; ) {
              cur = cur.lastChild;
              if (!cur || cur.to != to)
                break;
              if (cur.type.name == "Body")
                endBody = cur;
            }
            if (endBody) {
              let bodyIndent = indentBody(context, endBody);
              if (bodyIndent != null)
                return bodyIndent;
            }
          }
          return context.continue();
        }
      }),
      /* @__PURE__ */ import_language.foldNodeProp.add({
        "ArrayExpression DictionaryExpression SetExpression TupleExpression": import_language.foldInside,
        Body: (node, state) => ({ from: node.from + 1, to: node.to - (node.to == state.doc.length ? 0 : 1) })
      })
    ]
  }),
  languageData: {
    closeBrackets: { brackets: ["(", "[", "{", "'", '"', "'''", '"""'] },
    commentTokens: { line: "#" },
    indentOnInput: /^\s*([\}\]\)]|else:|elif |except |finally:)$/
  }
});
function python() {
  return new import_language.LanguageSupport(pythonLanguage);
}

// src/settings.ts
var config2 = {
  name: "obsidian",
  dark: false,
  string: "var(--text-accent)",
  constant: "var(--text-accent-hover)",
  comment: "var(--text-faint)",
  invalid: "var(--text-error)"
};
var obsidianHighlightStyle = import_language2.HighlightStyle.define([
  { tag: [tags.processingInstruction, tags.string, tags.inserted, tags.special(tags.string)], color: config2.string },
  { tag: [tags.color, tags.constant(tags.name), tags.standard(tags.name)], color: config2.constant },
  { tag: tags.comment, color: config2.comment },
  { tag: tags.invalid, color: config2.invalid }
]);
var DEFAULT_SETTINGS = {
  debug: false,
  convertRules: DEFAULT_RULES,
  zoneIndicatorOn: true,
  autoFormatOn: true
};
var SettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  hide() {
    var _a;
    (_a = this.ruleEditor) == null ? void 0 : _a.destroy();
  }
  display() {
    const { containerEl, plugin } = this;
    console.log("display settings");
    containerEl.empty();
    new import_obsidian.Setting(containerEl).setName("Auto Format").setDesc("Enable auto adding spaces etc.").addToggle((comp) => comp.setValue(plugin.settings.autoFormatOn).onChange((value) => __async(this, null, function* () {
      plugin.settings.autoFormatOn = value;
      yield plugin.saveSettings();
      plugin.configureActiveExtsFromSettings();
      plugin.app.workspace.updateOptions();
    })));
    new import_obsidian.Setting(containerEl).setName("Zone Indicator").setDesc("Enable showing zone indicator's start point as '\u2B50\uFE0F'").addToggle((comp) => comp.setValue(plugin.settings.zoneIndicatorOn).onChange((value) => __async(this, null, function* () {
      plugin.settings.zoneIndicatorOn = value;
      yield plugin.saveSettings();
      plugin.configureActiveExtsFromSettings();
      plugin.app.workspace.updateOptions();
    })));
    this.ruleEditor = createRuleEditorInContainer(containerEl, plugin);
  }
};
function createRuleEditorInContainer(container, plugin) {
  const convertRulesSetting = new import_obsidian.Setting(container).setName("Rules").setDesc('Enter converting & selection rules here. Each line is one rule and rules that come first                       have higher priority. Lines starting with "#" will be treated as comments and ignored.').setClass("rules-text-area");
  const customCSSWrapper = convertRulesSetting.controlEl.createDiv("rules-editor-wrapper");
  const rulesFooter = convertRulesSetting.controlEl.createDiv("rules-footer");
  const validity = rulesFooter.createDiv("rules-editor-validity");
  const validityIndicator = new import_obsidian.ExtraButtonComponent(validity);
  validityIndicator.setIcon("checkmark").extraSettingsEl.addClass("rules-editor-validity-indicator");
  const validityText = validity.createDiv("rules-editor-validity-text");
  validityText.addClass("setting-item-description");
  validityText.addClass("rules-editor-validity-txt");
  function updateValidityIndicator(success, err) {
    validityIndicator.setIcon(success ? "checkmark" : "cross");
    validityIndicator.extraSettingsEl.removeClass(success ? "invalid" : "valid");
    validityIndicator.extraSettingsEl.addClass(success ? "valid" : "invalid");
    validityText.setText("");
    validityText.setText(success ? "Saved" : err);
  }
  const extensions = [
    (0, import_view2.lineNumbers)(),
    import_view2.EditorView.lineWrapping,
    python(),
    (0, import_language2.syntaxHighlighting)(obsidianHighlightStyle),
    import_view2.EditorView.updateListener.of((v) => __async(this, null, function* () {
      if (v.docChanged) {
        const value = v.state.doc.toString();
        yield feedRules(value);
      }
    }))
  ];
  const feedRules = (newRule) => __async(this, null, function* () {
    plugin.configureRules(newRule);
    if (plugin.rulesErr != "") {
      updateValidityIndicator(false, plugin.rulesErr);
    } else {
      updateValidityIndicator(true, "");
      plugin.settings.convertRules = newRule;
      yield plugin.saveSettings();
    }
  });
  const convertRulesEditor = new import_view2.EditorView({
    state: import_state.EditorState.create({ doc: plugin.settings.convertRules, extensions })
  });
  customCSSWrapper.appendChild(convertRulesEditor.dom);
  const buttonsDiv = rulesFooter.createDiv("rules-editor-buttons");
  const reset = new import_obsidian.ButtonComponent(buttonsDiv);
  reset.setIcon("switch").setTooltip("Reset to default rules").onClick(() => __async(this, null, function* () {
    convertRulesEditor.setState(import_state.EditorState.create({ doc: DEFAULT_RULES, extensions }));
    yield feedRules(DEFAULT_RULES);
  }));
  return convertRulesEditor;
}

// src/main.ts
var ProgramTxn = import_state2.Annotation.define();
var deubgExt = import_state2.StateField.define({
  create: (_state) => {
    return 0;
  },
  update: (value, tr) => {
    if (tr.docChanged) {
      tr.changes.iterChanges((a, b, c, d, insert) => {
        console.log(a, b, c, d, insert.sliceString(0));
      });
    }
    return value;
  }
});
var TypingTransformer = class extends import_obsidian2.Plugin {
  constructor() {
    super(...arguments);
    this.configureRules = (ruleString) => {
      this.rules = new Rules(ruleString);
      if (this.rules.errors.length > 0) {
        this.rulesErr = this.rules.errors.join("\n");
      } else {
        this.rulesErr = "";
      }
    };
    this.configureActiveExtsFromSettings = () => {
      const activeIds = [1 /* Conversion */, 0 /* SideInsert */];
      const { debug, zoneIndicatorOn, autoFormatOn } = this.settings;
      debug ? activeIds.push(4 /* Debug */) : null;
      zoneIndicatorOn ? activeIds.push(2 /* ZoneIndicator */) : null;
      autoFormatOn ? activeIds.push(3 /* AutoFormat */) : null;
      this.activeExts.forEach((_ext, idx) => this.activeExts[idx] = []);
      activeIds.forEach((extid) => this.activeExts[extid] = this.availablExts[extid]);
    };
    this.spotLibertyZone = ({ view, docChanged }) => {
      if (!docChanged) {
        return;
      }
      const state = view.state;
      const mainSel = state.selection.asSingle().main;
      if (mainSel.anchor != mainSel.head) {
        return;
      }
      const line = state.doc.lineAt(mainSel.anchor);
      const from = line.from;
      const to = mainSel.anchor;
      if (from == to) {
        return;
      }
      for (const pos of this.specialSections) {
        if (pos.start.line <= line.number - 1 && line.number - 1 <= pos.end.line) {
          return;
        }
      }
      const blockRanges = getBlockRanges(line.text, to - from);
      const isInBlock = (offset) => {
        for (let i = blockRanges.length - 2; i > -1; i -= 2) {
          if (blockRanges[i] < offset && offset <= blockRanges[i + 1])
            return true;
        }
        return false;
      };
      if (isInBlock(to - from)) {
        return;
      }
      const txt = state.doc.sliceString(from, to);
      for (let i = txt.length - 2; i > 0; i--) {
        const ch = txt[i];
        if (ch != " " && PUNCTS.has(ch) && !isInBlock(i)) {
          return { from: from + i, to };
        }
      }
      return { from, to };
    };
    this.addLiberty = (update) => {
      const range = this.spotLibertyZone(update);
      if (range === void 0 || !update.selectionSet) {
        return;
      }
      const from = range.from, to = range.to;
      const toUpdate = update.view.state.doc.sliceString(from, to);
      if (PUNCTS.has(toUpdate.charAt(toUpdate.length - 1))) {
        const trimmed = toUpdate.trim();
        if (trimmed === "") {
          return;
        }
        const lspace = toUpdate.length - toUpdate.trimStart().length;
        const rspace = toUpdate.length - toUpdate.trimEnd().length;
        log("toUpdate: %s, lspace: %d, rspace: %d", toUpdate, lspace, rspace);
        log("trigger char: %s", toUpdate.charAt(toUpdate.length - 1));
        update.view.dispatch({ changes: { from: from + lspace, to: to - rspace, insert: formatLine(trimmed) }, annotations: ProgramTxn.of(true) });
      }
    };
    this.convertFilter = (tr) => {
      if (!tr.docChanged || tr.annotation(ProgramTxn)) {
        return tr;
      }
      let shouldHijack = true;
      const changes = [];
      tr.changes.iterChanges((fromA, toA, fromB, toB, inserted) => {
        const { trigSet, lmax, rmax } = this.rules;
        const char = inserted.sliceString(0);
        if (!shouldHijack || fromA != toA || toB != fromB + 1 || !trigSet.has(char)) {
          shouldHijack = false;
          return;
        }
        let leftIdx = fromB - lmax;
        let insertPosFromLineHead = lmax;
        if (leftIdx < 0) {
          insertPosFromLineHead = lmax + leftIdx;
          leftIdx = 0;
        }
        const input = tr.startState.doc.sliceString(leftIdx, fromB + rmax);
        const rule = this.rules.match(input, char, insertPosFromLineHead);
        if (rule != null) {
          const change = rule.mapToChanges(fromB);
          change.annotations = ProgramTxn.of(true);
          changes.push(change);
        } else {
          shouldHijack = false;
        }
      });
      if (shouldHijack) {
        tr = tr.startState.update(...changes);
      }
      return tr;
    };
    this.sidesInsertFilter = (tr) => {
      if (!tr.docChanged || tr.annotation(ProgramTxn)) {
        return tr;
      }
      let shouldHijack = true;
      const changes = [];
      tr.changes.iterChanges((fromA, toA, fromB, toB, inserted) => {
        const char = inserted.sliceString(0);
        if (!shouldHijack || fromA == toA || toB != fromB + 1 || !this.rules.sideInsertMap.has(char)) {
          shouldHijack = false;
          return;
        }
        const insert = this.rules.sideInsertMap.get(char);
        changes.push({ changes: { from: fromA, to: fromA, insert: insert.l }, annotations: ProgramTxn.of(true) });
        changes.push({ changes: { from: toA, to: toA, insert: insert.r }, annotations: ProgramTxn.of(true) });
      });
      if (shouldHijack) {
        tr = tr.startState.update(...changes);
      }
      return tr;
    };
  }
  onload() {
    return __async(this, null, function* () {
      console.log("loading typing transformer plugin");
      yield this.loadSettings();
      initLog(this.settings);
      yield charliberty_default(charliberty_bg_default);
      this.specialSections = [];
      this.activeExts = [];
      this.availablExts = [
        import_state2.EditorState.transactionFilter.of(this.sidesInsertFilter),
        import_state2.EditorState.transactionFilter.of(this.convertFilter),
        libertyZone(this.spotLibertyZone),
        import_view3.EditorView.updateListener.of(this.addLiberty),
        deubgExt,
        import_view3.keymap.of([
          {
            key: "a-b",
            run: (_view) => {
              log("alt-b pressed");
              return true;
            }
          }
        ])
      ];
      this.availablExts.forEach((_, idx) => this.activeExts[idx] = []);
      this.configureRules(this.settings.convertRules);
      this.configureActiveExtsFromSettings();
      this.registerEditorExtension(this.activeExts);
      this.registerEvent(this.app.metadataCache.on("changed", (_f, _d, meta2) => {
        var _a;
        this.specialSections.length = 0;
        (_a = meta2.sections) == null ? void 0 : _a.forEach((sec) => {
          if (sec.type == "code" || sec.type == "match") {
            this.specialSections.push(sec.position);
          }
        });
      }));
      this.addSettingTab(new SettingTab(this.app, this));
    });
  }
  onunload() {
    console.log("unloading typing transformer plugin");
  }
  loadSettings() {
    return __async(this, null, function* () {
      this.settings = Object.assign({}, DEFAULT_SETTINGS, yield this.loadData());
    });
  }
  saveSettings() {
    return __async(this, null, function* () {
      yield this.saveData(this.settings);
    });
  }
};
