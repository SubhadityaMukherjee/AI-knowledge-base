<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.53">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Effects of Contextual Cues on Inferring and Remembering Meanings of New Word – Subhaditya’s KB</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-sidebar floating nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Subhaditya’s KB</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://twitter.com"> <i class="bi bi-twitter" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item">Effects of Contextual Cues on Inferring and Remembering Meanings of New Word</li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
    </div>
  </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Effects of Contextual Cues on Inferring and Remembering Meanings of New Word</h1>
                                <div class="quarto-categories">
                <div class="quarto-category">usermodel</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<section id="effects-of-contextual-cues-on-inferring-and-remembering-meanings-of-new-word" class="level1">
<h1>Effects of Contextual Cues on Inferring and Remembering Meanings of New Word</h1>
<ul>
<li>xiaolongli</li>
<li>Li, X. (1988). Effects of contextual cues on inferring and remembering meanings of new words. Applied linguistics, 9(4), 402-413.</li>
</ul>
<pre class="toc"><code></code></pre>
<section id="abstract" class="level2">
<h2 class="anchored" data-anchor-id="abstract">Abstract</h2>
<ul>
<li>This study tested four directional hypotheses: Compared with those receiving cue- inadequate sentences, subjects receiving cue-adequate sentences will (1) report greater ease in word inference, and (2) score higher in inferring and remembering the contextual meanings of unfamiliar words. (3) Contextual cues being equally adequate, subjects reading, in contrast to listening to, the sentences will better infer and remember the contextual meanings ofunfamiliar words. (4) The higher the scores of word inference, the better the retention of the contextual meanings of the target word</li>
<li>An approach combining schema theory and the generative model of comprehension was usedfor the rationale of this study and the discussion of its findings.</li>
</ul>
</section>
<section id="literature-review" class="level2">
<h2 class="anchored" data-anchor-id="literature-review">LITERATURE REVIEW</h2>
<ul>
<li>Inferring, or ‘inferencing’, the meanings of unfamiliar words in context can be seen as ‘a process of identifying and acquiring’ new vocabulary by utilizing ‘attributes and contexts that are familiar’</li>
<li>In language learning, inferring word meanings while reading or listening is a process of vocabulary acquisition which has an important influence upon comprehension either in a first language (Kruse 1979) or in a second language (Yorio 1971).</li>
<li>Contextual cues can affect the process and outcome of word inference.</li>
<li>Carton (1971) hypothesized that in the process of identifying and acquiring unfamiliar words in context, greater certainty results from guesses based on many cues than on few.</li>
<li>However, for contextual cues to be of real help for word inference, they must (1) be perceptually and conceptually familiar to the text-receiver, and (2) contain the information available for the text-receiver to find the relevant schemata in order to (a) account for the oncoming input in the text, and (b) identify unfamiliar stimuli in context.</li>
<li>Memories are, in a sense, natural effects of the comprehension process (Rumelhart and Ortony 1977) which, by nature, is schematic (Bartlett 1932</li>
<li>memory performance is enhanced to the extent that the encoding context forms an integrated unit with the to-be-remembered word</li>
</ul>
</section>
<section id="this-study-purpose-and-hypotheses" class="level2">
<h2 class="anchored" data-anchor-id="this-study-purpose-and-hypotheses">THIS STUDY: PURPOSE AND HYPOTHESES</h2>
<ul>
<li>The present study was conducted among second language learners</li>
<li>It not only focused on the effects of cue adequacy on inferring and remembering the meanings of new words in discrete, semantically disconnected sentences, but also aimed at an empirical exploration concerning the relationship between word inference and retention.</li>
<li>this study compared the effects of cue adequacy in both reading and listening contexts</li>
<li>cue-adequate sentences were compared with their cue- inadequate counterparts for testing four directional hypotheses. These were: Compared with those receiving cue-inadequate sentences, subjects receiving cue-adequate sentences will (1) report greater ease in inferring the meanings of new words, and (2) score higher in inferring and remembering the meanings of new words. (3) Contextual cues being equally adequate, subjects reading, in contrast to listening to, the sentences will better infer and remember the meanings of unfamiliar words. (4) The higher the scores of word inference, the better the retention of the meanings of the target words.</li>
<li>a sentence with certain input information that contains clues sufficient for inferring the contextual meaning of a target word was defined as a cue-adequate sentence, while a sentence without such input information was defined as a cue-inadequate one</li>
<li>For example, the sentence John took out a collapsible bicycle and rode to school was treated as a cue- inadequate sentence, for, in this sentence, there was no input information signaling any clue to the contextual meaning of the target word collapsible</li>
<li>However, the sentence John took out a collapsible bicycle, unfolded it, and rode to school was treated as a cue-adequate one, for the word unfolded provided the clue to the approximate meaning of the target word.</li>
</ul>
</section>
<section id="method" class="level2">
<h2 class="anchored" data-anchor-id="method">METHOD</h2>
<section id="participant" class="level3">
<h3 class="anchored" data-anchor-id="participant">Participant</h3>
<ul>
<li>Forty-eight advanced trainees from an EAP (English for Academic Purposes) center in China were involved in this study.</li>
<li>Their average age was 35 (SD = 7), ranging from 22 to 48</li>
<li>They were randomly assigned into four treatment groups, namely</li>
<li>LC— (i.e.&nbsp;listening group with inadequate cues); RC— (i.e.&nbsp;reading group with inadequate cues); LC + (i.e.&nbsp;listening group with adequate cues), and RC+ (i.e.&nbsp;reading group with adequate cues). Of the four groups, two (i.e.&nbsp;LC— and RC—) received cue-inadequate sentences, and the others (i.e.&nbsp;LC+ and RC+), cue- adequate sentences. In each pair of groups that received the same sentences, one group (i.e.&nbsp;LC— and LC+) took the listening test, and the other (i.e.&nbsp;RC— and RC+), the reading test</li>
<li>There were two independent variables. The first one, text, had two levels- sentences with adequate cues versus inadequate cues. The second one, language skills, also had two levels—reading versus listening dependent</li>
<li>These were group means in terms of: (1) measures of word inference (i.e.&nbsp;inferring the meanings of unfamiliar words); (2) ratings of degrees of difficulty of word inference, and (3) measures of word retention (i.e.&nbsp;[recall] of the inferred meanings of the target words).</li>
</ul>
</section>
<section id="task" class="level3">
<h3 class="anchored" data-anchor-id="task">Task</h3>
<ul>
<li>Sixty discrete, semantically disconnected sentences were constructed for the experiment.</li>
<li>They formed two sets of counterparts. Each set was composed of 30 sentences.</li>
<li>One set consisted of cue-adequate sentences, and the other of cue-inadequate sentences</li>
<li>A target word was defined as a perceptually, not conceptually, unfamiliar term.</li>
<li>Since the target words were only perceptually unfamiliar, it would not be a prerequisite for the subjects to acquire any new concept to perform the task for this experiment.</li>
<li>By the same token, the topic of all the test items was based on common knowledge; thus, there was no need to turn to any biased or specialized frame of reference for inferring word meanings in this experiment</li>
<li>Furthermore, no meaning of any target word for this study could be deduced simply by applying morphological knowledge in terms of stems, affixes, or other devices of word formation.</li>
<li>In the pretest, the subjects were asked to write down (either in English or Chinese) the common meanings of the target words they knew.</li>
<li>Three more tasks were performed after the pretest. The first one, word inference, was to infer the contextual meanings of the target words based on the input information in the sentences in which the target words were embedded.</li>
<li>Both tapes, one containing sentences with adequate, and the other sentences with inadequate cues, were produced by a native English speaker at a speed of about 90 words per minute.</li>
<li>The subjects listened to the sentences one by one, with each sentence repeated three times.</li>
<li>Sentences were shown one by one on the screens by using a mask, and presented at the same rate as the corresponding items on the tapes for the listening groups.</li>
<li>The tests were presented in an open-ended, not in a multiple-choice, form</li>
<li>After reading or listening to each sentence, the subjects were asked to state (either in English or Chinese) their guesses of the contextual meaning of the target word in the sentence</li>
<li>The second task after the pretest was to rate the degrees of difficulty in terms of word inferences</li>
<li>The last task, word retention, was a cued [recall] of the target words’ inferred contextual meanings.</li>
<li>Each target word was cued by another word from the same sentence that had been processed for inferring the contextual meaning of the target word.</li>
<li>The target words were listed in exactly the same order as they appeared in the tests for word inference.</li>
</ul>
</section>
</section>
<section id="data-analyses" class="level2">
<h2 class="anchored" data-anchor-id="data-analyses">DATA ANALYSES</h2>
<ul>
<li>Hypothesis 1 was tested by a Chi-square, Hypothesis 2 by two separate one-way ANOVAs, Hypothesis 3 by two separate Duncan’s Multiple Range Tests, and Hypothesis 4 by a Correlation Test</li>
<li>Since the Chi-square is a test especially designed for nominal data, it was decided beforehand that the nine-point scale should be dichotomized: ratings less than 5 were defined as ‘difficult’ (to infer the contextual meanings of the target words from the discrete sentences), while ratings equal to or greater than 5 were defined as ‘easy’.</li>
<li>Cronbach’s Alpha was used for computing the test reliability. Reliability coefficients for the four tests of word inference were 0.60 for LC—, 0.54 for RC-, 0.68 for LC+, and 0.64 for RC+, which were rather low.</li>
<li>However, they can be considered as being acceptable for this study, for both the sample size (12 per cell) and the number of test items (30 for each test) were very small.</li>
</ul>
</section>
<section id="results" class="level2">
<h2 class="anchored" data-anchor-id="results">RESULTS</h2>
<ul>
<li>Data analyses indicated that all the four hypotheses were confirmed with statistical significance.</li>
</ul>
<section id="hypothesis-1" class="level3">
<h3 class="anchored" data-anchor-id="hypothesis-1">Hypothesis 1</h3>
<ul>
<li>no significant difference between the four groups in rating degrees of difficulty of word inference</li>
<li>result of the Chi-square Test presented null hypothesis could be rejected</li>
</ul>
</section>
<section id="hypothesis-2" class="level3">
<h3 class="anchored" data-anchor-id="hypothesis-2">Hypothesis 2</h3>
<ul>
<li>subjects in the four groups performed differently on both tasks of word inference and word retention</li>
<li>showed that RC+ scored significantly higher than LC+, and that both RC+ and LC+</li>
<li>scored significantly higher than RC— and LC—</li>
<li>However, there was no significant difference between RC— and LC—</li>
<li>showed both RC+ and LC+ scored significantly higher than RC— and LC—, and that R C + scored significantly higher than LC+. However, there was no significant difference between RC— and LC-.</li>
</ul>
</section>
<section id="hypothesis-3" class="level3">
<h3 class="anchored" data-anchor-id="hypothesis-3">Hypothesis 3</h3>
<ul>
<li>both in word inference and retention, R C + scored significantly higher than LC+; however, in either word inference or retention, there was no significant difference between RC— and LC—</li>
</ul>
</section>
<section id="hypothesis-4" class="level3">
<h3 class="anchored" data-anchor-id="hypothesis-4">Hypothesis 4</h3>
<ul>
<li>there was a positive correlation of statistical significance between word inference and word retention</li>
</ul>
</section>
</section>
<section id="discussion-and-conclusion" class="level2">
<h2 class="anchored" data-anchor-id="discussion-and-conclusion">DISCUSSION AND CONCLUSION</h2>
<ul>
<li>ubjects receiving cue- adequate sentences, in contrast to cue-inadequate sentences, not only reported greater ease in word inference, but also scored significantly higher in inferring and remembering the meanings of unfamiliar words in context</li>
<li>existed a positive correlation between word inference and word retention. That is, the higher the group means in inferring the contextual meanings of unfamiliar words, the better the performance in remembering the meanings of those words</li>
<li>contextual cues being equally adequate, subjects reading the sentences scored significantly higher in both inferring and remembering the contextual meanings of unfamiliar words than those listening to the sentences.</li>
<li>This finding further sustained Carton’s (1971) hypothesis that texts with adequate contextual cues minimize errors in the process of identifying and acquiring new words in a natural context</li>
<li>The presence of contextual cues means ‘bridging information’ (Garrod and Sanford 1981), grammatical and/or semantic, conceptual as well as perceptual.</li>
<li>Without adequate bridging information, it would seem next to impossible to infer and [recall] the contextual meaning of any unfamiliar word.</li>
<li>This explains why the LC— and RC— groups scored so low on both word inference and word retention.</li>
<li>the target words associated with more powerful retrieval cues were more recallable than those associated with less powerful retrieval cues</li>
<li>Probably, more powerfully associated retrieval cues better triggered the schematic memory, which created a ‘short cut’ that linked the process needed for recalling the contextual meaning of the target word and the initial process involved in inferring the contextual meaning of that target word.</li>
<li>contextual cues being equally adequate (not inadequate), subjects in the reading group scored significantly higher in both word inference and word retention than subjects in the listening group.</li>
<li>not clear why this was so</li>
<li>That is, the subjects might be more competent in reading than in listening contextual cues presented visually were more accessible</li>
</ul>
</section>
<section id="implications" class="level2">
<h2 class="anchored" data-anchor-id="implications">Implications</h2>
<ul>
<li>irst, since adequate cues in context can relieve learners of English as a second language from the anxiety of unfamiliar words, it might follow that reasonably sufficient contextual cues should be provided in texts for second language learners, so that enough information can be created for them to play the ‘psychoUnguistic guessing game’ (Goodman 1983)</li>
<li>contextual cues can enhance inferring and remembering the meanings of unfamiliar words in context,</li>
<li>since contextual cues being equally adequate, subjects can, within the same amount of time, better acquire vocabulary through visual patterns of learning than through oral patterns, it might follow that learners whose learning styles are congruent or similar to the subjects in this study, may well enlarge their vocabulary for reading in a more efficient way through visual ways of learning</li>
</ul>
</section>
<section id="pictures" class="level2">
<h2 class="anchored" data-anchor-id="pictures">Pictures</h2>
<ul>
<li><div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/Pasted%20image%2020221014165039.png" class="img-fluid figure-img"></p>
<figcaption>Pasted%20image%2020221014165039</figcaption>
</figure>
</div></li>
</ul>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>