/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};

// node_modules/classnames/index.js
var require_classnames = __commonJS({
  "node_modules/classnames/index.js"(exports, module2) {
    (function() {
      "use strict";
      var hasOwn2 = {}.hasOwnProperty;
      function classNames2() {
        var classes = "";
        for (var i = 0; i < arguments.length; i++) {
          var arg = arguments[i];
          if (arg) {
            classes = appendClass(classes, parseValue(arg));
          }
        }
        return classes;
      }
      function parseValue(arg) {
        if (typeof arg === "string" || typeof arg === "number") {
          return arg;
        }
        if (typeof arg !== "object") {
          return "";
        }
        if (Array.isArray(arg)) {
          return classNames2.apply(null, arg);
        }
        if (arg.toString !== Object.prototype.toString && !arg.toString.toString().includes("[native code]")) {
          return arg.toString();
        }
        var classes = "";
        for (var key in arg) {
          if (hasOwn2.call(arg, key) && arg[key]) {
            classes = appendClass(classes, key);
          }
        }
        return classes;
      }
      function appendClass(value, newClass) {
        if (!newClass) {
          return value;
        }
        if (value) {
          return value + " " + newClass;
        }
        return value + newClass;
      }
      if (typeof module2 !== "undefined" && module2.exports) {
        classNames2.default = classNames2;
        module2.exports = classNames2;
      } else if (typeof define === "function" && typeof define.amd === "object" && define.amd) {
        define("classnames", [], function() {
          return classNames2;
        });
      } else {
        window.classNames = classNames2;
      }
    })();
  }
});

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => Lineage
});
module.exports = __toCommonJS(main_exports);
var import_obsidian38 = require("obsidian");

// src/view/view.ts
var import_obsidian26 = require("obsidian");

// node_modules/svelte/src/runtime/internal/utils.js
function noop() {
}
function assign(tar, src) {
  for (const k in src)
    tar[k] = src[k];
  return (
    /** @type {T & S} */
    tar
  );
}
function run(fn) {
  return fn();
}
function blank_object() {
  return /* @__PURE__ */ Object.create(null);
}
function run_all(fns) {
  fns.forEach(run);
}
function is_function(thing) {
  return typeof thing === "function";
}
function safe_not_equal(a, b) {
  return a != a ? b == b : a !== b || a && typeof a === "object" || typeof a === "function";
}
function is_empty(obj) {
  return Object.keys(obj).length === 0;
}
function subscribe(store, ...callbacks) {
  if (store == null) {
    for (const callback of callbacks) {
      callback(void 0);
    }
    return noop;
  }
  const unsub = store.subscribe(...callbacks);
  return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
}
function get_store_value(store) {
  let value;
  subscribe(store, (_) => value = _)();
  return value;
}
function component_subscribe(component, store, callback) {
  component.$$.on_destroy.push(subscribe(store, callback));
}
function create_slot(definition, ctx, $$scope, fn) {
  if (definition) {
    const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);
    return definition[0](slot_ctx);
  }
}
function get_slot_context(definition, ctx, $$scope, fn) {
  return definition[1] && fn ? assign($$scope.ctx.slice(), definition[1](fn(ctx))) : $$scope.ctx;
}
function get_slot_changes(definition, $$scope, dirty, fn) {
  if (definition[2] && fn) {
    const lets = definition[2](fn(dirty));
    if ($$scope.dirty === void 0) {
      return lets;
    }
    if (typeof lets === "object") {
      const merged = [];
      const len = Math.max($$scope.dirty.length, lets.length);
      for (let i = 0; i < len; i += 1) {
        merged[i] = $$scope.dirty[i] | lets[i];
      }
      return merged;
    }
    return $$scope.dirty | lets;
  }
  return $$scope.dirty;
}
function update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {
  if (slot_changes) {
    const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);
    slot.p(slot_context, slot_changes);
  }
}
function get_all_dirty_from_scope($$scope) {
  if ($$scope.ctx.length > 32) {
    const dirty = [];
    const length = $$scope.ctx.length / 32;
    for (let i = 0; i < length; i++) {
      dirty[i] = -1;
    }
    return dirty;
  }
  return -1;
}
function exclude_internal_props(props) {
  const result = {};
  for (const k in props)
    if (k[0] !== "$")
      result[k] = props[k];
  return result;
}
function compute_rest_props(props, keys) {
  const rest = {};
  keys = new Set(keys);
  for (const k in props)
    if (!keys.has(k) && k[0] !== "$")
      rest[k] = props[k];
  return rest;
}
function null_to_empty(value) {
  return value == null ? "" : value;
}
function action_destroyer(action_result) {
  return action_result && is_function(action_result.destroy) ? action_result.destroy : noop;
}

// node_modules/svelte/src/runtime/internal/globals.js
var globals = typeof window !== "undefined" ? window : typeof globalThis !== "undefined" ? globalThis : (
  // @ts-ignore Node typings have this
  global
);

// node_modules/svelte/src/runtime/internal/ResizeObserverSingleton.js
var ResizeObserverSingleton = class _ResizeObserverSingleton {
  /** @param {ResizeObserverOptions} options */
  constructor(options) {
    /**
     * @private
     * @readonly
     * @type {WeakMap<Element, import('./private.js').Listener>}
     */
    __publicField(this, "_listeners", "WeakMap" in globals ? /* @__PURE__ */ new WeakMap() : void 0);
    /**
     * @private
     * @type {ResizeObserver}
     */
    __publicField(this, "_observer");
    /** @type {ResizeObserverOptions} */
    __publicField(this, "options");
    this.options = options;
  }
  /**
   * @param {Element} element
   * @param {import('./private.js').Listener} listener
   * @returns {() => void}
   */
  observe(element2, listener) {
    this._listeners.set(element2, listener);
    this._getObserver().observe(element2, this.options);
    return () => {
      this._listeners.delete(element2);
      this._observer.unobserve(element2);
    };
  }
  /**
   * @private
   */
  _getObserver() {
    return this._observer ?? (this._observer = new ResizeObserver((entries) => {
      for (const entry of entries) {
        _ResizeObserverSingleton.entries.set(entry.target, entry);
        this._listeners.get(entry.target)?.(entry);
      }
    }));
  }
};
ResizeObserverSingleton.entries = "WeakMap" in globals ? /* @__PURE__ */ new WeakMap() : void 0;

// node_modules/svelte/src/runtime/internal/dom.js
var is_hydrating = false;
function start_hydrating() {
  is_hydrating = true;
}
function end_hydrating() {
  is_hydrating = false;
}
function append(target, node) {
  target.appendChild(node);
}
function append_styles(target, style_sheet_id, styles) {
  const append_styles_to = get_root_for_style(target);
  if (!append_styles_to.getElementById(style_sheet_id)) {
    const style = element("style");
    style.id = style_sheet_id;
    style.textContent = styles;
    append_stylesheet(append_styles_to, style);
  }
}
function get_root_for_style(node) {
  if (!node)
    return document;
  const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;
  if (root && /** @type {ShadowRoot} */
  root.host) {
    return (
      /** @type {ShadowRoot} */
      root
    );
  }
  return node.ownerDocument;
}
function append_stylesheet(node, style) {
  append(
    /** @type {Document} */
    node.head || node,
    style
  );
  return style.sheet;
}
function insert(target, node, anchor) {
  target.insertBefore(node, anchor || null);
}
function detach(node) {
  if (node.parentNode) {
    node.parentNode.removeChild(node);
  }
}
function destroy_each(iterations, detaching) {
  for (let i = 0; i < iterations.length; i += 1) {
    if (iterations[i])
      iterations[i].d(detaching);
  }
}
function element(name) {
  return document.createElement(name);
}
function svg_element(name) {
  return document.createElementNS("http://www.w3.org/2000/svg", name);
}
function text(data) {
  return document.createTextNode(data);
}
function space() {
  return text(" ");
}
function empty() {
  return text("");
}
function listen(node, event, handler, options) {
  node.addEventListener(event, handler, options);
  return () => node.removeEventListener(event, handler, options);
}
function attr(node, attribute, value) {
  if (value == null)
    node.removeAttribute(attribute);
  else if (node.getAttribute(attribute) !== value)
    node.setAttribute(attribute, value);
}
function set_svg_attributes(node, attributes) {
  for (const key in attributes) {
    attr(node, key, attributes[key]);
  }
}
function children(element2) {
  return Array.from(element2.childNodes);
}
function set_data(text2, data) {
  data = "" + data;
  if (text2.data === data)
    return;
  text2.data = /** @type {string} */
  data;
}
function set_input_value(input, value) {
  input.value = value == null ? "" : value;
}
function set_style(node, key, value, important) {
  if (value == null) {
    node.style.removeProperty(key);
  } else {
    node.style.setProperty(key, value, important ? "important" : "");
  }
}
function toggle_class(element2, name, toggle) {
  element2.classList.toggle(name, !!toggle);
}
function get_custom_elements_slots(element2) {
  const result = {};
  element2.childNodes.forEach(
    /** @param {Element} node */
    (node) => {
      result[node.slot || "default"] = true;
    }
  );
  return result;
}
function construct_svelte_component(component, props) {
  return new component(props);
}

// node_modules/svelte/src/runtime/internal/lifecycle.js
var current_component;
function set_current_component(component) {
  current_component = component;
}
function get_current_component() {
  if (!current_component)
    throw new Error("Function called outside component initialization");
  return current_component;
}
function onMount(fn) {
  get_current_component().$$.on_mount.push(fn);
}
function setContext(key, context) {
  get_current_component().$$.context.set(key, context);
  return context;
}
function getContext(key) {
  return get_current_component().$$.context.get(key);
}
function bubble(component, event) {
  const callbacks = component.$$.callbacks[event.type];
  if (callbacks) {
    callbacks.slice().forEach((fn) => fn.call(this, event));
  }
}

// node_modules/svelte/src/runtime/internal/scheduler.js
var dirty_components = [];
var binding_callbacks = [];
var render_callbacks = [];
var flush_callbacks = [];
var resolved_promise = /* @__PURE__ */ Promise.resolve();
var update_scheduled = false;
function schedule_update() {
  if (!update_scheduled) {
    update_scheduled = true;
    resolved_promise.then(flush);
  }
}
function add_render_callback(fn) {
  render_callbacks.push(fn);
}
var seen_callbacks = /* @__PURE__ */ new Set();
var flushidx = 0;
function flush() {
  if (flushidx !== 0) {
    return;
  }
  const saved_component = current_component;
  do {
    try {
      while (flushidx < dirty_components.length) {
        const component = dirty_components[flushidx];
        flushidx++;
        set_current_component(component);
        update(component.$$);
      }
    } catch (e) {
      dirty_components.length = 0;
      flushidx = 0;
      throw e;
    }
    set_current_component(null);
    dirty_components.length = 0;
    flushidx = 0;
    while (binding_callbacks.length)
      binding_callbacks.pop()();
    for (let i = 0; i < render_callbacks.length; i += 1) {
      const callback = render_callbacks[i];
      if (!seen_callbacks.has(callback)) {
        seen_callbacks.add(callback);
        callback();
      }
    }
    render_callbacks.length = 0;
  } while (dirty_components.length);
  while (flush_callbacks.length) {
    flush_callbacks.pop()();
  }
  update_scheduled = false;
  seen_callbacks.clear();
  set_current_component(saved_component);
}
function update($$) {
  if ($$.fragment !== null) {
    $$.update();
    run_all($$.before_update);
    const dirty = $$.dirty;
    $$.dirty = [-1];
    $$.fragment && $$.fragment.p($$.ctx, dirty);
    $$.after_update.forEach(add_render_callback);
  }
}
function flush_render_callbacks(fns) {
  const filtered = [];
  const targets = [];
  render_callbacks.forEach((c) => fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c));
  targets.forEach((c) => c());
  render_callbacks = filtered;
}

// node_modules/svelte/src/runtime/internal/transitions.js
var outroing = /* @__PURE__ */ new Set();
var outros;
function group_outros() {
  outros = {
    r: 0,
    c: [],
    p: outros
    // parent group
  };
}
function check_outros() {
  if (!outros.r) {
    run_all(outros.c);
  }
  outros = outros.p;
}
function transition_in(block, local) {
  if (block && block.i) {
    outroing.delete(block);
    block.i(local);
  }
}
function transition_out(block, local, detach2, callback) {
  if (block && block.o) {
    if (outroing.has(block))
      return;
    outroing.add(block);
    outros.c.push(() => {
      outroing.delete(block);
      if (callback) {
        if (detach2)
          block.d(1);
        callback();
      }
    });
    block.o(local);
  } else if (callback) {
    callback();
  }
}

// node_modules/svelte/src/runtime/internal/each.js
function ensure_array_like(array_like_or_iterator) {
  return array_like_or_iterator?.length !== void 0 ? array_like_or_iterator : Array.from(array_like_or_iterator);
}
function outro_and_destroy_block(block, lookup) {
  transition_out(block, 1, 1, () => {
    lookup.delete(block.key);
  });
}
function update_keyed_each(old_blocks, dirty, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block13, next, get_context) {
  let o = old_blocks.length;
  let n = list.length;
  let i = o;
  const old_indexes = {};
  while (i--)
    old_indexes[old_blocks[i].key] = i;
  const new_blocks = [];
  const new_lookup = /* @__PURE__ */ new Map();
  const deltas = /* @__PURE__ */ new Map();
  const updates = [];
  i = n;
  while (i--) {
    const child_ctx = get_context(ctx, list, i);
    const key = get_key(child_ctx);
    let block = lookup.get(key);
    if (!block) {
      block = create_each_block13(key, child_ctx);
      block.c();
    } else if (dynamic) {
      updates.push(() => block.p(child_ctx, dirty));
    }
    new_lookup.set(key, new_blocks[i] = block);
    if (key in old_indexes)
      deltas.set(key, Math.abs(i - old_indexes[key]));
  }
  const will_move = /* @__PURE__ */ new Set();
  const did_move = /* @__PURE__ */ new Set();
  function insert2(block) {
    transition_in(block, 1);
    block.m(node, next);
    lookup.set(block.key, block);
    next = block.first;
    n--;
  }
  while (o && n) {
    const new_block = new_blocks[n - 1];
    const old_block = old_blocks[o - 1];
    const new_key = new_block.key;
    const old_key = old_block.key;
    if (new_block === old_block) {
      next = new_block.first;
      o--;
      n--;
    } else if (!new_lookup.has(old_key)) {
      destroy(old_block, lookup);
      o--;
    } else if (!lookup.has(new_key) || will_move.has(new_key)) {
      insert2(new_block);
    } else if (did_move.has(old_key)) {
      o--;
    } else if (deltas.get(new_key) > deltas.get(old_key)) {
      did_move.add(new_key);
      insert2(new_block);
    } else {
      will_move.add(old_key);
      o--;
    }
  }
  while (o--) {
    const old_block = old_blocks[o];
    if (!new_lookup.has(old_block.key))
      destroy(old_block, lookup);
  }
  while (n)
    insert2(new_blocks[n - 1]);
  run_all(updates);
  return new_blocks;
}

// node_modules/svelte/src/runtime/internal/spread.js
function get_spread_update(levels, updates) {
  const update2 = {};
  const to_null_out = {};
  const accounted_for = { $$scope: 1 };
  let i = levels.length;
  while (i--) {
    const o = levels[i];
    const n = updates[i];
    if (n) {
      for (const key in o) {
        if (!(key in n))
          to_null_out[key] = 1;
      }
      for (const key in n) {
        if (!accounted_for[key]) {
          update2[key] = n[key];
          accounted_for[key] = 1;
        }
      }
      levels[i] = n;
    } else {
      for (const key in o) {
        accounted_for[key] = 1;
      }
    }
  }
  for (const key in to_null_out) {
    if (!(key in update2))
      update2[key] = void 0;
  }
  return update2;
}
function get_spread_object(spread_props) {
  return typeof spread_props === "object" && spread_props !== null ? spread_props : {};
}

// node_modules/svelte/src/shared/boolean_attributes.js
var _boolean_attributes = (
  /** @type {const} */
  [
    "allowfullscreen",
    "allowpaymentrequest",
    "async",
    "autofocus",
    "autoplay",
    "checked",
    "controls",
    "default",
    "defer",
    "disabled",
    "formnovalidate",
    "hidden",
    "inert",
    "ismap",
    "loop",
    "multiple",
    "muted",
    "nomodule",
    "novalidate",
    "open",
    "playsinline",
    "readonly",
    "required",
    "reversed",
    "selected"
  ]
);
var boolean_attributes = /* @__PURE__ */ new Set([..._boolean_attributes]);

// node_modules/svelte/src/runtime/internal/Component.js
function create_component(block) {
  block && block.c();
}
function mount_component(component, target, anchor) {
  const { fragment, after_update } = component.$$;
  fragment && fragment.m(target, anchor);
  add_render_callback(() => {
    const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);
    if (component.$$.on_destroy) {
      component.$$.on_destroy.push(...new_on_destroy);
    } else {
      run_all(new_on_destroy);
    }
    component.$$.on_mount = [];
  });
  after_update.forEach(add_render_callback);
}
function destroy_component(component, detaching) {
  const $$ = component.$$;
  if ($$.fragment !== null) {
    flush_render_callbacks($$.after_update);
    run_all($$.on_destroy);
    $$.fragment && $$.fragment.d(detaching);
    $$.on_destroy = $$.fragment = null;
    $$.ctx = [];
  }
}
function make_dirty(component, i) {
  if (component.$$.dirty[0] === -1) {
    dirty_components.push(component);
    schedule_update();
    component.$$.dirty.fill(0);
  }
  component.$$.dirty[i / 31 | 0] |= 1 << i % 31;
}
function init(component, options, instance75, create_fragment77, not_equal, props, append_styles2 = null, dirty = [-1]) {
  const parent_component = current_component;
  set_current_component(component);
  const $$ = component.$$ = {
    fragment: null,
    ctx: [],
    // state
    props,
    update: noop,
    not_equal,
    bound: blank_object(),
    // lifecycle
    on_mount: [],
    on_destroy: [],
    on_disconnect: [],
    before_update: [],
    after_update: [],
    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
    // everything else
    callbacks: blank_object(),
    dirty,
    skip_bound: false,
    root: options.target || parent_component.$$.root
  };
  append_styles2 && append_styles2($$.root);
  let ready = false;
  $$.ctx = instance75 ? instance75(component, options.props || {}, (i, ret, ...rest) => {
    const value = rest.length ? rest[0] : ret;
    if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
      if (!$$.skip_bound && $$.bound[i])
        $$.bound[i](value);
      if (ready)
        make_dirty(component, i);
    }
    return ret;
  }) : [];
  $$.update();
  ready = true;
  run_all($$.before_update);
  $$.fragment = create_fragment77 ? create_fragment77($$.ctx) : false;
  if (options.target) {
    if (options.hydrate) {
      start_hydrating();
      const nodes = children(options.target);
      $$.fragment && $$.fragment.l(nodes);
      nodes.forEach(detach);
    } else {
      $$.fragment && $$.fragment.c();
    }
    if (options.intro)
      transition_in(component.$$.fragment);
    mount_component(component, options.target, options.anchor);
    end_hydrating();
    flush();
  }
  set_current_component(parent_component);
}
var SvelteElement;
if (typeof HTMLElement === "function") {
  SvelteElement = class extends HTMLElement {
    constructor($$componentCtor, $$slots, use_shadow_dom) {
      super();
      /** The Svelte component constructor */
      __publicField(this, "$$ctor");
      /** Slots */
      __publicField(this, "$$s");
      /** The Svelte component instance */
      __publicField(this, "$$c");
      /** Whether or not the custom element is connected */
      __publicField(this, "$$cn", false);
      /** Component props data */
      __publicField(this, "$$d", {});
      /** `true` if currently in the process of reflecting component props back to attributes */
      __publicField(this, "$$r", false);
      /** @type {Record<string, CustomElementPropDefinition>} Props definition (name, reflected, type etc) */
      __publicField(this, "$$p_d", {});
      /** @type {Record<string, Function[]>} Event listeners */
      __publicField(this, "$$l", {});
      /** @type {Map<Function, Function>} Event listener unsubscribe functions */
      __publicField(this, "$$l_u", /* @__PURE__ */ new Map());
      this.$$ctor = $$componentCtor;
      this.$$s = $$slots;
      if (use_shadow_dom) {
        this.attachShadow({ mode: "open" });
      }
    }
    addEventListener(type, listener, options) {
      this.$$l[type] = this.$$l[type] || [];
      this.$$l[type].push(listener);
      if (this.$$c) {
        const unsub = this.$$c.$on(type, listener);
        this.$$l_u.set(listener, unsub);
      }
      super.addEventListener(type, listener, options);
    }
    removeEventListener(type, listener, options) {
      super.removeEventListener(type, listener, options);
      if (this.$$c) {
        const unsub = this.$$l_u.get(listener);
        if (unsub) {
          unsub();
          this.$$l_u.delete(listener);
        }
      }
    }
    async connectedCallback() {
      this.$$cn = true;
      if (!this.$$c) {
        let create_slot2 = function(name) {
          return () => {
            let node;
            const obj = {
              c: function create() {
                node = element("slot");
                if (name !== "default") {
                  attr(node, "name", name);
                }
              },
              /**
               * @param {HTMLElement} target
               * @param {HTMLElement} [anchor]
               */
              m: function mount(target, anchor) {
                insert(target, node, anchor);
              },
              d: function destroy(detaching) {
                if (detaching) {
                  detach(node);
                }
              }
            };
            return obj;
          };
        };
        await Promise.resolve();
        if (!this.$$cn || this.$$c) {
          return;
        }
        const $$slots = {};
        const existing_slots = get_custom_elements_slots(this);
        for (const name of this.$$s) {
          if (name in existing_slots) {
            $$slots[name] = [create_slot2(name)];
          }
        }
        for (const attribute of this.attributes) {
          const name = this.$$g_p(attribute.name);
          if (!(name in this.$$d)) {
            this.$$d[name] = get_custom_element_value(name, attribute.value, this.$$p_d, "toProp");
          }
        }
        for (const key in this.$$p_d) {
          if (!(key in this.$$d) && this[key] !== void 0) {
            this.$$d[key] = this[key];
            delete this[key];
          }
        }
        this.$$c = new this.$$ctor({
          target: this.shadowRoot || this,
          props: {
            ...this.$$d,
            $$slots,
            $$scope: {
              ctx: []
            }
          }
        });
        const reflect_attributes = () => {
          this.$$r = true;
          for (const key in this.$$p_d) {
            this.$$d[key] = this.$$c.$$.ctx[this.$$c.$$.props[key]];
            if (this.$$p_d[key].reflect) {
              const attribute_value = get_custom_element_value(
                key,
                this.$$d[key],
                this.$$p_d,
                "toAttribute"
              );
              if (attribute_value == null) {
                this.removeAttribute(this.$$p_d[key].attribute || key);
              } else {
                this.setAttribute(this.$$p_d[key].attribute || key, attribute_value);
              }
            }
          }
          this.$$r = false;
        };
        this.$$c.$$.after_update.push(reflect_attributes);
        reflect_attributes();
        for (const type in this.$$l) {
          for (const listener of this.$$l[type]) {
            const unsub = this.$$c.$on(type, listener);
            this.$$l_u.set(listener, unsub);
          }
        }
        this.$$l = {};
      }
    }
    // We don't need this when working within Svelte code, but for compatibility of people using this outside of Svelte
    // and setting attributes through setAttribute etc, this is helpful
    attributeChangedCallback(attr2, _oldValue, newValue) {
      if (this.$$r)
        return;
      attr2 = this.$$g_p(attr2);
      this.$$d[attr2] = get_custom_element_value(attr2, newValue, this.$$p_d, "toProp");
      this.$$c?.$set({ [attr2]: this.$$d[attr2] });
    }
    disconnectedCallback() {
      this.$$cn = false;
      Promise.resolve().then(() => {
        if (!this.$$cn) {
          this.$$c.$destroy();
          this.$$c = void 0;
        }
      });
    }
    $$g_p(attribute_name) {
      return Object.keys(this.$$p_d).find(
        (key) => this.$$p_d[key].attribute === attribute_name || !this.$$p_d[key].attribute && key.toLowerCase() === attribute_name
      ) || attribute_name;
    }
  };
}
function get_custom_element_value(prop, value, props_definition, transform) {
  const type = props_definition[prop]?.type;
  value = type === "Boolean" && typeof value !== "boolean" ? value != null : value;
  if (!transform || !props_definition[prop]) {
    return value;
  } else if (transform === "toAttribute") {
    switch (type) {
      case "Object":
      case "Array":
        return value == null ? null : JSON.stringify(value);
      case "Boolean":
        return value ? "" : null;
      case "Number":
        return value == null ? null : value;
      default:
        return value;
    }
  } else {
    switch (type) {
      case "Object":
      case "Array":
        return value && JSON.parse(value);
      case "Boolean":
        return value;
      case "Number":
        return value != null ? +value : value;
      default:
        return value;
    }
  }
}
var SvelteComponent = class {
  constructor() {
    /**
     * ### PRIVATE API
     *
     * Do not use, may change at any time
     *
     * @type {any}
     */
    __publicField(this, "$$");
    /**
     * ### PRIVATE API
     *
     * Do not use, may change at any time
     *
     * @type {any}
     */
    __publicField(this, "$$set");
  }
  /** @returns {void} */
  $destroy() {
    destroy_component(this, 1);
    this.$destroy = noop;
  }
  /**
   * @template {Extract<keyof Events, string>} K
   * @param {K} type
   * @param {((e: Events[K]) => void) | null | undefined} callback
   * @returns {() => void}
   */
  $on(type, callback) {
    if (!is_function(callback)) {
      return noop;
    }
    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
    callbacks.push(callback);
    return () => {
      const index = callbacks.indexOf(callback);
      if (index !== -1)
        callbacks.splice(index, 1);
    };
  }
  /**
   * @param {Partial<Props>} props
   * @returns {void}
   */
  $set(props) {
    if (this.$$set && !is_empty(props)) {
      this.$$.skip_bound = true;
      this.$$set(props);
      this.$$.skip_bound = false;
    }
  }
};

// node_modules/svelte/src/shared/version.js
var PUBLIC_VERSION = "4";

// node_modules/svelte/src/runtime/internal/disclose-version/index.js
if (typeof window !== "undefined")
  (window.__svelte || (window.__svelte = { v: /* @__PURE__ */ new Set() })).v.add(PUBLIC_VERSION);

// src/lang/lang.ts
var lang = {
  open_in_editor: "Open in editor",
  open_in_lineage: "Open in Lineage",
  toggle_lineage_view: "Toggle view",
  export_document: "Export document",
  create_new_document: "Create new document",
  new_document: "New document",
  change_format_to_document: "File format: sections",
  change_format_to_outline: "File format: outline (experimental)",
  format_headings: "Format headings",
  extract_branch: "Extract branch to a new document",
  error_apply_snapshot_while_editing: "Cannot apply a snapshot while editing",
  error_delete_last_node: "Cannot delete this card",
  error_generic: "Something went wrong\nFurther details may be available in the developer console",
  cant_split_card_that_has_children: "Cannot split a card that has children",
  cant_split_card_identical: "The result is the same as the input",
  cant_merge_multiple_nodes: "Cannot merge multiple cards",
  error_parent_not_found: (full) => `Could not find the parent section of ${full}`,
  import_from_gingko: "Import from Gingko"
};

// src/stores/settings/reducers/change-zoom-level.ts
var zoomStep = 0.1;
var maxZoomLevel = 2;
var minZoomLevel = 0.1;
var changeZoomLevel = (state2, payload) => {
  if ("value" in payload) {
    state2.view.zoomLevel = payload.value;
  } else {
    state2.view.zoomLevel = payload.direction === "in" ? Math.min(state2.view.zoomLevel + zoomStep, maxZoomLevel) : Math.max(state2.view.zoomLevel - zoomStep, minZoomLevel);
  }
};

// node_modules/lucide-svelte/dist/defaultAttributes.js
var defaultAttributes = {
  xmlns: "http://www.w3.org/2000/svg",
  width: 24,
  height: 24,
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  "stroke-width": 2,
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
};
var defaultAttributes_default = defaultAttributes;

// node_modules/lucide-svelte/dist/Icon.svelte
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[10] = list[i][0];
  child_ctx[11] = list[i][1];
  return child_ctx;
}
function create_dynamic_element(ctx) {
  let svelte_element;
  let svelte_element_levels = [
    /*attrs*/
    ctx[11]
  ];
  let svelte_element_data = {};
  for (let i = 0; i < svelte_element_levels.length; i += 1) {
    svelte_element_data = assign(svelte_element_data, svelte_element_levels[i]);
  }
  return {
    c() {
      svelte_element = svg_element(
        /*tag*/
        ctx[10]
      );
      set_svg_attributes(svelte_element, svelte_element_data);
    },
    m(target, anchor) {
      insert(target, svelte_element, anchor);
    },
    p(ctx2, dirty) {
      set_svg_attributes(svelte_element, svelte_element_data = get_spread_update(svelte_element_levels, [dirty & /*iconNode*/
      32 && /*attrs*/
      ctx2[11]]));
    },
    d(detaching) {
      if (detaching) {
        detach(svelte_element);
      }
    }
  };
}
function create_each_block(ctx) {
  let previous_tag = (
    /*tag*/
    ctx[10]
  );
  let svelte_element_anchor;
  let svelte_element = (
    /*tag*/
    ctx[10] && create_dynamic_element(ctx)
  );
  return {
    c() {
      if (svelte_element)
        svelte_element.c();
      svelte_element_anchor = empty();
    },
    m(target, anchor) {
      if (svelte_element)
        svelte_element.m(target, anchor);
      insert(target, svelte_element_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (
        /*tag*/
        ctx2[10]
      ) {
        if (!previous_tag) {
          svelte_element = create_dynamic_element(ctx2);
          previous_tag = /*tag*/
          ctx2[10];
          svelte_element.c();
          svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
        } else if (safe_not_equal(
          previous_tag,
          /*tag*/
          ctx2[10]
        )) {
          svelte_element.d(1);
          svelte_element = create_dynamic_element(ctx2);
          previous_tag = /*tag*/
          ctx2[10];
          svelte_element.c();
          svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
        } else {
          svelte_element.p(ctx2, dirty);
        }
      } else if (previous_tag) {
        svelte_element.d(1);
        svelte_element = null;
        previous_tag = /*tag*/
        ctx2[10];
      }
    },
    d(detaching) {
      if (detaching) {
        detach(svelte_element_anchor);
      }
      if (svelte_element)
        svelte_element.d(detaching);
    }
  };
}
function create_fragment(ctx) {
  let svg;
  let each_1_anchor;
  let svg_stroke_width_value;
  let svg_class_value;
  let current;
  let each_value = ensure_array_like(
    /*iconNode*/
    ctx[5]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
  }
  const default_slot_template = (
    /*#slots*/
    ctx[9].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[8],
    null
  );
  let svg_levels = [
    defaultAttributes_default,
    /*$$restProps*/
    ctx[6],
    { width: (
      /*size*/
      ctx[2]
    ) },
    { height: (
      /*size*/
      ctx[2]
    ) },
    { stroke: (
      /*color*/
      ctx[1]
    ) },
    {
      "stroke-width": svg_stroke_width_value = /*absoluteStrokeWidth*/
      ctx[4] ? Number(
        /*strokeWidth*/
        ctx[3]
      ) * 24 / Number(
        /*size*/
        ctx[2]
      ) : (
        /*strokeWidth*/
        ctx[3]
      )
    },
    {
      class: svg_class_value = `lucide-icon lucide lucide-${/*name*/
      ctx[0]} ${/*$$props*/
      ctx[7].class ?? ""}`
    }
  ];
  let svg_data = {};
  for (let i = 0; i < svg_levels.length; i += 1) {
    svg_data = assign(svg_data, svg_levels[i]);
  }
  return {
    c() {
      svg = svg_element("svg");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
      if (default_slot)
        default_slot.c();
      set_svg_attributes(svg, svg_data);
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(svg, null);
        }
      }
      append(svg, each_1_anchor);
      if (default_slot) {
        default_slot.m(svg, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (dirty & /*iconNode*/
      32) {
        each_value = ensure_array_like(
          /*iconNode*/
          ctx2[5]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(svg, each_1_anchor);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        256)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[8],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[8]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[8],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
        defaultAttributes_default,
        dirty & /*$$restProps*/
        64 && /*$$restProps*/
        ctx2[6],
        (!current || dirty & /*size*/
        4) && { width: (
          /*size*/
          ctx2[2]
        ) },
        (!current || dirty & /*size*/
        4) && { height: (
          /*size*/
          ctx2[2]
        ) },
        (!current || dirty & /*color*/
        2) && { stroke: (
          /*color*/
          ctx2[1]
        ) },
        (!current || dirty & /*absoluteStrokeWidth, strokeWidth, size*/
        28 && svg_stroke_width_value !== (svg_stroke_width_value = /*absoluteStrokeWidth*/
        ctx2[4] ? Number(
          /*strokeWidth*/
          ctx2[3]
        ) * 24 / Number(
          /*size*/
          ctx2[2]
        ) : (
          /*strokeWidth*/
          ctx2[3]
        ))) && { "stroke-width": svg_stroke_width_value },
        (!current || dirty & /*name, $$props*/
        129 && svg_class_value !== (svg_class_value = `lucide-icon lucide lucide-${/*name*/
        ctx2[0]} ${/*$$props*/
        ctx2[7].class ?? ""}`)) && { class: svg_class_value }
      ]));
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(svg);
      }
      destroy_each(each_blocks, detaching);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function instance($$self, $$props, $$invalidate) {
  const omit_props_names = ["name", "color", "size", "strokeWidth", "absoluteStrokeWidth", "iconNode"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  let { name } = $$props;
  let { color = "currentColor" } = $$props;
  let { size = 24 } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { absoluteStrokeWidth = false } = $$props;
  let { iconNode } = $$props;
  $$self.$$set = ($$new_props) => {
    $$invalidate(7, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("name" in $$new_props)
      $$invalidate(0, name = $$new_props.name);
    if ("color" in $$new_props)
      $$invalidate(1, color = $$new_props.color);
    if ("size" in $$new_props)
      $$invalidate(2, size = $$new_props.size);
    if ("strokeWidth" in $$new_props)
      $$invalidate(3, strokeWidth = $$new_props.strokeWidth);
    if ("absoluteStrokeWidth" in $$new_props)
      $$invalidate(4, absoluteStrokeWidth = $$new_props.absoluteStrokeWidth);
    if ("iconNode" in $$new_props)
      $$invalidate(5, iconNode = $$new_props.iconNode);
    if ("$$scope" in $$new_props)
      $$invalidate(8, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [
    name,
    color,
    size,
    strokeWidth,
    absoluteStrokeWidth,
    iconNode,
    $$restProps,
    $$props,
    $$scope,
    slots
  ];
}
var Icon = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance, create_fragment, safe_not_equal, {
      name: 0,
      color: 1,
      size: 2,
      strokeWidth: 3,
      absoluteStrokeWidth: 4,
      iconNode: 5
    });
  }
};
var Icon_default = Icon;

// node_modules/lucide-svelte/dist/icons/arrow-left.svelte
function create_default_slot(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment2(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [
    { name: "arrow-left" },
    /*$$props*/
    ctx[1],
    { iconNode: (
      /*iconNode*/
      ctx[0]
    ) }
  ];
  let icon_props = {
    $$slots: { default: [create_default_slot] },
    $$scope: { ctx }
  };
  for (let i = 0; i < icon_spread_levels.length; i += 1) {
    icon_props = assign(icon_props, icon_spread_levels[i]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & /*$$props, iconNode*/
      3 ? get_spread_update(icon_spread_levels, [
        icon_spread_levels[0],
        dirty & /*$$props*/
        2 && get_spread_object(
          /*$$props*/
          ctx2[1]
        ),
        dirty & /*iconNode*/
        1 && { iconNode: (
          /*iconNode*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      8) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance2($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const iconNode = [["path", { "d": "m12 19-7-7 7-7" }], ["path", { "d": "M19 12H5" }]];
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [iconNode, $$props, slots, $$scope];
}
var Arrow_left = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance2, create_fragment2, safe_not_equal, {});
  }
};
var arrow_left_default = Arrow_left;

// node_modules/lucide-svelte/dist/icons/arrow-right.svelte
function create_default_slot2(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment3(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [
    { name: "arrow-right" },
    /*$$props*/
    ctx[1],
    { iconNode: (
      /*iconNode*/
      ctx[0]
    ) }
  ];
  let icon_props = {
    $$slots: { default: [create_default_slot2] },
    $$scope: { ctx }
  };
  for (let i = 0; i < icon_spread_levels.length; i += 1) {
    icon_props = assign(icon_props, icon_spread_levels[i]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & /*$$props, iconNode*/
      3 ? get_spread_update(icon_spread_levels, [
        icon_spread_levels[0],
        dirty & /*$$props*/
        2 && get_spread_object(
          /*$$props*/
          ctx2[1]
        ),
        dirty & /*iconNode*/
        1 && { iconNode: (
          /*iconNode*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      8) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance3($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const iconNode = [["path", { "d": "M5 12h14" }], ["path", { "d": "m12 5 7 7-7 7" }]];
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [iconNode, $$props, slots, $$scope];
}
var Arrow_right = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance3, create_fragment3, safe_not_equal, {});
  }
};
var arrow_right_default = Arrow_right;

// node_modules/lucide-svelte/dist/icons/chevron-down.svelte
function create_default_slot3(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment4(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [
    { name: "chevron-down" },
    /*$$props*/
    ctx[1],
    { iconNode: (
      /*iconNode*/
      ctx[0]
    ) }
  ];
  let icon_props = {
    $$slots: { default: [create_default_slot3] },
    $$scope: { ctx }
  };
  for (let i = 0; i < icon_spread_levels.length; i += 1) {
    icon_props = assign(icon_props, icon_spread_levels[i]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & /*$$props, iconNode*/
      3 ? get_spread_update(icon_spread_levels, [
        icon_spread_levels[0],
        dirty & /*$$props*/
        2 && get_spread_object(
          /*$$props*/
          ctx2[1]
        ),
        dirty & /*iconNode*/
        1 && { iconNode: (
          /*iconNode*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      8) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance4($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const iconNode = [["path", { "d": "m6 9 6 6 6-6" }]];
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [iconNode, $$props, slots, $$scope];
}
var Chevron_down = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance4, create_fragment4, safe_not_equal, {});
  }
};
var chevron_down_default = Chevron_down;

// node_modules/lucide-svelte/dist/icons/chevron-right.svelte
function create_default_slot4(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment5(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [
    { name: "chevron-right" },
    /*$$props*/
    ctx[1],
    { iconNode: (
      /*iconNode*/
      ctx[0]
    ) }
  ];
  let icon_props = {
    $$slots: { default: [create_default_slot4] },
    $$scope: { ctx }
  };
  for (let i = 0; i < icon_spread_levels.length; i += 1) {
    icon_props = assign(icon_props, icon_spread_levels[i]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & /*$$props, iconNode*/
      3 ? get_spread_update(icon_spread_levels, [
        icon_spread_levels[0],
        dirty & /*$$props*/
        2 && get_spread_object(
          /*$$props*/
          ctx2[1]
        ),
        dirty & /*iconNode*/
        1 && { iconNode: (
          /*iconNode*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      8) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance5($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const iconNode = [["path", { "d": "m9 18 6-6-6-6" }]];
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [iconNode, $$props, slots, $$scope];
}
var Chevron_right = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance5, create_fragment5, safe_not_equal, {});
  }
};
var chevron_right_default = Chevron_right;

// node_modules/lucide-svelte/dist/icons/chevron-up.svelte
function create_default_slot5(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment6(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [
    { name: "chevron-up" },
    /*$$props*/
    ctx[1],
    { iconNode: (
      /*iconNode*/
      ctx[0]
    ) }
  ];
  let icon_props = {
    $$slots: { default: [create_default_slot5] },
    $$scope: { ctx }
  };
  for (let i = 0; i < icon_spread_levels.length; i += 1) {
    icon_props = assign(icon_props, icon_spread_levels[i]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & /*$$props, iconNode*/
      3 ? get_spread_update(icon_spread_levels, [
        icon_spread_levels[0],
        dirty & /*$$props*/
        2 && get_spread_object(
          /*$$props*/
          ctx2[1]
        ),
        dirty & /*iconNode*/
        1 && { iconNode: (
          /*iconNode*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      8) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance6($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const iconNode = [["path", { "d": "m18 15-6-6-6 6" }]];
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [iconNode, $$props, slots, $$scope];
}
var Chevron_up = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance6, create_fragment6, safe_not_equal, {});
  }
};
var chevron_up_default = Chevron_up;

// node_modules/lucide-svelte/dist/icons/clipboard-paste.svelte
function create_default_slot6(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment7(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [
    { name: "clipboard-paste" },
    /*$$props*/
    ctx[1],
    { iconNode: (
      /*iconNode*/
      ctx[0]
    ) }
  ];
  let icon_props = {
    $$slots: { default: [create_default_slot6] },
    $$scope: { ctx }
  };
  for (let i = 0; i < icon_spread_levels.length; i += 1) {
    icon_props = assign(icon_props, icon_spread_levels[i]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & /*$$props, iconNode*/
      3 ? get_spread_update(icon_spread_levels, [
        icon_spread_levels[0],
        dirty & /*$$props*/
        2 && get_spread_object(
          /*$$props*/
          ctx2[1]
        ),
        dirty & /*iconNode*/
        1 && { iconNode: (
          /*iconNode*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      8) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance7($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const iconNode = [
    [
      "path",
      {
        "d": "M15 2H9a1 1 0 0 0-1 1v2c0 .6.4 1 1 1h6c.6 0 1-.4 1-1V3c0-.6-.4-1-1-1Z"
      }
    ],
    [
      "path",
      {
        "d": "M8 4H6a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2M16 4h2a2 2 0 0 1 2 2v2M11 14h10"
      }
    ],
    ["path", { "d": "m17 10 4 4-4 4" }]
  ];
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [iconNode, $$props, slots, $$scope];
}
var Clipboard_paste = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance7, create_fragment7, safe_not_equal, {});
  }
};
var clipboard_paste_default = Clipboard_paste;

// node_modules/lucide-svelte/dist/icons/file-minus.svelte
function create_default_slot7(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment8(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [
    { name: "file-minus" },
    /*$$props*/
    ctx[1],
    { iconNode: (
      /*iconNode*/
      ctx[0]
    ) }
  ];
  let icon_props = {
    $$slots: { default: [create_default_slot7] },
    $$scope: { ctx }
  };
  for (let i = 0; i < icon_spread_levels.length; i += 1) {
    icon_props = assign(icon_props, icon_spread_levels[i]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & /*$$props, iconNode*/
      3 ? get_spread_update(icon_spread_levels, [
        icon_spread_levels[0],
        dirty & /*$$props*/
        2 && get_spread_object(
          /*$$props*/
          ctx2[1]
        ),
        dirty & /*iconNode*/
        1 && { iconNode: (
          /*iconNode*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      8) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance8($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const iconNode = [
    [
      "path",
      {
        "d": "M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7Z"
      }
    ],
    ["path", { "d": "M14 2v4a2 2 0 0 0 2 2h4" }],
    ["path", { "d": "M9 15h6" }]
  ];
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [iconNode, $$props, slots, $$scope];
}
var File_minus = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance8, create_fragment8, safe_not_equal, {});
  }
};
var file_minus_default = File_minus;

// node_modules/lucide-svelte/dist/icons/file-output.svelte
function create_default_slot8(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment9(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [
    { name: "file-output" },
    /*$$props*/
    ctx[1],
    { iconNode: (
      /*iconNode*/
      ctx[0]
    ) }
  ];
  let icon_props = {
    $$slots: { default: [create_default_slot8] },
    $$scope: { ctx }
  };
  for (let i = 0; i < icon_spread_levels.length; i += 1) {
    icon_props = assign(icon_props, icon_spread_levels[i]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & /*$$props, iconNode*/
      3 ? get_spread_update(icon_spread_levels, [
        icon_spread_levels[0],
        dirty & /*$$props*/
        2 && get_spread_object(
          /*$$props*/
          ctx2[1]
        ),
        dirty & /*iconNode*/
        1 && { iconNode: (
          /*iconNode*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      8) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance9($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const iconNode = [
    ["path", { "d": "M14 2v4a2 2 0 0 0 2 2h4" }],
    [
      "path",
      {
        "d": "M4 7V4a2 2 0 0 1 2-2 2 2 0 0 0-2 2"
      }
    ],
    [
      "path",
      {
        "d": "M4.063 20.999a2 2 0 0 0 2 1L18 22a2 2 0 0 0 2-2V7l-5-5H6"
      }
    ],
    ["path", { "d": "m5 11-3 3" }],
    ["path", { "d": "m5 17-3-3h10" }]
  ];
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [iconNode, $$props, slots, $$scope];
}
var File_output = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance9, create_fragment9, safe_not_equal, {});
  }
};
var file_output_default = File_output;

// node_modules/lucide-svelte/dist/icons/file-pen.svelte
function create_default_slot9(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment10(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [
    { name: "file-pen" },
    /*$$props*/
    ctx[1],
    { iconNode: (
      /*iconNode*/
      ctx[0]
    ) }
  ];
  let icon_props = {
    $$slots: { default: [create_default_slot9] },
    $$scope: { ctx }
  };
  for (let i = 0; i < icon_spread_levels.length; i += 1) {
    icon_props = assign(icon_props, icon_spread_levels[i]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & /*$$props, iconNode*/
      3 ? get_spread_update(icon_spread_levels, [
        icon_spread_levels[0],
        dirty & /*$$props*/
        2 && get_spread_object(
          /*$$props*/
          ctx2[1]
        ),
        dirty & /*iconNode*/
        1 && { iconNode: (
          /*iconNode*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      8) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance10($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const iconNode = [
    [
      "path",
      {
        "d": "M12 22h6a2 2 0 0 0 2-2V7l-5-5H6a2 2 0 0 0-2 2v10"
      }
    ],
    ["path", { "d": "M14 2v4a2 2 0 0 0 2 2h4" }],
    [
      "path",
      {
        "d": "M10.4 12.6a2 2 0 1 1 3 3L8 21l-4 1 1-4Z"
      }
    ]
  ];
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [iconNode, $$props, slots, $$scope];
}
var File_pen = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance10, create_fragment10, safe_not_equal, {});
  }
};
var file_pen_default = File_pen;

// node_modules/lucide-svelte/dist/icons/file-plus.svelte
function create_default_slot10(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment11(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [
    { name: "file-plus" },
    /*$$props*/
    ctx[1],
    { iconNode: (
      /*iconNode*/
      ctx[0]
    ) }
  ];
  let icon_props = {
    $$slots: { default: [create_default_slot10] },
    $$scope: { ctx }
  };
  for (let i = 0; i < icon_spread_levels.length; i += 1) {
    icon_props = assign(icon_props, icon_spread_levels[i]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & /*$$props, iconNode*/
      3 ? get_spread_update(icon_spread_levels, [
        icon_spread_levels[0],
        dirty & /*$$props*/
        2 && get_spread_object(
          /*$$props*/
          ctx2[1]
        ),
        dirty & /*iconNode*/
        1 && { iconNode: (
          /*iconNode*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      8) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance11($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const iconNode = [
    [
      "path",
      {
        "d": "M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7Z"
      }
    ],
    ["path", { "d": "M14 2v4a2 2 0 0 0 2 2h4" }],
    ["path", { "d": "M9 15h6" }],
    ["path", { "d": "M12 18v-6" }]
  ];
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [iconNode, $$props, slots, $$scope];
}
var File_plus = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance11, create_fragment11, safe_not_equal, {});
  }
};
var file_plus_default = File_plus;

// node_modules/lucide-svelte/dist/icons/file-symlink.svelte
function create_default_slot11(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment12(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [
    { name: "file-symlink" },
    /*$$props*/
    ctx[1],
    { iconNode: (
      /*iconNode*/
      ctx[0]
    ) }
  ];
  let icon_props = {
    $$slots: { default: [create_default_slot11] },
    $$scope: { ctx }
  };
  for (let i = 0; i < icon_spread_levels.length; i += 1) {
    icon_props = assign(icon_props, icon_spread_levels[i]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & /*$$props, iconNode*/
      3 ? get_spread_update(icon_spread_levels, [
        icon_spread_levels[0],
        dirty & /*$$props*/
        2 && get_spread_object(
          /*$$props*/
          ctx2[1]
        ),
        dirty & /*iconNode*/
        1 && { iconNode: (
          /*iconNode*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      8) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance12($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const iconNode = [
    ["path", { "d": "m10 18 3-3-3-3" }],
    ["path", { "d": "M14 2v4a2 2 0 0 0 2 2h4" }],
    [
      "path",
      {
        "d": "M4 11V4a2 2 0 0 1 2-2h9l5 5v13a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2v-3a2 2 0 0 1 2-2h7"
      }
    ]
  ];
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [iconNode, $$props, slots, $$scope];
}
var File_symlink = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance12, create_fragment12, safe_not_equal, {});
  }
};
var file_symlink_default = File_symlink;

// node_modules/lucide-svelte/dist/icons/file-up.svelte
function create_default_slot12(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment13(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [
    { name: "file-up" },
    /*$$props*/
    ctx[1],
    { iconNode: (
      /*iconNode*/
      ctx[0]
    ) }
  ];
  let icon_props = {
    $$slots: { default: [create_default_slot12] },
    $$scope: { ctx }
  };
  for (let i = 0; i < icon_spread_levels.length; i += 1) {
    icon_props = assign(icon_props, icon_spread_levels[i]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & /*$$props, iconNode*/
      3 ? get_spread_update(icon_spread_levels, [
        icon_spread_levels[0],
        dirty & /*$$props*/
        2 && get_spread_object(
          /*$$props*/
          ctx2[1]
        ),
        dirty & /*iconNode*/
        1 && { iconNode: (
          /*iconNode*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      8) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance13($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const iconNode = [
    [
      "path",
      {
        "d": "M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7Z"
      }
    ],
    ["path", { "d": "M14 2v4a2 2 0 0 0 2 2h4" }],
    ["path", { "d": "M12 12v6" }],
    ["path", { "d": "m15 15-3-3-3 3" }]
  ];
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [iconNode, $$props, slots, $$scope];
}
var File_up = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance13, create_fragment13, safe_not_equal, {});
  }
};
var file_up_default = File_up;

// node_modules/lucide-svelte/dist/icons/heading-1.svelte
function create_default_slot13(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment14(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [
    { name: "heading-1" },
    /*$$props*/
    ctx[1],
    { iconNode: (
      /*iconNode*/
      ctx[0]
    ) }
  ];
  let icon_props = {
    $$slots: { default: [create_default_slot13] },
    $$scope: { ctx }
  };
  for (let i = 0; i < icon_spread_levels.length; i += 1) {
    icon_props = assign(icon_props, icon_spread_levels[i]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & /*$$props, iconNode*/
      3 ? get_spread_update(icon_spread_levels, [
        icon_spread_levels[0],
        dirty & /*$$props*/
        2 && get_spread_object(
          /*$$props*/
          ctx2[1]
        ),
        dirty & /*iconNode*/
        1 && { iconNode: (
          /*iconNode*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      8) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance14($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const iconNode = [
    ["path", { "d": "M4 12h8" }],
    ["path", { "d": "M4 18V6" }],
    ["path", { "d": "M12 18V6" }],
    ["path", { "d": "m17 12 3-2v8" }]
  ];
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [iconNode, $$props, slots, $$scope];
}
var Heading_1 = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance14, create_fragment14, safe_not_equal, {});
  }
};
var heading_1_default = Heading_1;

// node_modules/lucide-svelte/dist/icons/history.svelte
function create_default_slot14(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment15(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [
    { name: "history" },
    /*$$props*/
    ctx[1],
    { iconNode: (
      /*iconNode*/
      ctx[0]
    ) }
  ];
  let icon_props = {
    $$slots: { default: [create_default_slot14] },
    $$scope: { ctx }
  };
  for (let i = 0; i < icon_spread_levels.length; i += 1) {
    icon_props = assign(icon_props, icon_spread_levels[i]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & /*$$props, iconNode*/
      3 ? get_spread_update(icon_spread_levels, [
        icon_spread_levels[0],
        dirty & /*$$props*/
        2 && get_spread_object(
          /*$$props*/
          ctx2[1]
        ),
        dirty & /*iconNode*/
        1 && { iconNode: (
          /*iconNode*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      8) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance15($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const iconNode = [
    [
      "path",
      {
        "d": "M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"
      }
    ],
    ["path", { "d": "M3 3v5h5" }],
    ["path", { "d": "M12 7v5l4 2" }]
  ];
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [iconNode, $$props, slots, $$scope];
}
var History = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance15, create_fragment15, safe_not_equal, {});
  }
};
var history_default = History;

// node_modules/lucide-svelte/dist/icons/keyboard.svelte
function create_default_slot15(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment16(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [
    { name: "keyboard" },
    /*$$props*/
    ctx[1],
    { iconNode: (
      /*iconNode*/
      ctx[0]
    ) }
  ];
  let icon_props = {
    $$slots: { default: [create_default_slot15] },
    $$scope: { ctx }
  };
  for (let i = 0; i < icon_spread_levels.length; i += 1) {
    icon_props = assign(icon_props, icon_spread_levels[i]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & /*$$props, iconNode*/
      3 ? get_spread_update(icon_spread_levels, [
        icon_spread_levels[0],
        dirty & /*$$props*/
        2 && get_spread_object(
          /*$$props*/
          ctx2[1]
        ),
        dirty & /*iconNode*/
        1 && { iconNode: (
          /*iconNode*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      8) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance16($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const iconNode = [
    ["path", { "d": "M10 8h.01" }],
    ["path", { "d": "M12 12h.01" }],
    ["path", { "d": "M14 8h.01" }],
    ["path", { "d": "M16 12h.01" }],
    ["path", { "d": "M18 8h.01" }],
    ["path", { "d": "M6 8h.01" }],
    ["path", { "d": "M7 16h10" }],
    ["path", { "d": "M8 12h.01" }],
    [
      "rect",
      {
        "x": "2",
        "y": "4",
        "width": "20",
        "height": "16",
        "rx": "2"
      }
    ]
  ];
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [iconNode, $$props, slots, $$scope];
}
var Keyboard = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance16, create_fragment16, safe_not_equal, {});
  }
};
var keyboard_default = Keyboard;

// node_modules/lucide-svelte/dist/icons/maximize.svelte
function create_default_slot16(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment17(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [
    { name: "maximize" },
    /*$$props*/
    ctx[1],
    { iconNode: (
      /*iconNode*/
      ctx[0]
    ) }
  ];
  let icon_props = {
    $$slots: { default: [create_default_slot16] },
    $$scope: { ctx }
  };
  for (let i = 0; i < icon_spread_levels.length; i += 1) {
    icon_props = assign(icon_props, icon_spread_levels[i]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & /*$$props, iconNode*/
      3 ? get_spread_update(icon_spread_levels, [
        icon_spread_levels[0],
        dirty & /*$$props*/
        2 && get_spread_object(
          /*$$props*/
          ctx2[1]
        ),
        dirty & /*iconNode*/
        1 && { iconNode: (
          /*iconNode*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      8) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance17($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const iconNode = [
    ["path", { "d": "M8 3H5a2 2 0 0 0-2 2v3" }],
    ["path", { "d": "M21 8V5a2 2 0 0 0-2-2h-3" }],
    ["path", { "d": "M3 16v3a2 2 0 0 0 2 2h3" }],
    ["path", { "d": "M16 21h3a2 2 0 0 0 2-2v-3" }]
  ];
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [iconNode, $$props, slots, $$scope];
}
var Maximize = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance17, create_fragment17, safe_not_equal, {});
  }
};
var maximize_default = Maximize;

// node_modules/lucide-svelte/dist/icons/merge.svelte
function create_default_slot17(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment18(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [
    { name: "merge" },
    /*$$props*/
    ctx[1],
    { iconNode: (
      /*iconNode*/
      ctx[0]
    ) }
  ];
  let icon_props = {
    $$slots: { default: [create_default_slot17] },
    $$scope: { ctx }
  };
  for (let i = 0; i < icon_spread_levels.length; i += 1) {
    icon_props = assign(icon_props, icon_spread_levels[i]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & /*$$props, iconNode*/
      3 ? get_spread_update(icon_spread_levels, [
        icon_spread_levels[0],
        dirty & /*$$props*/
        2 && get_spread_object(
          /*$$props*/
          ctx2[1]
        ),
        dirty & /*iconNode*/
        1 && { iconNode: (
          /*iconNode*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      8) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance18($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const iconNode = [
    ["path", { "d": "m8 6 4-4 4 4" }],
    [
      "path",
      {
        "d": "M12 2v10.3a4 4 0 0 1-1.172 2.872L4 22"
      }
    ],
    ["path", { "d": "m20 22-5-5" }]
  ];
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [iconNode, $$props, slots, $$scope];
}
var Merge = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance18, create_fragment18, safe_not_equal, {});
  }
};
var merge_default = Merge;

// node_modules/lucide-svelte/dist/icons/minus.svelte
function create_default_slot18(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment19(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [
    { name: "minus" },
    /*$$props*/
    ctx[1],
    { iconNode: (
      /*iconNode*/
      ctx[0]
    ) }
  ];
  let icon_props = {
    $$slots: { default: [create_default_slot18] },
    $$scope: { ctx }
  };
  for (let i = 0; i < icon_spread_levels.length; i += 1) {
    icon_props = assign(icon_props, icon_spread_levels[i]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & /*$$props, iconNode*/
      3 ? get_spread_update(icon_spread_levels, [
        icon_spread_levels[0],
        dirty & /*$$props*/
        2 && get_spread_object(
          /*$$props*/
          ctx2[1]
        ),
        dirty & /*iconNode*/
        1 && { iconNode: (
          /*iconNode*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      8) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance19($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const iconNode = [["path", { "d": "M5 12h14" }]];
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [iconNode, $$props, slots, $$scope];
}
var Minus = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance19, create_fragment19, safe_not_equal, {});
  }
};
var minus_default = Minus;

// node_modules/lucide-svelte/dist/icons/more-vertical.svelte
function create_default_slot19(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment20(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [
    { name: "more-vertical" },
    /*$$props*/
    ctx[1],
    { iconNode: (
      /*iconNode*/
      ctx[0]
    ) }
  ];
  let icon_props = {
    $$slots: { default: [create_default_slot19] },
    $$scope: { ctx }
  };
  for (let i = 0; i < icon_spread_levels.length; i += 1) {
    icon_props = assign(icon_props, icon_spread_levels[i]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & /*$$props, iconNode*/
      3 ? get_spread_update(icon_spread_levels, [
        icon_spread_levels[0],
        dirty & /*$$props*/
        2 && get_spread_object(
          /*$$props*/
          ctx2[1]
        ),
        dirty & /*iconNode*/
        1 && { iconNode: (
          /*iconNode*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      8) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance20($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const iconNode = [
    ["circle", { "cx": "12", "cy": "12", "r": "1" }],
    ["circle", { "cx": "12", "cy": "5", "r": "1" }],
    ["circle", { "cx": "12", "cy": "19", "r": "1" }]
  ];
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [iconNode, $$props, slots, $$scope];
}
var More_vertical = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance20, create_fragment20, safe_not_equal, {});
  }
};
var more_vertical_default = More_vertical;

// node_modules/lucide-svelte/dist/icons/pen.svelte
function create_default_slot20(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment21(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [
    { name: "pen" },
    /*$$props*/
    ctx[1],
    { iconNode: (
      /*iconNode*/
      ctx[0]
    ) }
  ];
  let icon_props = {
    $$slots: { default: [create_default_slot20] },
    $$scope: { ctx }
  };
  for (let i = 0; i < icon_spread_levels.length; i += 1) {
    icon_props = assign(icon_props, icon_spread_levels[i]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & /*$$props, iconNode*/
      3 ? get_spread_update(icon_spread_levels, [
        icon_spread_levels[0],
        dirty & /*$$props*/
        2 && get_spread_object(
          /*$$props*/
          ctx2[1]
        ),
        dirty & /*iconNode*/
        1 && { iconNode: (
          /*iconNode*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      8) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance21($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const iconNode = [
    [
      "path",
      {
        "d": "M17 3a2.85 2.83 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5Z"
      }
    ]
  ];
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [iconNode, $$props, slots, $$scope];
}
var Pen = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance21, create_fragment21, safe_not_equal, {});
  }
};
var pen_default = Pen;

// node_modules/lucide-svelte/dist/icons/pencil.svelte
function create_default_slot21(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment22(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [
    { name: "pencil" },
    /*$$props*/
    ctx[1],
    { iconNode: (
      /*iconNode*/
      ctx[0]
    ) }
  ];
  let icon_props = {
    $$slots: { default: [create_default_slot21] },
    $$scope: { ctx }
  };
  for (let i = 0; i < icon_spread_levels.length; i += 1) {
    icon_props = assign(icon_props, icon_spread_levels[i]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & /*$$props, iconNode*/
      3 ? get_spread_update(icon_spread_levels, [
        icon_spread_levels[0],
        dirty & /*$$props*/
        2 && get_spread_object(
          /*$$props*/
          ctx2[1]
        ),
        dirty & /*iconNode*/
        1 && { iconNode: (
          /*iconNode*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      8) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance22($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const iconNode = [
    [
      "path",
      {
        "d": "M17 3a2.85 2.83 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5Z"
      }
    ],
    ["path", { "d": "m15 5 4 4" }]
  ];
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [iconNode, $$props, slots, $$scope];
}
var Pencil = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance22, create_fragment22, safe_not_equal, {});
  }
};
var pencil_default = Pencil;

// node_modules/lucide-svelte/dist/icons/plus.svelte
function create_default_slot22(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment23(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [
    { name: "plus" },
    /*$$props*/
    ctx[1],
    { iconNode: (
      /*iconNode*/
      ctx[0]
    ) }
  ];
  let icon_props = {
    $$slots: { default: [create_default_slot22] },
    $$scope: { ctx }
  };
  for (let i = 0; i < icon_spread_levels.length; i += 1) {
    icon_props = assign(icon_props, icon_spread_levels[i]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & /*$$props, iconNode*/
      3 ? get_spread_update(icon_spread_levels, [
        icon_spread_levels[0],
        dirty & /*$$props*/
        2 && get_spread_object(
          /*$$props*/
          ctx2[1]
        ),
        dirty & /*iconNode*/
        1 && { iconNode: (
          /*iconNode*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      8) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance23($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const iconNode = [["path", { "d": "M5 12h14" }], ["path", { "d": "M12 5v14" }]];
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [iconNode, $$props, slots, $$scope];
}
var Plus = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance23, create_fragment23, safe_not_equal, {});
  }
};
var plus_default = Plus;

// node_modules/lucide-svelte/dist/icons/redo-2.svelte
function create_default_slot23(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment24(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [
    { name: "redo-2" },
    /*$$props*/
    ctx[1],
    { iconNode: (
      /*iconNode*/
      ctx[0]
    ) }
  ];
  let icon_props = {
    $$slots: { default: [create_default_slot23] },
    $$scope: { ctx }
  };
  for (let i = 0; i < icon_spread_levels.length; i += 1) {
    icon_props = assign(icon_props, icon_spread_levels[i]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & /*$$props, iconNode*/
      3 ? get_spread_update(icon_spread_levels, [
        icon_spread_levels[0],
        dirty & /*$$props*/
        2 && get_spread_object(
          /*$$props*/
          ctx2[1]
        ),
        dirty & /*iconNode*/
        1 && { iconNode: (
          /*iconNode*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      8) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance24($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const iconNode = [
    ["path", { "d": "m15 14 5-5-5-5" }],
    [
      "path",
      {
        "d": "M20 9H9.5A5.5 5.5 0 0 0 4 14.5v0A5.5 5.5 0 0 0 9.5 20H13"
      }
    ]
  ];
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [iconNode, $$props, slots, $$scope];
}
var Redo_2 = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance24, create_fragment24, safe_not_equal, {});
  }
};
var redo_2_default = Redo_2;

// node_modules/lucide-svelte/dist/icons/rotate-ccw.svelte
function create_default_slot24(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment25(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [
    { name: "rotate-ccw" },
    /*$$props*/
    ctx[1],
    { iconNode: (
      /*iconNode*/
      ctx[0]
    ) }
  ];
  let icon_props = {
    $$slots: { default: [create_default_slot24] },
    $$scope: { ctx }
  };
  for (let i = 0; i < icon_spread_levels.length; i += 1) {
    icon_props = assign(icon_props, icon_spread_levels[i]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & /*$$props, iconNode*/
      3 ? get_spread_update(icon_spread_levels, [
        icon_spread_levels[0],
        dirty & /*$$props*/
        2 && get_spread_object(
          /*$$props*/
          ctx2[1]
        ),
        dirty & /*iconNode*/
        1 && { iconNode: (
          /*iconNode*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      8) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance25($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const iconNode = [
    [
      "path",
      {
        "d": "M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"
      }
    ],
    ["path", { "d": "M3 3v5h5" }]
  ];
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [iconNode, $$props, slots, $$scope];
}
var Rotate_ccw = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance25, create_fragment25, safe_not_equal, {});
  }
};
var rotate_ccw_default = Rotate_ccw;

// node_modules/lucide-svelte/dist/icons/save.svelte
function create_default_slot25(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment26(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [
    { name: "save" },
    /*$$props*/
    ctx[1],
    { iconNode: (
      /*iconNode*/
      ctx[0]
    ) }
  ];
  let icon_props = {
    $$slots: { default: [create_default_slot25] },
    $$scope: { ctx }
  };
  for (let i = 0; i < icon_spread_levels.length; i += 1) {
    icon_props = assign(icon_props, icon_spread_levels[i]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & /*$$props, iconNode*/
      3 ? get_spread_update(icon_spread_levels, [
        icon_spread_levels[0],
        dirty & /*$$props*/
        2 && get_spread_object(
          /*$$props*/
          ctx2[1]
        ),
        dirty & /*iconNode*/
        1 && { iconNode: (
          /*iconNode*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      8) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance26($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const iconNode = [
    [
      "path",
      {
        "d": "M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"
      }
    ],
    ["polyline", { "points": "17 21 17 13 7 13 7 21" }],
    ["polyline", { "points": "7 3 7 8 15 8" }]
  ];
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [iconNode, $$props, slots, $$scope];
}
var Save = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance26, create_fragment26, safe_not_equal, {});
  }
};
var save_default = Save;

// node_modules/lucide-svelte/dist/icons/scissors.svelte
function create_default_slot26(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment27(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [
    { name: "scissors" },
    /*$$props*/
    ctx[1],
    { iconNode: (
      /*iconNode*/
      ctx[0]
    ) }
  ];
  let icon_props = {
    $$slots: { default: [create_default_slot26] },
    $$scope: { ctx }
  };
  for (let i = 0; i < icon_spread_levels.length; i += 1) {
    icon_props = assign(icon_props, icon_spread_levels[i]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & /*$$props, iconNode*/
      3 ? get_spread_update(icon_spread_levels, [
        icon_spread_levels[0],
        dirty & /*$$props*/
        2 && get_spread_object(
          /*$$props*/
          ctx2[1]
        ),
        dirty & /*iconNode*/
        1 && { iconNode: (
          /*iconNode*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      8) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance27($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const iconNode = [
    ["circle", { "cx": "6", "cy": "6", "r": "3" }],
    ["path", { "d": "M8.12 8.12 12 12" }],
    ["path", { "d": "M20 4 8.12 15.88" }],
    ["circle", { "cx": "6", "cy": "18", "r": "3" }],
    ["path", { "d": "M14.8 14.8 20 20" }]
  ];
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [iconNode, $$props, slots, $$scope];
}
var Scissors = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance27, create_fragment27, safe_not_equal, {});
  }
};
var scissors_default = Scissors;

// node_modules/lucide-svelte/dist/icons/search.svelte
function create_default_slot27(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment28(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [
    { name: "search" },
    /*$$props*/
    ctx[1],
    { iconNode: (
      /*iconNode*/
      ctx[0]
    ) }
  ];
  let icon_props = {
    $$slots: { default: [create_default_slot27] },
    $$scope: { ctx }
  };
  for (let i = 0; i < icon_spread_levels.length; i += 1) {
    icon_props = assign(icon_props, icon_spread_levels[i]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & /*$$props, iconNode*/
      3 ? get_spread_update(icon_spread_levels, [
        icon_spread_levels[0],
        dirty & /*$$props*/
        2 && get_spread_object(
          /*$$props*/
          ctx2[1]
        ),
        dirty & /*iconNode*/
        1 && { iconNode: (
          /*iconNode*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      8) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance28($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const iconNode = [
    ["circle", { "cx": "11", "cy": "11", "r": "8" }],
    ["path", { "d": "m21 21-4.3-4.3" }]
  ];
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [iconNode, $$props, slots, $$scope];
}
var Search = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance28, create_fragment28, safe_not_equal, {});
  }
};
var search_default = Search;

// node_modules/lucide-svelte/dist/icons/settings.svelte
function create_default_slot28(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment29(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [
    { name: "settings" },
    /*$$props*/
    ctx[1],
    { iconNode: (
      /*iconNode*/
      ctx[0]
    ) }
  ];
  let icon_props = {
    $$slots: { default: [create_default_slot28] },
    $$scope: { ctx }
  };
  for (let i = 0; i < icon_spread_levels.length; i += 1) {
    icon_props = assign(icon_props, icon_spread_levels[i]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & /*$$props, iconNode*/
      3 ? get_spread_update(icon_spread_levels, [
        icon_spread_levels[0],
        dirty & /*$$props*/
        2 && get_spread_object(
          /*$$props*/
          ctx2[1]
        ),
        dirty & /*iconNode*/
        1 && { iconNode: (
          /*iconNode*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      8) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance29($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const iconNode = [
    [
      "path",
      {
        "d": "M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.39a2 2 0 0 0-.73-2.73l-.15-.08a2 2 0 0 1-1-1.74v-.5a2 2 0 0 1 1-1.74l.15-.09a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z"
      }
    ],
    ["circle", { "cx": "12", "cy": "12", "r": "3" }]
  ];
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [iconNode, $$props, slots, $$scope];
}
var Settings = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance29, create_fragment29, safe_not_equal, {});
  }
};
var settings_default = Settings;

// node_modules/lucide-svelte/dist/icons/split.svelte
function create_default_slot29(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment30(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [
    { name: "split" },
    /*$$props*/
    ctx[1],
    { iconNode: (
      /*iconNode*/
      ctx[0]
    ) }
  ];
  let icon_props = {
    $$slots: { default: [create_default_slot29] },
    $$scope: { ctx }
  };
  for (let i = 0; i < icon_spread_levels.length; i += 1) {
    icon_props = assign(icon_props, icon_spread_levels[i]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & /*$$props, iconNode*/
      3 ? get_spread_update(icon_spread_levels, [
        icon_spread_levels[0],
        dirty & /*$$props*/
        2 && get_spread_object(
          /*$$props*/
          ctx2[1]
        ),
        dirty & /*iconNode*/
        1 && { iconNode: (
          /*iconNode*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      8) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance30($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const iconNode = [
    ["path", { "d": "M16 3h5v5" }],
    ["path", { "d": "M8 3H3v5" }],
    [
      "path",
      {
        "d": "M12 22v-8.3a4 4 0 0 0-1.172-2.872L3 3"
      }
    ],
    ["path", { "d": "m15 9 6-6" }]
  ];
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [iconNode, $$props, slots, $$scope];
}
var Split = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance30, create_fragment30, safe_not_equal, {});
  }
};
var split_default = Split;

// node_modules/lucide-svelte/dist/icons/text.svelte
function create_default_slot30(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment31(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [
    { name: "text" },
    /*$$props*/
    ctx[1],
    { iconNode: (
      /*iconNode*/
      ctx[0]
    ) }
  ];
  let icon_props = {
    $$slots: { default: [create_default_slot30] },
    $$scope: { ctx }
  };
  for (let i = 0; i < icon_spread_levels.length; i += 1) {
    icon_props = assign(icon_props, icon_spread_levels[i]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & /*$$props, iconNode*/
      3 ? get_spread_update(icon_spread_levels, [
        icon_spread_levels[0],
        dirty & /*$$props*/
        2 && get_spread_object(
          /*$$props*/
          ctx2[1]
        ),
        dirty & /*iconNode*/
        1 && { iconNode: (
          /*iconNode*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      8) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance31($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const iconNode = [
    ["path", { "d": "M17 6.1H3" }],
    ["path", { "d": "M21 12.1H3" }],
    ["path", { "d": "M15.1 18H3" }]
  ];
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [iconNode, $$props, slots, $$scope];
}
var Text = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance31, create_fragment31, safe_not_equal, {});
  }
};
var text_default = Text;

// node_modules/lucide-svelte/dist/icons/trash.svelte
function create_default_slot31(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment32(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [
    { name: "trash" },
    /*$$props*/
    ctx[1],
    { iconNode: (
      /*iconNode*/
      ctx[0]
    ) }
  ];
  let icon_props = {
    $$slots: { default: [create_default_slot31] },
    $$scope: { ctx }
  };
  for (let i = 0; i < icon_spread_levels.length; i += 1) {
    icon_props = assign(icon_props, icon_spread_levels[i]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & /*$$props, iconNode*/
      3 ? get_spread_update(icon_spread_levels, [
        icon_spread_levels[0],
        dirty & /*$$props*/
        2 && get_spread_object(
          /*$$props*/
          ctx2[1]
        ),
        dirty & /*iconNode*/
        1 && { iconNode: (
          /*iconNode*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      8) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance32($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const iconNode = [
    ["path", { "d": "M3 6h18" }],
    [
      "path",
      {
        "d": "M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6"
      }
    ],
    [
      "path",
      {
        "d": "M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2"
      }
    ]
  ];
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [iconNode, $$props, slots, $$scope];
}
var Trash = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance32, create_fragment32, safe_not_equal, {});
  }
};
var trash_default = Trash;

// node_modules/lucide-svelte/dist/icons/undo-2.svelte
function create_default_slot32(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment33(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [
    { name: "undo-2" },
    /*$$props*/
    ctx[1],
    { iconNode: (
      /*iconNode*/
      ctx[0]
    ) }
  ];
  let icon_props = {
    $$slots: { default: [create_default_slot32] },
    $$scope: { ctx }
  };
  for (let i = 0; i < icon_spread_levels.length; i += 1) {
    icon_props = assign(icon_props, icon_spread_levels[i]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & /*$$props, iconNode*/
      3 ? get_spread_update(icon_spread_levels, [
        icon_spread_levels[0],
        dirty & /*$$props*/
        2 && get_spread_object(
          /*$$props*/
          ctx2[1]
        ),
        dirty & /*iconNode*/
        1 && { iconNode: (
          /*iconNode*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      8) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance33($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const iconNode = [
    ["path", { "d": "M9 14 4 9l5-5" }],
    [
      "path",
      {
        "d": "M4 9h10.5a5.5 5.5 0 0 1 5.5 5.5v0a5.5 5.5 0 0 1-5.5 5.5H11"
      }
    ]
  ];
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [iconNode, $$props, slots, $$scope];
}
var Undo_2 = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance33, create_fragment33, safe_not_equal, {});
  }
};
var undo_2_default = Undo_2;

// node_modules/lucide-svelte/dist/icons/x.svelte
function create_default_slot33(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment34(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [
    { name: "x" },
    /*$$props*/
    ctx[1],
    { iconNode: (
      /*iconNode*/
      ctx[0]
    ) }
  ];
  let icon_props = {
    $$slots: { default: [create_default_slot33] },
    $$scope: { ctx }
  };
  for (let i = 0; i < icon_spread_levels.length; i += 1) {
    icon_props = assign(icon_props, icon_spread_levels[i]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & /*$$props, iconNode*/
      3 ? get_spread_update(icon_spread_levels, [
        icon_spread_levels[0],
        dirty & /*$$props*/
        2 && get_spread_object(
          /*$$props*/
          ctx2[1]
        ),
        dirty & /*iconNode*/
        1 && { iconNode: (
          /*iconNode*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      8) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance34($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const iconNode = [["path", { "d": "M18 6 6 18" }], ["path", { "d": "m6 6 12 12" }]];
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [iconNode, $$props, slots, $$scope];
}
var X = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance34, create_fragment34, safe_not_equal, {});
  }
};
var x_default = X;

// src/view/components/container/context.ts
var getPlugin = () => {
  return getContext("plugin");
};
var getView = () => {
  return getContext("view");
};

// src/lib/store/derived.ts
var derived = (source, mapper) => {
  const subscribers = /* @__PURE__ */ new Set();
  let derivedValue;
  let unsubFromSource = null;
  return {
    subscribe: (run2) => {
      subscribers.add(run2);
      if (!unsubFromSource) {
        unsubFromSource = source.subscribe(
          (value, action, initialRun) => {
            if (action || initialRun) {
              const newValue = mapper(value, action);
              if (newValue !== derivedValue) {
                derivedValue = newValue;
                for (const sub of subscribers) {
                  sub(derivedValue, action, initialRun);
                }
              }
            }
          }
        );
      }
      return () => {
        subscribers.delete(run2);
        if (unsubFromSource && subscribers.size === 0) {
          unsubFromSource();
          unsubFromSource = null;
        }
      };
    }
  };
};

// src/stores/document/derived/history-store.ts
var historyStore = (view) => {
  return derived(view.documentStore, (state2) => {
    return state2.history;
  });
};

// src/view/components/container/controls-bar/controls-container.svelte
var import_obsidian = require("obsidian");

// src/stores/view/derived/zoom-level-store.ts
var zoomLevelStore = (view) => derived(view.plugin.settings, (state2) => state2.view.zoomLevel);

// node_modules/svelte/src/runtime/store/index.js
var subscriber_queue = [];
function writable(value, start = noop) {
  let stop;
  const subscribers = /* @__PURE__ */ new Set();
  function set(new_value) {
    if (safe_not_equal(value, new_value)) {
      value = new_value;
      if (stop) {
        const run_queue = !subscriber_queue.length;
        for (const subscriber of subscribers) {
          subscriber[1]();
          subscriber_queue.push(subscriber, value);
        }
        if (run_queue) {
          for (let i = 0; i < subscriber_queue.length; i += 2) {
            subscriber_queue[i][0](subscriber_queue[i + 1]);
          }
          subscriber_queue.length = 0;
        }
      }
    }
  }
  function update2(fn) {
    set(fn(value));
  }
  function subscribe2(run2, invalidate = noop) {
    const subscriber = [run2, invalidate];
    subscribers.add(subscriber);
    if (subscribers.size === 1) {
      stop = start(set, update2) || noop;
    }
    run2(value);
    return () => {
      subscribers.delete(subscriber);
      if (subscribers.size === 0 && stop) {
        stop();
        stop = null;
      }
    };
  }
  return { set, update: update2, subscribe: subscribe2 };
}

// src/stores/view/derived/ui-controls-store.ts
var uiControlsStore = (view) => derived(view.viewStore, (state2) => state2.ui.controls);

// src/view/components/container/shared/button.svelte
function create_fragment35(ctx) {
  let button;
  let button_class_value;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[6].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    null
  );
  return {
    c() {
      button = element("button");
      if (default_slot)
        default_slot.c();
      attr(
        button,
        "aria-label",
        /*label*/
        ctx[0]
      );
      attr(button, "class", button_class_value = "lineage-view-button " + /*classes*/
      ctx[3]);
      attr(
        button,
        "data-active",
        /*active*/
        ctx[4]
      );
      attr(
        button,
        "data-tooltip-position",
        /*tooltipPosition*/
        ctx[1]
      );
      button.disabled = /*disabled*/
      ctx[2];
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (default_slot) {
        default_slot.m(button, null);
      }
      current = true;
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*click_handler*/
          ctx[7]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        32)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*label*/
      1) {
        attr(
          button,
          "aria-label",
          /*label*/
          ctx2[0]
        );
      }
      if (!current || dirty & /*classes*/
      8 && button_class_value !== (button_class_value = "lineage-view-button " + /*classes*/
      ctx2[3])) {
        attr(button, "class", button_class_value);
      }
      if (!current || dirty & /*active*/
      16) {
        attr(
          button,
          "data-active",
          /*active*/
          ctx2[4]
        );
      }
      if (!current || dirty & /*tooltipPosition*/
      2) {
        attr(
          button,
          "data-tooltip-position",
          /*tooltipPosition*/
          ctx2[1]
        );
      }
      if (!current || dirty & /*disabled*/
      4) {
        button.disabled = /*disabled*/
        ctx2[2];
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
}
function instance35($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { label } = $$props;
  let { tooltipPosition } = $$props;
  let { disabled = false } = $$props;
  let { classes = "" } = $$props;
  let { active = false } = $$props;
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("label" in $$props2)
      $$invalidate(0, label = $$props2.label);
    if ("tooltipPosition" in $$props2)
      $$invalidate(1, tooltipPosition = $$props2.tooltipPosition);
    if ("disabled" in $$props2)
      $$invalidate(2, disabled = $$props2.disabled);
    if ("classes" in $$props2)
      $$invalidate(3, classes = $$props2.classes);
    if ("active" in $$props2)
      $$invalidate(4, active = $$props2.active);
    if ("$$scope" in $$props2)
      $$invalidate(5, $$scope = $$props2.$$scope);
  };
  return [
    label,
    tooltipPosition,
    disabled,
    classes,
    active,
    $$scope,
    slots,
    click_handler
  ];
}
var Button = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance35, create_fragment35, safe_not_equal, {
      label: 0,
      tooltipPosition: 1,
      disabled: 2,
      classes: 3,
      active: 4
    });
  }
};
var button_default = Button;

// src/stores/view/subscriptions/effects/align-branch/helpers/reset-zoom.ts
var resetZoom = (container) => {
  const columnsContainer = container.querySelector(".columns");
  columnsContainer.style.transform = "none";
};

// node_modules/tiny-invariant/dist/esm/tiny-invariant.js
var isProduction = false;
var prefix = "Invariant failed";
function invariant(condition, message) {
  if (condition) {
    return;
  }
  if (isProduction) {
    throw new Error(prefix);
  }
  var provided = typeof message === "function" ? message() : message;
  var value = provided ? "".concat(prefix, ": ").concat(provided) : prefix;
  throw new Error(value);
}

// src/stores/view/subscriptions/effects/align-branch/helpers/get-combined-client-rect.ts
var getCombinedBoundingClientRect = (elements) => {
  if (elements.length === 0) {
    return new DOMRect(0, 0, 0, 0);
  }
  let combinedRect = elements[0].getBoundingClientRect();
  for (let i = 1; i < elements.length; i++) {
    const rect = elements[i].getBoundingClientRect();
    combinedRect = combineRects(combinedRect, rect);
  }
  return combinedRect;
};
var combineRects = (rect1, rect2) => {
  const left = Math.min(rect1.left, rect2.left);
  const top = Math.min(rect1.top, rect2.top);
  const right = Math.max(rect1.right, rect2.right);
  const bottom = Math.max(rect1.bottom, rect2.bottom);
  const width = right - left;
  const height = bottom - top;
  return new DOMRect(left, top, width, height);
};

// src/view/components/container/controls-bar/controls-container.svelte
function add_css(target) {
  append_styles(target, "svelte-qjaf0g", ".controls-container.svelte-qjaf0g{right:var(--size-4-2);top:var(--size-4-2);gap:var(--size-4-2);display:flex;flex-direction:column;position:absolute;z-index:2}.controls-toggle.svelte-qjaf0g{display:none}.is-mobile{& .controls-toggle {\n            display: block;\n        };& .buttons-group[data-visible='false'] {\n            display: none;\n        }}");
}
function create_default_slot_9(ctx) {
  let morevertical;
  let current;
  morevertical = new more_vertical_default({ props: { class: "svg-icon" } });
  return {
    c() {
      create_component(morevertical.$$.fragment);
    },
    m(target, anchor) {
      mount_component(morevertical, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(morevertical.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(morevertical.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(morevertical, detaching);
    }
  };
}
function create_default_slot_8(ctx) {
  let settings;
  let current;
  settings = new settings_default({ props: { class: "svg-icon" } });
  return {
    c() {
      create_component(settings.$$.fragment);
    },
    m(target, anchor) {
      mount_component(settings, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(settings.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(settings.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(settings, detaching);
    }
  };
}
function create_default_slot_7(ctx) {
  let keyboard;
  let current;
  keyboard = new keyboard_default({ props: { class: "svg-icon" } });
  return {
    c() {
      create_component(keyboard.$$.fragment);
    },
    m(target, anchor) {
      mount_component(keyboard, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(keyboard.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(keyboard.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(keyboard, detaching);
    }
  };
}
function create_default_slot_6(ctx) {
  let historyicon;
  let current;
  historyicon = new history_default({ props: { class: "svg-icon" } });
  return {
    c() {
      create_component(historyicon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(historyicon, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(historyicon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(historyicon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(historyicon, detaching);
    }
  };
}
function create_default_slot_5(ctx) {
  let undoicon;
  let current;
  undoicon = new undo_2_default({ props: { class: "svg-icon" } });
  return {
    c() {
      create_component(undoicon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(undoicon, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(undoicon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(undoicon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(undoicon, detaching);
    }
  };
}
function create_default_slot_4(ctx) {
  let redoicon;
  let current;
  redoicon = new redo_2_default({ props: { class: "svg-icon" } });
  return {
    c() {
      create_component(redoicon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(redoicon, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(redoicon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(redoicon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(redoicon, detaching);
    }
  };
}
function create_default_slot_3(ctx) {
  let zoomin;
  let current;
  zoomin = new plus_default({ props: { class: "svg-icon" } });
  return {
    c() {
      create_component(zoomin.$$.fragment);
    },
    m(target, anchor) {
      mount_component(zoomin, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(zoomin.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(zoomin.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(zoomin, detaching);
    }
  };
}
function create_default_slot_2(ctx) {
  let rotateccw;
  let current;
  rotateccw = new rotate_ccw_default({ props: { class: "svg-icon" } });
  return {
    c() {
      create_component(rotateccw.$$.fragment);
    },
    m(target, anchor) {
      mount_component(rotateccw, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(rotateccw.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(rotateccw.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(rotateccw, detaching);
    }
  };
}
function create_default_slot_1(ctx) {
  let maximize;
  let current;
  maximize = new maximize_default({ props: { class: "svg-icon" } });
  return {
    c() {
      create_component(maximize.$$.fragment);
    },
    m(target, anchor) {
      mount_component(maximize, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(maximize.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(maximize.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(maximize, detaching);
    }
  };
}
function create_default_slot34(ctx) {
  let zoomout;
  let current;
  zoomout = new minus_default({ props: { class: "svg-icon" } });
  return {
    c() {
      create_component(zoomout.$$.fragment);
    },
    m(target, anchor) {
      mount_component(zoomout, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(zoomout.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(zoomout.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(zoomout, detaching);
    }
  };
}
function create_fragment36(ctx) {
  let div4;
  let div0;
  let button0;
  let t0;
  let div1;
  let button1;
  let t1;
  let button2;
  let t2;
  let div2;
  let button3;
  let t3;
  let button4;
  let t4;
  let button5;
  let t5;
  let div3;
  let button6;
  let t6;
  let button7;
  let t7;
  let button8;
  let t8;
  let button9;
  let current;
  button0 = new button_default({
    props: {
      active: (
        /*$showControls*/
        ctx[0]
      ),
      label: "Toggle controls",
      tooltipPosition: "left",
      $$slots: { default: [create_default_slot_9] },
      $$scope: { ctx }
    }
  });
  button0.$on(
    "click",
    /*toggleShowControls*/
    ctx[17]
  );
  button1 = new button_default({
    props: {
      active: (
        /*$controls*/
        ctx[1].showSettingsSidebar
      ),
      class: "control-item",
      label: "Settings",
      tooltipPosition: "left",
      $$slots: { default: [create_default_slot_8] },
      $$scope: { ctx }
    }
  });
  button1.$on(
    "click",
    /*toggleSettings*/
    ctx[9]
  );
  button2 = new button_default({
    props: {
      active: (
        /*$controls*/
        ctx[1].showHelpSidebar
      ),
      class: "control-item",
      label: "Keyboard shortcuts",
      tooltipPosition: "left",
      $$slots: { default: [create_default_slot_7] },
      $$scope: { ctx }
    }
  });
  button2.$on(
    "click",
    /*toggleHelp*/
    ctx[8]
  );
  button3 = new button_default({
    props: {
      active: (
        /*$controls*/
        ctx[1].showHistorySidebar
      ),
      class: "control-item",
      disabled: (
        /*$history*/
        ctx[2].items.length === 0
      ),
      label: "History",
      tooltipPosition: "left",
      $$slots: { default: [create_default_slot_6] },
      $$scope: { ctx }
    }
  });
  button3.$on(
    "click",
    /*click_handler*/
    ctx[18]
  );
  button4 = new button_default({
    props: {
      class: "control-item",
      disabled: !/*$history*/
      ctx[2].state.canGoBack,
      label: "Undo",
      tooltipPosition: "left",
      $$slots: { default: [create_default_slot_5] },
      $$scope: { ctx }
    }
  });
  button4.$on(
    "click",
    /*handlePreviousClick*/
    ctx[7]
  );
  button5 = new button_default({
    props: {
      class: "control-item",
      disabled: !/*$history*/
      ctx[2].state.canGoForward,
      label: "Redo",
      tooltipPosition: "left",
      $$slots: { default: [create_default_slot_4] },
      $$scope: { ctx }
    }
  });
  button5.$on(
    "click",
    /*handleNextClick*/
    ctx[6]
  );
  button6 = new button_default({
    props: {
      class: "control-item",
      disabled: (
        /*$zoomLevel*/
        ctx[3] === maxZoomLevel
      ),
      label: "zoom in",
      tooltipPosition: "left",
      $$slots: { default: [create_default_slot_3] },
      $$scope: { ctx }
    }
  });
  button6.$on(
    "click",
    /*zoomIn*/
    ctx[10]
  );
  button7 = new button_default({
    props: {
      class: "control-item",
      disabled: (
        /*$zoomLevel*/
        ctx[3] === 1
      ),
      label: "Restore zoom level",
      tooltipPosition: "left",
      $$slots: { default: [create_default_slot_2] },
      $$scope: { ctx }
    }
  });
  button7.$on(
    "click",
    /*restoreZoom*/
    ctx[12]
  );
  button8 = new button_default({
    props: {
      class: "control-item",
      label: "Fit document height into view",
      tooltipPosition: "left",
      $$slots: { default: [create_default_slot_1] },
      $$scope: { ctx }
    }
  });
  button8.$on(
    "click",
    /*fitDocumentHeightIntoView*/
    ctx[13]
  );
  button9 = new button_default({
    props: {
      class: "control-item",
      disabled: (
        /*$zoomLevel*/
        ctx[3] === minZoomLevel
      ),
      label: "Zoom out",
      tooltipPosition: "left",
      $$slots: { default: [create_default_slot34] },
      $$scope: { ctx }
    }
  });
  button9.$on(
    "click",
    /*zoomOut*/
    ctx[11]
  );
  return {
    c() {
      div4 = element("div");
      div0 = element("div");
      create_component(button0.$$.fragment);
      t0 = space();
      div1 = element("div");
      create_component(button1.$$.fragment);
      t1 = space();
      create_component(button2.$$.fragment);
      t2 = space();
      div2 = element("div");
      create_component(button3.$$.fragment);
      t3 = space();
      create_component(button4.$$.fragment);
      t4 = space();
      create_component(button5.$$.fragment);
      t5 = space();
      div3 = element("div");
      create_component(button6.$$.fragment);
      t6 = space();
      create_component(button7.$$.fragment);
      t7 = space();
      create_component(button8.$$.fragment);
      t8 = space();
      create_component(button9.$$.fragment);
      attr(div0, "class", "buttons-group controls-toggle svelte-qjaf0g");
      attr(div1, "class", "buttons-group buttons-group--vertical");
      attr(
        div1,
        "data-visible",
        /*$showControls*/
        ctx[0]
      );
      attr(div2, "class", "buttons-group buttons-group--vertical");
      attr(
        div2,
        "data-visible",
        /*$showControls*/
        ctx[0]
      );
      attr(div3, "class", "buttons-group buttons-group--vertical");
      attr(
        div3,
        "data-visible",
        /*$showControls*/
        ctx[0]
      );
      attr(div4, "class", "controls-container svelte-qjaf0g");
    },
    m(target, anchor) {
      insert(target, div4, anchor);
      append(div4, div0);
      mount_component(button0, div0, null);
      append(div4, t0);
      append(div4, div1);
      mount_component(button1, div1, null);
      append(div1, t1);
      mount_component(button2, div1, null);
      append(div4, t2);
      append(div4, div2);
      mount_component(button3, div2, null);
      append(div2, t3);
      mount_component(button4, div2, null);
      append(div2, t4);
      mount_component(button5, div2, null);
      append(div4, t5);
      append(div4, div3);
      mount_component(button6, div3, null);
      append(div3, t6);
      mount_component(button7, div3, null);
      append(div3, t7);
      mount_component(button8, div3, null);
      append(div3, t8);
      mount_component(button9, div3, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const button0_changes = {};
      if (dirty & /*$showControls*/
      1)
        button0_changes.active = /*$showControls*/
        ctx2[0];
      if (dirty & /*$$scope*/
      4194304) {
        button0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button0.$set(button0_changes);
      const button1_changes = {};
      if (dirty & /*$controls*/
      2)
        button1_changes.active = /*$controls*/
        ctx2[1].showSettingsSidebar;
      if (dirty & /*$$scope*/
      4194304) {
        button1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button1.$set(button1_changes);
      const button2_changes = {};
      if (dirty & /*$controls*/
      2)
        button2_changes.active = /*$controls*/
        ctx2[1].showHelpSidebar;
      if (dirty & /*$$scope*/
      4194304) {
        button2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button2.$set(button2_changes);
      if (!current || dirty & /*$showControls*/
      1) {
        attr(
          div1,
          "data-visible",
          /*$showControls*/
          ctx2[0]
        );
      }
      const button3_changes = {};
      if (dirty & /*$controls*/
      2)
        button3_changes.active = /*$controls*/
        ctx2[1].showHistorySidebar;
      if (dirty & /*$history*/
      4)
        button3_changes.disabled = /*$history*/
        ctx2[2].items.length === 0;
      if (dirty & /*$$scope*/
      4194304) {
        button3_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button3.$set(button3_changes);
      const button4_changes = {};
      if (dirty & /*$history*/
      4)
        button4_changes.disabled = !/*$history*/
        ctx2[2].state.canGoBack;
      if (dirty & /*$$scope*/
      4194304) {
        button4_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button4.$set(button4_changes);
      const button5_changes = {};
      if (dirty & /*$history*/
      4)
        button5_changes.disabled = !/*$history*/
        ctx2[2].state.canGoForward;
      if (dirty & /*$$scope*/
      4194304) {
        button5_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button5.$set(button5_changes);
      if (!current || dirty & /*$showControls*/
      1) {
        attr(
          div2,
          "data-visible",
          /*$showControls*/
          ctx2[0]
        );
      }
      const button6_changes = {};
      if (dirty & /*$zoomLevel*/
      8)
        button6_changes.disabled = /*$zoomLevel*/
        ctx2[3] === maxZoomLevel;
      if (dirty & /*$$scope*/
      4194304) {
        button6_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button6.$set(button6_changes);
      const button7_changes = {};
      if (dirty & /*$zoomLevel*/
      8)
        button7_changes.disabled = /*$zoomLevel*/
        ctx2[3] === 1;
      if (dirty & /*$$scope*/
      4194304) {
        button7_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button7.$set(button7_changes);
      const button8_changes = {};
      if (dirty & /*$$scope*/
      4194304) {
        button8_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button8.$set(button8_changes);
      const button9_changes = {};
      if (dirty & /*$zoomLevel*/
      8)
        button9_changes.disabled = /*$zoomLevel*/
        ctx2[3] === minZoomLevel;
      if (dirty & /*$$scope*/
      4194304) {
        button9_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button9.$set(button9_changes);
      if (!current || dirty & /*$showControls*/
      1) {
        attr(
          div3,
          "data-visible",
          /*$showControls*/
          ctx2[0]
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(button0.$$.fragment, local);
      transition_in(button1.$$.fragment, local);
      transition_in(button2.$$.fragment, local);
      transition_in(button3.$$.fragment, local);
      transition_in(button4.$$.fragment, local);
      transition_in(button5.$$.fragment, local);
      transition_in(button6.$$.fragment, local);
      transition_in(button7.$$.fragment, local);
      transition_in(button8.$$.fragment, local);
      transition_in(button9.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(button0.$$.fragment, local);
      transition_out(button1.$$.fragment, local);
      transition_out(button2.$$.fragment, local);
      transition_out(button3.$$.fragment, local);
      transition_out(button4.$$.fragment, local);
      transition_out(button5.$$.fragment, local);
      transition_out(button6.$$.fragment, local);
      transition_out(button7.$$.fragment, local);
      transition_out(button8.$$.fragment, local);
      transition_out(button9.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div4);
      }
      destroy_component(button0);
      destroy_component(button1);
      destroy_component(button2);
      destroy_component(button3);
      destroy_component(button4);
      destroy_component(button5);
      destroy_component(button6);
      destroy_component(button7);
      destroy_component(button8);
      destroy_component(button9);
    }
  };
}
function instance36($$self, $$props, $$invalidate) {
  let $showControls;
  let $controls;
  let $history;
  let $zoomLevel;
  const view = getView();
  const viewStore = view.viewStore;
  const documentStore = view.documentStore;
  const history = historyStore(view);
  component_subscribe($$self, history, (value) => $$invalidate(2, $history = value));
  const handleNextClick = () => {
    if (viewStore.getValue().document.editing.activeNodeId)
      new import_obsidian.Notice(lang.error_apply_snapshot_while_editing);
    else
      documentStore.dispatch({ type: "HISTORY/APPLY_NEXT_SNAPSHOT" });
  };
  const handlePreviousClick = () => {
    if (viewStore.getValue().document.editing.activeNodeId)
      new import_obsidian.Notice(lang.error_apply_snapshot_while_editing);
    else
      documentStore.dispatch({ type: "HISTORY/APPLY_PREVIOUS_SNAPSHOT" });
  };
  const plugin = getPlugin();
  const toggleHelp = () => {
    viewStore.dispatch({ type: "UI/TOGGLE_HELP_SIDEBAR" });
  };
  const toggleSettings = () => {
    viewStore.dispatch({ type: "UI/TOGGLE_SETTINGS_SIDEBAR" });
  };
  const zoomIn = () => {
    view.plugin.settings.dispatch({
      type: "UI/CHANGE_ZOOM_LEVEL",
      payload: { direction: "in" }
    });
  };
  const zoomOut = () => {
    view.plugin.settings.dispatch({
      type: "UI/CHANGE_ZOOM_LEVEL",
      payload: { direction: "out" }
    });
  };
  const restoreZoom = () => {
    view.plugin.settings.dispatch({
      type: "UI/CHANGE_ZOOM_LEVEL",
      payload: { value: 1 }
    });
  };
  const fitDocumentHeightIntoView = () => {
    invariant(view.container);
    resetZoom(view.container);
    const columns = Array.from(view.containerEl.querySelectorAll(".column"));
    if (columns.length) {
      const groupHeights = columns.map((c) => {
        return getCombinedBoundingClientRect(Array.from(c.querySelectorAll(".group"))).height;
      }).sort((a, b) => a - b);
      const height = groupHeights[groupHeights.length - 1];
      const width = getCombinedBoundingClientRect(columns).width;
      const heightScale = view.container.getBoundingClientRect().height / (height + 100);
      const widthScale = view.container.getBoundingClientRect().width / (width + 100);
      const scale = Math.min(heightScale, widthScale);
      view.plugin.settings.dispatch({
        type: "UI/CHANGE_ZOOM_LEVEL",
        payload: { value: scale }
      });
    }
  };
  const zoomLevel = zoomLevelStore(view);
  component_subscribe($$self, zoomLevel, (value) => $$invalidate(3, $zoomLevel = value));
  const controls = uiControlsStore(view);
  component_subscribe($$self, controls, (value) => $$invalidate(1, $controls = value));
  const showControls = writable(false);
  component_subscribe($$self, showControls, (value) => $$invalidate(0, $showControls = value));
  const toggleShowControls = () => {
    showControls.update((v) => !v);
  };
  const click_handler = () => {
    viewStore.dispatch({ type: "UI/TOGGLE_HISTORY_SIDEBAR" });
  };
  return [
    $showControls,
    $controls,
    $history,
    $zoomLevel,
    viewStore,
    history,
    handleNextClick,
    handlePreviousClick,
    toggleHelp,
    toggleSettings,
    zoomIn,
    zoomOut,
    restoreZoom,
    fitDocumentHeightIntoView,
    zoomLevel,
    controls,
    showControls,
    toggleShowControls,
    click_handler
  ];
}
var Controls_container = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance36, create_fragment36, safe_not_equal, {}, add_css);
  }
};
var controls_container_default = Controls_container;

// src/lib/tree-utils/get/traverse-down.ts
var traverseDown = (childGroups, columns, nodeId, columnIndex = 0) => {
  for (let i = columnIndex; i < columns.length; i++) {
    const column = columns[i];
    for (const group of column.groups) {
      if (group.parentId === nodeId) {
        if (!nodeId.startsWith("-r"))
          childGroups.push(nodeId);
        for (const childNodeId of group.nodes) {
          traverseDown(
            childGroups,
            columns,
            childNodeId,
            columnIndex + 1
          );
        }
      }
    }
  }
};

// src/view/actions/dnd/draggable.ts
var toggleDraggedNodeVisibility = (node, data, visible) => {
  requestAnimationFrame(() => {
    const parent = node.matchParent("#" + data.id);
    if (parent) {
      parent.style.display = visible ? "flex" : "none";
    }
  });
};
var draggable = (node, data) => {
  node.draggable = true;
  const handleDragstart = (event) => {
    if (!event.dataTransfer)
      return;
    const target = event.currentTarget;
    if (event.clientX - target.getBoundingClientRect().x <= 7 || target.dataset["test"] === "true") {
      event.dataTransfer.setData("text/plain", data.id);
      setTimeout(() => {
        const childGroups = [];
        traverseDown(
          childGroups,
          data.documentStore.getValue().document.columns,
          data.id
        );
        data.viewStore.dispatch({
          type: "SET_DRAG_STARTED",
          payload: { nodeId: data.id, childGroups }
        });
        toggleDraggedNodeVisibility(node, data, false);
      }, 0);
    } else {
      event.preventDefault();
    }
  };
  node.addEventListener("dragstart", handleDragstart);
  const handleDragEnd = () => {
    data.viewStore.dispatch({ type: "DOCUMENT/SET_DRAG_ENDED" });
    toggleDraggedNodeVisibility(node, data, true);
  };
  node.addEventListener("dragend", handleDragEnd);
  return {
    destroy: () => {
      node.removeEventListener("dragstart", handleDragstart);
      node.removeEventListener("dragend", handleDragEnd);
    }
  };
};

// src/view/components/container/column/components/group/components/card/components/dnd/draggable.svelte
function add_css2(target) {
  append_styles(target, "svelte-id8vtx", ".draggable.svelte-id8vtx.svelte-id8vtx{width:100%;background-color:transparent;display:flex;position:relative}.drag-handle.svelte-id8vtx.svelte-id8vtx{height:100%;width:6px;background-color:transparent;cursor:grab;position:absolute;left:0;z-index:1}.draggable.svelte-id8vtx:hover .drag-handle.svelte-id8vtx{background-size:2px 4px;background-image:linear-gradient(\n            0deg,\n            hsla(0, 0%, 44.7%, 0.25) 20%,\n            transparent 40%\n        )}.content.svelte-id8vtx.svelte-id8vtx{width:100%\n    }");
}
function create_fragment37(ctx) {
  let div2;
  let div0;
  let t;
  let div1;
  let draggable_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      div2 = element("div");
      div0 = element("div");
      t = space();
      div1 = element("div");
      if (default_slot)
        default_slot.c();
      attr(div0, "class", "drag-handle svelte-id8vtx");
      attr(div1, "class", "content svelte-id8vtx");
      attr(div2, "class", "draggable svelte-id8vtx");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div0);
      append(div2, t);
      append(div2, div1);
      if (default_slot) {
        default_slot.m(div1, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            div1,
            "dblclick",
            /*dblclick_handler*/
            ctx[5]
          ),
          action_destroyer(draggable_action = draggable.call(null, div2, {
            id: (
              /*nodeId*/
              ctx[0]
            ),
            documentStore: (
              /*documentStore*/
              ctx[1]
            ),
            viewStore: (
              /*viewStore*/
              ctx[2]
            )
          }))
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (draggable_action && is_function(draggable_action.update) && dirty & /*nodeId*/
      1)
        draggable_action.update.call(null, {
          id: (
            /*nodeId*/
            ctx2[0]
          ),
          documentStore: (
            /*documentStore*/
            ctx2[1]
          ),
          viewStore: (
            /*viewStore*/
            ctx2[2]
          )
        });
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance37($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { nodeId } = $$props;
  const view = getView();
  const documentStore = view.documentStore;
  const viewStore = view.viewStore;
  const dblclick_handler = () => {
    viewStore.dispatch({
      type: "DOCUMENT/ENABLE_EDIT_MODE",
      payload: { nodeId }
    });
  };
  $$self.$$set = ($$props2) => {
    if ("nodeId" in $$props2)
      $$invalidate(0, nodeId = $$props2.nodeId);
    if ("$$scope" in $$props2)
      $$invalidate(3, $$scope = $$props2.$$scope);
  };
  return [nodeId, documentStore, viewStore, $$scope, slots, dblclick_handler];
}
var Draggable = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance37, create_fragment37, safe_not_equal, { nodeId: 0 }, add_css2);
  }
};
var draggable_default = Draggable;

// src/view/actions/dnd/droppable.ts
var getDropPosition = (event, targetElement) => {
  const boundingBox = targetElement.getBoundingClientRect();
  const mouseX = event.clientX;
  const mouseY = event.clientY;
  if (mouseY - boundingBox.top < boundingBox.height / 4) {
    return "up";
  } else if (boundingBox.bottom - mouseY < boundingBox.height / 4)
    return "down";
  else if (boundingBox.right - mouseX < boundingBox.width / 4)
    return "right";
};
var dropClasses = {
  up: "lineage__drop-node-above",
  down: "lineage__drop-node-below",
  right: "lineage__drop-node-under"
};
var classesList = Object.values(dropClasses);
var droppable = (node, { documentStore, viewStore }) => {
  function HandleDragLeave(event) {
    if (!(event.currentTarget instanceof HTMLElement))
      return;
    event.currentTarget.removeClasses(classesList);
    event.currentTarget.removeClass("inactive-node-hover");
  }
  const handleDragOver = (event) => {
    event.preventDefault();
    if (!event.dataTransfer)
      return;
    const targetCard = event.currentTarget;
    if (!targetCard.id.startsWith("n"))
      return;
    event.dataTransfer.dropEffect = "move";
    const position = getDropPosition(event, targetCard);
    targetCard.removeClasses(classesList);
    if (position) {
      targetCard.addClass(dropClasses[position]);
      if (targetCard.hasClass("inactive-node"))
        targetCard.addClass("inactive-node-hover");
    }
  };
  function handleDrop(event) {
    event.preventDefault();
    if (!(event.currentTarget instanceof HTMLElement))
      return;
    if (!event.dataTransfer)
      return;
    const data = event.dataTransfer.getData("text/plain");
    const targetCard = event.currentTarget;
    if (!targetCard.id.startsWith("n"))
      return;
    targetCard.removeClasses(classesList);
    targetCard.removeClass("inactive-node-hover");
    if (!data)
      throw new Error(`droppedNodeId is missing`);
    if (!targetCard.id)
      throw new Error(`targetCard.id is missing`);
    documentStore.dispatch({
      type: "DOCUMENT/DROP_NODE",
      payload: {
        droppedNodeId: data,
        targetNodeId: targetCard.id,
        position: getDropPosition(event, targetCard)
      }
    });
    viewStore.dispatch({
      type: "DOCUMENT/SET_DRAG_ENDED"
    });
  }
  node.addEventListener("dragleave", HandleDragLeave);
  node.addEventListener("dragover", handleDragOver);
  node.addEventListener("drop", handleDrop);
  return {
    destroy() {
      node.removeEventListener("dragleave", HandleDragLeave);
      node.removeEventListener("dragover", handleDragOver);
      node.removeEventListener("drop", handleDrop);
    }
  };
};

// src/view/components/container/column/components/group/components/card/components/bridges/bridges.svelte
function add_css3(target) {
  append_styles(target, "svelte-aqw235", ".active-node-bridge.svelte-aqw235,.active-parent-bridge-right.svelte-aqw235,.active-parent-bridge-left.svelte-aqw235{height:100%;width:10px;position:absolute;top:0}.active-parent-bridge-right.svelte-aqw235{right:-10px;background-color:var(--background-active-parent)}.active-parent-bridge-left.svelte-aqw235{left:-10px;background-color:var(--background-active-parent)}.active-node-bridge.svelte-aqw235{right:-10px;background-color:var(--background-active-node)}");
}
function create_if_block_1(ctx) {
  let div;
  let div_class_value;
  let t;
  let show_if = !/*parentId*/
  ctx[3].startsWith("r");
  let if_block_anchor;
  let if_block = show_if && create_if_block_2(ctx);
  return {
    c() {
      div = element("div");
      t = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      attr(div, "class", div_class_value = null_to_empty("active-parent-bridge-right") + " svelte-aqw235");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      insert(target, t, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*parentId*/
      8)
        show_if = !/*parentId*/
        ctx2[3].startsWith("r");
      if (show_if) {
        if (if_block) {
        } else {
          if_block = create_if_block_2(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div);
        detach(t);
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function create_if_block(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      attr(div, "class", "active-node-bridge svelte-aqw235");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
function create_if_block_2(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      attr(div, "class", "active-parent-bridge-left svelte-aqw235");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
function create_fragment38(ctx) {
  let if_block_anchor;
  function select_block_type(ctx2, dirty) {
    if (!/*editing*/
    ctx2[0] && /*hasChildren*/
    ctx2[1] && /*active*/
    ctx2[2] === "node" /* node */)
      return create_if_block;
    if (
      /*active*/
      ctx2[2] === "parent" /* parent */
    )
      return create_if_block_1;
  }
  let current_block_type = select_block_type(ctx, -1);
  let if_block = current_block_type && current_block_type(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, [dirty]) {
      if (current_block_type === (current_block_type = select_block_type(ctx2, dirty)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if (if_block)
          if_block.d(1);
        if_block = current_block_type && current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block) {
        if_block.d(detaching);
      }
    }
  };
}
function instance38($$self, $$props, $$invalidate) {
  let { editing } = $$props;
  let { hasChildren } = $$props;
  let { active } = $$props;
  let { parentId } = $$props;
  $$self.$$set = ($$props2) => {
    if ("editing" in $$props2)
      $$invalidate(0, editing = $$props2.editing);
    if ("hasChildren" in $$props2)
      $$invalidate(1, hasChildren = $$props2.hasChildren);
    if ("active" in $$props2)
      $$invalidate(2, active = $$props2.active);
    if ("parentId" in $$props2)
      $$invalidate(3, parentId = $$props2.parentId);
  };
  return [editing, hasChildren, active, parentId];
}
var Bridges = class extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance38,
      create_fragment38,
      safe_not_equal,
      {
        editing: 0,
        hasChildren: 1,
        active: 2,
        parentId: 3
      },
      add_css3
    );
  }
};
var bridges_default = Bridges;

// src/view/components/container/column/components/group/components/card/components/dnd/droppable.svelte
var import_classnames = __toESM(require_classnames());

// src/view/actions/keyboard-shortcuts/helpers/keyboard-events/mod-key.ts
var import_obsidian2 = require("obsidian");
var isMacLike = import_obsidian2.Platform.isMacOS || import_obsidian2.Platform.isIosApp;
var modKey = isMacLike ? "Cmd" : "Ctrl";

// src/view/components/container/column/components/group/components/card/components/dnd/droppable.svelte
function add_css4(target) {
  append_styles(target, "svelte-7s9glw", ":root{--node-width:400px;--min-node-height:100px}.lineage-card.svelte-7s9glw{width:var(--node-width);height:fit-content;display:flex;position:relative;font-size:16px;--scrollbar-thumb-bg:var(--color-base-30);--scrollbar-active-thumb-bg:var(--color-base-40)}.lineage-card.svelte-7s9glw::-webkit-scrollbar{display:initial}.node-border--active.svelte-7s9glw{border-left:5px var(--lineage-accent) solid}.node-border--editing.svelte-7s9glw{border-left:5px var(--color-base-70) solid}.node-border--discard.svelte-7s9glw{border-left:5px var(--color-red) solid}.node-border--selected.svelte-7s9glw{border-left:5px var(--lineage-color-selection) solid}");
}
function create_fragment39(ctx) {
  let div;
  let t;
  let bridges;
  let div_class_value;
  let droppable_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[12].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[11],
    null
  );
  bridges = new bridges_default({
    props: {
      active: (
        /*active*/
        ctx[1]
      ),
      editing: (
        /*editing*/
        ctx[4]
      ),
      hasChildren: (
        /*hasChildren*/
        ctx[2]
      ),
      parentId: (
        /*parentId*/
        ctx[3]
      )
    }
  });
  return {
    c() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      t = space();
      create_component(bridges.$$.fragment);
      attr(div, "class", div_class_value = null_to_empty((0, import_classnames.default)(
        "lineage-card",
        /*active*/
        ctx[1] ? (
          /*activeStatusClasses*/
          ctx[10][
            /*active*/
            ctx[1]
          ]
        ) : " inactive-node",
        /*disableEditConfirmation*/
        ctx[5] ? "node-border--discard" : (
          /*editing*/
          ctx[4] ? "node-border--editing" : (
            /*selected*/
            ctx[6] ? "node-border--selected" : (
              /*active*/
              ctx[1] === "node" /* node */ ? "node-border--active" : void 0
            )
          )
        )
      )) + " svelte-7s9glw");
      attr(
        div,
        "id",
        /*nodeId*/
        ctx[0]
      );
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      append(div, t);
      mount_component(bridges, div, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            div,
            "click",
            /*setActive*/
            ctx[7]
          ),
          listen(
            div,
            "dblclick",
            /*dblclick_handler*/
            ctx[13]
          ),
          action_destroyer(droppable_action = droppable.call(null, div, {
            viewStore: (
              /*viewStore*/
              ctx[9]
            ),
            documentStore: (
              /*documentStore*/
              ctx[8]
            )
          }))
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        2048)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[11],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[11]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[11],
              dirty,
              null
            ),
            null
          );
        }
      }
      const bridges_changes = {};
      if (dirty & /*active*/
      2)
        bridges_changes.active = /*active*/
        ctx2[1];
      if (dirty & /*editing*/
      16)
        bridges_changes.editing = /*editing*/
        ctx2[4];
      if (dirty & /*hasChildren*/
      4)
        bridges_changes.hasChildren = /*hasChildren*/
        ctx2[2];
      if (dirty & /*parentId*/
      8)
        bridges_changes.parentId = /*parentId*/
        ctx2[3];
      bridges.$set(bridges_changes);
      if (!current || dirty & /*active, disableEditConfirmation, editing, selected*/
      114 && div_class_value !== (div_class_value = null_to_empty((0, import_classnames.default)(
        "lineage-card",
        /*active*/
        ctx2[1] ? (
          /*activeStatusClasses*/
          ctx2[10][
            /*active*/
            ctx2[1]
          ]
        ) : " inactive-node",
        /*disableEditConfirmation*/
        ctx2[5] ? "node-border--discard" : (
          /*editing*/
          ctx2[4] ? "node-border--editing" : (
            /*selected*/
            ctx2[6] ? "node-border--selected" : (
              /*active*/
              ctx2[1] === "node" /* node */ ? "node-border--active" : void 0
            )
          )
        )
      )) + " svelte-7s9glw")) {
        attr(div, "class", div_class_value);
      }
      if (!current || dirty & /*nodeId*/
      1) {
        attr(
          div,
          "id",
          /*nodeId*/
          ctx2[0]
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      transition_in(bridges.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      transition_out(bridges.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (default_slot)
        default_slot.d(detaching);
      destroy_component(bridges);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance39($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { nodeId } = $$props;
  let { active } = $$props;
  let { hasChildren } = $$props;
  let { parentId } = $$props;
  let { editing } = $$props;
  let { disableEditConfirmation } = $$props;
  let { selected } = $$props;
  const setActive = (e) => {
    if (!editing)
      viewStore.dispatch({
        type: "DOCUMENT/SET_ACTIVE_NODE",
        payload: { id: nodeId },
        context: {
          modKey: isMacLike ? e.metaKey : e.ctrlKey,
          source: "mouse"
        }
      });
  };
  const view = getView();
  const documentStore = view.documentStore;
  const viewStore = view.viewStore;
  const activeStatusClasses = {
    ["node" /* node */]: "active-node",
    ["child" /* child */]: "active-child",
    ["parent" /* parent */]: "active-parent",
    ["sibling" /* sibling */]: "active-sibling"
  };
  const dblclick_handler = (e) => {
    setActive(e);
    viewStore.dispatch({
      type: "DOCUMENT/ENABLE_EDIT_MODE",
      payload: { nodeId }
    });
  };
  $$self.$$set = ($$props2) => {
    if ("nodeId" in $$props2)
      $$invalidate(0, nodeId = $$props2.nodeId);
    if ("active" in $$props2)
      $$invalidate(1, active = $$props2.active);
    if ("hasChildren" in $$props2)
      $$invalidate(2, hasChildren = $$props2.hasChildren);
    if ("parentId" in $$props2)
      $$invalidate(3, parentId = $$props2.parentId);
    if ("editing" in $$props2)
      $$invalidate(4, editing = $$props2.editing);
    if ("disableEditConfirmation" in $$props2)
      $$invalidate(5, disableEditConfirmation = $$props2.disableEditConfirmation);
    if ("selected" in $$props2)
      $$invalidate(6, selected = $$props2.selected);
    if ("$$scope" in $$props2)
      $$invalidate(11, $$scope = $$props2.$$scope);
  };
  return [
    nodeId,
    active,
    hasChildren,
    parentId,
    editing,
    disableEditConfirmation,
    selected,
    setActive,
    documentStore,
    viewStore,
    activeStatusClasses,
    $$scope,
    slots,
    dblclick_handler
  ];
}
var Droppable = class extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance39,
      create_fragment39,
      safe_not_equal,
      {
        nodeId: 0,
        active: 1,
        hasChildren: 2,
        parentId: 3,
        editing: 4,
        disableEditConfirmation: 5,
        selected: 6
      },
      add_css4
    );
  }
};
var droppable_default = Droppable;

// src/view/actions/inline-editor/load-inline-editor.ts
var loadInlineEditor = (target, { nodeId, view }) => {
  if (!view.file)
    return;
  view.inlineEditor.loadNode(target, nodeId);
  return {
    destroy: () => {
      if (view.inlineEditor.activeNode === nodeId) {
        view.documentStore.dispatch({
          type: "DOCUMENT/SET_NODE_CONTENT",
          payload: {
            nodeId,
            content: view.inlineEditor.getContent()
          }
        });
        view.inlineEditor.unloadNode();
      }
    }
  };
};

// src/view/actions/inline-editor/expandable-textarea-action.ts
var deletionKeys = /* @__PURE__ */ new Set(["Backspace", "Delete", "x", " "]);
var AdjustHeight = (el) => {
  let previousScrollHeight = 0;
  let x;
  return (e) => {
    if (!x) {
      x = el.querySelector(".cm-scroller");
    }
    if (!x)
      return;
    requestAnimationFrame(() => {
      if (x.scrollHeight !== previousScrollHeight || e && deletionKeys.has(e.key)) {
        x.style.height = "auto";
        previousScrollHeight = x.scrollHeight;
        el.style.height = previousScrollHeight + "px";
        x.style.height = "";
      }
    });
  };
};
var expandableTextareaAction = (el) => {
  const adjustHeight = AdjustHeight(el);
  el.addEventListener("keydown", adjustHeight);
  return {
    destroy: () => {
      el.removeEventListener("keydown", adjustHeight);
    }
  };
};

// src/view/components/container/column/components/group/components/card/components/content/inline-editor.svelte
function add_css5(target) {
  append_styles(target, "svelte-1y50rwn", ".editor-container.svelte-1y50rwn{width:100%;min-height:var(--min-node-height);height:fit-content;overflow:hidden;display:flex}");
}
function create_fragment40(ctx) {
  let div;
  let expandableTextareaAction_action;
  let loadInlineEditor_action;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      div.innerHTML = ``;
      attr(div, "class", "editor-container svelte-1y50rwn");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (!mounted) {
        dispose = [
          action_destroyer(expandableTextareaAction_action = expandableTextareaAction.call(null, div)),
          action_destroyer(loadInlineEditor_action = loadInlineEditor.call(null, div, {
            nodeId: (
              /*nodeId*/
              ctx[0]
            ),
            view: (
              /*view*/
              ctx[1]
            )
          }))
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (loadInlineEditor_action && is_function(loadInlineEditor_action.update) && dirty & /*nodeId*/
      1)
        loadInlineEditor_action.update.call(null, {
          nodeId: (
            /*nodeId*/
            ctx2[0]
          ),
          view: (
            /*view*/
            ctx2[1]
          )
        });
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance40($$self, $$props, $$invalidate) {
  let { nodeId } = $$props;
  const view = getView();
  $$self.$$set = ($$props2) => {
    if ("nodeId" in $$props2)
      $$invalidate(0, nodeId = $$props2.nodeId);
  };
  return [nodeId, view];
}
var Inline_editor = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance40, create_fragment40, safe_not_equal, { nodeId: 0 }, add_css5);
  }
};
var inline_editor_default = Inline_editor;

// src/view/actions/markdown-preview-action.ts
var import_obsidian3 = require("obsidian");

// src/stores/document/derived/content-store.ts
var contentStore = (view, nodeId) => {
  let nodeContent;
  let documentContent;
  return derived(view.documentStore, (state2) => {
    if (!nodeContent || documentContent !== state2.document.content || nodeContent !== documentContent[nodeId]) {
      documentContent = state2.document.content;
      nodeContent = documentContent[nodeId];
      if (!nodeContent)
        return "";
    }
    return nodeContent.content;
  });
};
var documentContentStore = (view) => {
  return derived(view.documentStore, (state2) => {
    return state2.document.content;
  });
};

// src/view/actions/markdown-preview-action.ts
var markdownPreviewAction = (element2, nodeId) => {
  const plugin = getPlugin();
  const view = getView();
  const store = view.documentStore;
  const render = (content) => {
    if (view && element2) {
      element2.empty();
      if (content.length > 0) {
        const hasCallout = /^> /gm.test(content);
        if (!hasCallout)
          content = content.replace(/^$/gm, "&nbsp;");
        content = content.replace(
          /\s+(\^[a-zA-Z0-9]{4,})$/gm,
          '<sup class="cm-blockid" data-block-id="$1">$1</sup>'
        );
      }
      import_obsidian3.MarkdownRenderer.render(
        plugin.app,
        content,
        element2,
        store.getValue().file.path,
        view
      );
    }
  };
  const $content = contentStore(view, nodeId);
  const unsub = $content.subscribe((content) => {
    render(content);
  });
  return {
    destroy: () => {
      unsub();
    }
  };
};

// src/view/components/container/column/components/group/components/card/components/content/event-handlers/handle-links.ts
var selectCard = (view, id2) => {
  view.viewStore.dispatch({
    type: "DOCUMENT/SET_ACTIVE_NODE",
    payload: {
      id: id2
    }
  });
};
var handleFile = (view, link) => {
  const path = view.documentStore.getValue().file.path;
  if (link && path) {
    view.plugin.app.workspace.openLinkText(link, path, "split");
  }
};
var handleHeading = (view, link) => {
  const levelMatch = /(#+)/.exec(link);
  if (levelMatch) {
    for (let level2 = 1; level2 <= 6; level2++) {
      const headings = Array.from(
        view.containerEl.querySelectorAll("h" + level2)
      );
      const heading = headings.find(
        (h) => "#" + h.dataset.heading === link
      );
      if (heading) {
        const card = heading.closest(".lineage-card");
        if (card && card.id) {
          selectCard(view, card.id);
          break;
        }
      }
    }
  }
};
var handleBlockLink = (view, link) => {
  const match = /#\^([a-zA-Z0-9]{4,})$/.exec(link);
  if (match) {
    const id2 = match[1];
    if (id2) {
      const element2 = view.containerEl.querySelector(
        `[data-block-id="^${id2}"`
      );
      if (element2) {
        const card = element2.closest(".lineage-card");
        if (card && card.id) {
          selectCard(view, card.id);
        }
      }
    }
  }
};
var handleClick = (view) => (e) => {
  if (!(e.target instanceof HTMLAnchorElement))
    return;
  if (!e.target.hasClass("internal-link"))
    return;
  const link = e.target.dataset.href;
  if (!link)
    return;
  if (link.contains("#^")) {
    e.stopPropagation();
    handleBlockLink(view, link);
  } else if (link.startsWith("#")) {
    e.stopPropagation();
    handleHeading(view, link);
  } else {
    handleFile(view, link);
  }
};

// src/view/components/container/column/components/group/components/card/components/content/content.svelte
function add_css6(target) {
  append_styles(target, "svelte-1acdsm2", ".preview-container.svelte-1acdsm2{width:100%;min-height:var(--min-node-height);font-size:var(--font-text-size);padding:6px 6px 6px 12px;color-scheme:light}");
}
function create_fragment41(ctx) {
  let div;
  let div_class_value;
  let markdownPreviewAction_action;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      attr(div, "class", div_class_value = null_to_empty("preview-container markdown-preview-view markdown-preview-section ") + " svelte-1acdsm2");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (!mounted) {
        dispose = [
          listen(
            div,
            "click",
            /*onClick*/
            ctx[1]
          ),
          action_destroyer(markdownPreviewAction_action = markdownPreviewAction.call(
            null,
            div,
            /*nodeId*/
            ctx[0]
          ))
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (markdownPreviewAction_action && is_function(markdownPreviewAction_action.update) && dirty & /*nodeId*/
      1)
        markdownPreviewAction_action.update.call(
          null,
          /*nodeId*/
          ctx2[0]
        );
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance41($$self, $$props, $$invalidate) {
  let { nodeId } = $$props;
  const view = getView();
  const onClick = handleClick(view);
  $$self.$$set = ($$props2) => {
    if ("nodeId" in $$props2)
      $$invalidate(0, nodeId = $$props2.nodeId);
  };
  return [nodeId, onClick];
}
var Content = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance41, create_fragment41, safe_not_equal, { nodeId: 0 }, add_css6);
  }
};
var content_default = Content;

// src/view/components/container/column/components/group/components/card/components/card-buttons/floating-button.svelte
var import_classnames2 = __toESM(require_classnames());
function add_css7(target) {
  append_styles(target, "svelte-fdem69", ":root{--floating-button-width:30px;--floating-button-height:30px;--floating-button-bg:#dbdbdb;--position-tb:-10px;--position-lr:-4px}button.svelte-fdem69{color:var(--color-acive-node) !important;width:var(--floating-button-width);height:var(--floating-button-height);position:absolute;opacity:0;box-shadow:none;border:none;background-color:transparent;transition:opacity 200ms;padding:8px !important;cursor:pointer}.is-disabled.svelte-fdem69{cursor:not-allowed}button.svelte-fdem69:not(.is-disabled):hover{opacity:0.8}.is-mobile{& button {\n            opacity: 0.8;\n        }}.position-top.svelte-fdem69{top:var(--position-tb);left:calc(50% - calc(var(--floating-button-width) / 2))}.position-bottom.svelte-fdem69{bottom:var(--position-tb);left:calc(50% - calc(var(--floating-button-width) / 2))}.position-right.svelte-fdem69{top:calc(50% - calc(var(--floating-button-height) / 2));right:var(--position-lr)}.position-bottom-right.svelte-fdem69{top:var(--position-lr);right:var(--position-lr)}.position-top-right.svelte-fdem69{top:var(--position-lr);right:16px}");
}
function create_fragment42(ctx) {
  let button;
  let button_class_value;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    null
  );
  return {
    c() {
      button = element("button");
      if (default_slot)
        default_slot.c();
      attr(
        button,
        "aria-label",
        /*label*/
        ctx[2]
      );
      attr(button, "class", button_class_value = null_to_empty((0, import_classnames2.default)(
        /*classes*/
        ctx[0],
        /*positionClasses*/
        ctx[3][
          /*position*/
          ctx[1]
        ],
        "lineage-floating-button"
      )) + " svelte-fdem69");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (default_slot) {
        default_slot.m(button, null);
      }
      current = true;
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*click_handler*/
          ctx[6]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*label*/
      4) {
        attr(
          button,
          "aria-label",
          /*label*/
          ctx2[2]
        );
      }
      if (!current || dirty & /*classes, position*/
      3 && button_class_value !== (button_class_value = null_to_empty((0, import_classnames2.default)(
        /*classes*/
        ctx2[0],
        /*positionClasses*/
        ctx2[3][
          /*position*/
          ctx2[1]
        ],
        "lineage-floating-button"
      )) + " svelte-fdem69")) {
        attr(button, "class", button_class_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
}
function instance42($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { classes = "" } = $$props;
  let { position } = $$props;
  let { label } = $$props;
  const positionClasses = {
    up: "position-top",
    right: "position-right",
    down: "position-bottom",
    "down-right": "position-bottom-right",
    "up-right": "position-top-right"
  };
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("classes" in $$props2)
      $$invalidate(0, classes = $$props2.classes);
    if ("position" in $$props2)
      $$invalidate(1, position = $$props2.position);
    if ("label" in $$props2)
      $$invalidate(2, label = $$props2.label);
    if ("$$scope" in $$props2)
      $$invalidate(4, $$scope = $$props2.$$scope);
  };
  return [classes, position, label, positionClasses, $$scope, slots, click_handler];
}
var Floating_button = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance42, create_fragment42, safe_not_equal, { classes: 0, position: 1, label: 2 }, add_css7);
  }
};
var floating_button_default = Floating_button;

// src/view/components/container/column/components/group/components/card/components/card-buttons/delete-node-button.svelte
function create_default_slot35(ctx) {
  let trashicon;
  let current;
  trashicon = new trash_default({ props: { class: "svg-con" } });
  return {
    c() {
      create_component(trashicon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(trashicon, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(trashicon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(trashicon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(trashicon, detaching);
    }
  };
}
function create_fragment43(ctx) {
  let floatingbutton;
  let current;
  floatingbutton = new floating_button_default({
    props: {
      label: "Delete",
      position: "up-right",
      $$slots: { default: [create_default_slot35] },
      $$scope: { ctx }
    }
  });
  floatingbutton.$on(
    "click",
    /*deleteNode*/
    ctx[0]
  );
  return {
    c() {
      create_component(floatingbutton.$$.fragment);
    },
    m(target, anchor) {
      mount_component(floatingbutton, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const floatingbutton_changes = {};
      if (dirty & /*$$scope*/
      16) {
        floatingbutton_changes.$$scope = { dirty, ctx: ctx2 };
      }
      floatingbutton.$set(floatingbutton_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(floatingbutton.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(floatingbutton.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(floatingbutton, detaching);
    }
  };
}
function instance43($$self, $$props, $$invalidate) {
  let { nodeId } = $$props;
  const view = getView();
  const documentStore = view.documentStore;
  const deleteNode2 = (e) => {
    e.stopPropagation();
    documentStore.dispatch({
      type: "DOCUMENT/DELETE_NODE",
      payload: { activeNodeId: nodeId }
    });
  };
  $$self.$$set = ($$props2) => {
    if ("nodeId" in $$props2)
      $$invalidate(1, nodeId = $$props2.nodeId);
  };
  return [deleteNode2, nodeId];
}
var Delete_node_button = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance43, create_fragment43, safe_not_equal, { nodeId: 1 });
  }
};
var delete_node_button_default = Delete_node_button;

// src/view/actions/keyboard-shortcuts/helpers/commands/commands/helpers/cancel-changes.ts
var discardChanges = (view) => {
  view.inlineEditor.unloadNode();
};
var cancelChanges = (view) => {
  if (view.viewStore.getValue().document.editing.disableEditConfirmation) {
    discardChanges(view);
    view.viewStore.dispatch({
      type: "DOCUMENT/DISABLE_EDIT_MODE"
    });
  } else {
    view.inlineEditor.onNextChange(() => {
      view.viewStore.dispatch({
        type: "DOCUMENT/RESET_DISABLE_EDIT_CONFIRMATION"
      });
    });
    view.viewStore.dispatch({
      type: "DOCUMENT/CONFIRM_DISABLE_EDIT"
    });
  }
};

// src/view/actions/keyboard-shortcuts/helpers/commands/commands/helpers/save-node-content.ts
var saveNodeContent = (view) => {
  if (view.inlineEditor.activeNode) {
    const content = view.inlineEditor.getContent();
    const nodeId = view.inlineEditor.activeNode;
    invariant(nodeId);
    discardChanges(view);
    view.viewStore.dispatch({
      type: "DOCUMENT/DISABLE_EDIT_MODE"
    });
    view.documentStore.dispatch({
      type: "DOCUMENT/SET_NODE_CONTENT",
      payload: {
        nodeId,
        content
      }
    });
  }
};

// src/view/components/container/column/components/group/components/card/components/card-buttons/edit-node-button.svelte
function create_else_block(ctx) {
  let pencilicon;
  let current;
  pencilicon = new pencil_default({ props: { class: "svg-icon" } });
  return {
    c() {
      create_component(pencilicon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(pencilicon, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(pencilicon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(pencilicon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(pencilicon, detaching);
    }
  };
}
function create_if_block2(ctx) {
  let saveicon;
  let current;
  saveicon = new save_default({ props: { class: "svg-con" } });
  return {
    c() {
      create_component(saveicon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(saveicon, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(saveicon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(saveicon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(saveicon, detaching);
    }
  };
}
function create_default_slot36(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block2, create_else_block];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*editing*/
      ctx2[0]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index !== previous_block_index) {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
}
function create_fragment44(ctx) {
  let floatingbutton;
  let current;
  floatingbutton = new floating_button_default({
    props: {
      label: (
        /*editing*/
        ctx[0] ? "Save" : "Edit"
      ),
      position: "down-right",
      $$slots: { default: [create_default_slot36] },
      $$scope: { ctx }
    }
  });
  floatingbutton.$on(
    "click",
    /*toggleEdit*/
    ctx[1]
  );
  return {
    c() {
      create_component(floatingbutton.$$.fragment);
    },
    m(target, anchor) {
      mount_component(floatingbutton, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const floatingbutton_changes = {};
      if (dirty & /*editing*/
      1)
        floatingbutton_changes.label = /*editing*/
        ctx2[0] ? "Save" : "Edit";
      if (dirty & /*$$scope, editing*/
      33) {
        floatingbutton_changes.$$scope = { dirty, ctx: ctx2 };
      }
      floatingbutton.$set(floatingbutton_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(floatingbutton.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(floatingbutton.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(floatingbutton, detaching);
    }
  };
}
function instance44($$self, $$props, $$invalidate) {
  let { editing } = $$props;
  let { nodeId } = $$props;
  const view = getView();
  const viewStore = view.viewStore;
  const toggleEdit = (e) => {
    e.stopPropagation();
    if (editing) {
      saveNodeContent(view);
    } else {
      viewStore.dispatch({
        type: "DOCUMENT/ENABLE_EDIT_MODE",
        payload: { nodeId }
      });
    }
  };
  $$self.$$set = ($$props2) => {
    if ("editing" in $$props2)
      $$invalidate(0, editing = $$props2.editing);
    if ("nodeId" in $$props2)
      $$invalidate(2, nodeId = $$props2.nodeId);
  };
  return [editing, toggleEdit, nodeId];
}
var Edit_node_button = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance44, create_fragment44, safe_not_equal, { editing: 0, nodeId: 2 });
  }
};
var edit_node_button_default = Edit_node_button;

// src/view/actions/keyboard-shortcuts/helpers/commands/commands/helpers/is-editing.ts
var isEditing = (view) => {
  return !!view.viewStore.getValue().document.editing.activeNodeId;
};
var isActive = (view) => {
  return !!view.viewStore.getValue().document.activeNode;
};
var isActiveAndNotEditing = (view) => {
  return isActive(view) && !isEditing(view);
};
var isActiveAndEditing = (view) => {
  return isActive(view) && isEditing(view);
};
var isActiveAndNotEditingAndHasFile = (view) => {
  return isActiveAndNotEditing(view) && !!view.documentStore.getValue().file.path;
};

// src/view/actions/keyboard-shortcuts/helpers/commands/commands/helpers/save-node-and-insert-node.ts
var saveNodeAndInsertNode = (view, direction, content = "") => {
  if (isEditing(view)) {
    saveNodeContent(view);
  }
  view.documentStore.dispatch({
    type: "DOCUMENT/INSERT_NODE",
    payload: {
      position: direction,
      content,
      activeNodeId: view.viewStore.getValue().document.activeNode
    }
  });
  if (content) {
    if (direction === "down" || direction === "right") {
      view.inlineEditor.overrideCursor({ line: 0, ch: 0 });
    }
  }
};

// src/view/components/container/column/components/group/components/card/components/card-buttons/create-card-button.svelte
function create_default_slot37(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  var switch_value = (
    /*chevrons*/
    ctx[2][
      /*position*/
      ctx[0]
    ]
  );
  function switch_props(ctx2, dirty) {
    return {};
  }
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
  }
  return {
    c() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    m(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert(target, switch_instance_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*position*/
      1 && switch_value !== (switch_value = /*chevrons*/
      ctx2[2][
        /*position*/
        ctx2[0]
      ])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props(ctx2, dirty));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(switch_instance_anchor);
      }
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
}
function create_fragment45(ctx) {
  let floatingbutton;
  let current;
  floatingbutton = new floating_button_default({
    props: {
      label: (
        /*label*/
        ctx[3][
          /*position*/
          ctx[0]
        ]
      ),
      position: (
        /*position*/
        ctx[0]
      ),
      $$slots: { default: [create_default_slot37] },
      $$scope: { ctx }
    }
  });
  floatingbutton.$on(
    "click",
    /*createCard*/
    ctx[1]
  );
  return {
    c() {
      create_component(floatingbutton.$$.fragment);
    },
    m(target, anchor) {
      mount_component(floatingbutton, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const floatingbutton_changes = {};
      if (dirty & /*position*/
      1)
        floatingbutton_changes.label = /*label*/
        ctx2[3][
          /*position*/
          ctx2[0]
        ];
      if (dirty & /*position*/
      1)
        floatingbutton_changes.position = /*position*/
        ctx2[0];
      if (dirty & /*$$scope, position*/
      33) {
        floatingbutton_changes.$$scope = { dirty, ctx: ctx2 };
      }
      floatingbutton.$set(floatingbutton_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(floatingbutton.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(floatingbutton.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(floatingbutton, detaching);
    }
  };
}
function instance45($$self, $$props, $$invalidate) {
  let { position } = $$props;
  const view = getView();
  const createCard = (e) => {
    e.stopPropagation();
    saveNodeAndInsertNode(view, position);
  };
  const chevrons = {
    right: chevron_right_default,
    up: chevron_up_default,
    down: chevron_down_default
  };
  const label = {
    "up": "Add card above",
    "down": "Add card below",
    "right": "Add child card"
  };
  $$self.$$set = ($$props2) => {
    if ("position" in $$props2)
      $$invalidate(0, position = $$props2.position);
  };
  return [position, createCard, chevrons, label];
}
var Create_card_button = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance45, create_fragment45, safe_not_equal, { position: 0 });
  }
};
var create_card_button_default = Create_card_button;

// node_modules/tslib/tslib.es6.mjs
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}

// src/obsidian/events/workspace/helpers/get-document-format.ts
var getDocumentFormat = (view) => {
  invariant(view.file);
  const format2 = view.plugin.settings.getValue().documents[view.file.path]?.documentFormat;
  invariant(format2);
  return format2;
};

// src/lib/data-conversion/helpers/delimiter.ts
var level = (parentNumber, index) => `${parentNumber ? parentNumber + "." : ""}${index}`;
var delimiter = (parentNumber, index) => `
<!--section: ${level(parentNumber, index)}-->`;
var delimiterRegex = /\s*<!--\s*section:\s*((\d\.?)*(\d))[\w\s]*-->/;
var parseDelimiter = (line) => {
  const results = delimiterRegex.exec(line);
  if (results) {
    const result = results[1];
    const split2 = result.split(".");
    const index = split2[split2.length - 1];
    const parent = result.substring(0, result.length - index.length - 1);
    return [parent, index, result];
  }
};

// src/view/components/container/column/components/group/components/card/components/card-buttons/helpers/find-section-position.ts
var findSectionPosition = (view, nodeId) => {
  const lines = view.data.split("\n");
  const treeIndex = get_store_value(view.documentStore).sections.id_section[nodeId];
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    if (line.startsWith("<!--")) {
      const section = parseDelimiter(line);
      if (section && section[2] === treeIndex) {
        return i;
      }
    }
  }
};

// src/helpers/clone.ts
var clone = (object) => JSON.parse(JSON.stringify(object));

// node_modules/nanoid/url-alphabet/index.js
var urlAlphabet = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";

// node_modules/nanoid/index.browser.js
var nanoid = (size = 21) => {
  let id2 = "";
  let bytes = crypto.getRandomValues(new Uint8Array(size));
  while (size--) {
    id2 += urlAlphabet[bytes[size] & 63];
  }
  return id2;
};

// src/lib/data-conversion/json-to-outline.ts
var formatContent = (content, indent) => {
  const lines = content.split("\n");
  return lines.length === 1 ? lines[0] : lines.map((line, i) => i === 0 ? line : `${indent}  ${line}`).join("\n");
};
var nodeToOutline = (node, depth = 0) => {
  const indent = "	".repeat(depth);
  let outline = `${indent}- ${formatContent(node.content, indent)}
`;
  for (const child of node.children) {
    outline += nodeToOutline(child, depth + 1);
  }
  return outline;
};
var jsonToOutline = (nodes, depth = 0) => {
  const mapped = nodes.map((node) => nodeToOutline(node, depth));
  const last = mapped.pop() || "";
  mapped.push(last.replace(/\n$/, ""));
  return mapped.join("");
};

// src/lib/data-conversion/columns-to-json.ts
var createTreeNode = (content = "") => {
  return {
    content: content.trim(),
    children: []
  };
};
var columnsToJson = (columns, content) => {
  const nodeMap = {};
  for (const column of columns) {
    for (const group of column.groups) {
      for (const node of group.nodes) {
        const treeNode = createTreeNode(content[node]?.content);
        let parentNode = nodeMap[group.parentId];
        if (!parentNode) {
          parentNode = createTreeNode();
          nodeMap[group.parentId] = parentNode;
        }
        parentNode.children.push(treeNode);
        nodeMap[node] = treeNode;
      }
    }
  }
  const roots = [];
  if (columns[0])
    for (const group of columns[0].groups) {
      for (const node of group.nodes) {
        const treeNode = nodeMap[node];
        if (treeNode) {
          roots.push(treeNode);
        } else {
          throw new Error(`could not find node ${node}`);
        }
      }
    }
  return roots;
};

// src/view/helpers/extract-frontmatter.ts
var extractFrontmatter = (markdown) => {
  const frontmatterRegex = /^---\n([\s\S]+?)\n---\n/;
  const match = markdown.match(frontmatterRegex);
  if (match) {
    const frontmatter = match[0];
    const data = markdown.slice(frontmatter.length);
    return { data, frontmatter: frontmatter.trim() + "\n" };
  } else {
    return { data: markdown, frontmatter: "" };
  }
};

// src/view/components/container/column/components/group/components/card/components/card-buttons/helpers/find-outline-position.ts
var findOutlinePosition = (view, nodeId) => {
  const documentStore = view.documentStore;
  const document2 = clone(documentStore.getValue().document);
  const id2 = nanoid(12);
  document2.content[nodeId].content = id2;
  const outline = jsonToOutline(
    columnsToJson(document2.columns, document2.content)
  );
  const { frontmatter } = extractFrontmatter(view.data);
  const frontmatterOffset = frontmatter.length ? frontmatter.split("\n").length - 1 : 0;
  const lines = outline.split("\n");
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    if (line.contains(id2)) {
      return i + frontmatterOffset;
    }
  }
};

// src/obsidian/events/workspace/actions/set-view-type.ts
var setViewType = (plugin, path, type) => {
  plugin.settings.dispatch({
    type: "SET_VIEW_TYPE",
    payload: {
      path,
      type
    }
  });
};

// src/view/components/container/column/components/group/components/card/components/card-buttons/helpers/openFileAndJumpToLine.ts
var openFileAndJumpToLine = async (plugin, file, line, ch) => {
  const leaf = plugin.app.workspace.getLeaf("split");
  setViewType(plugin, file.path, "markdown");
  await leaf.openFile(file);
  const markdownView = leaf.view;
  markdownView.editor.setCursor({ line, ch });
  setViewType(plugin, file.path, "lineage");
};

// src/view/components/container/column/components/group/components/card/components/card-buttons/tree-index-button.svelte
function add_css8(target) {
  append_styles(target, "svelte-zzekbz", ".tree-index.svelte-zzekbz{position:absolute;bottom:3px;right:8px;opacity:0.8;font-size:12px;cursor:pointer}.is-active.svelte-zzekbz{opacity:0.3}.is-active-child.svelte-zzekbz{opacity:0.3}.is-active-parent.svelte-zzekbz{opacity:0.6}");
}
function create_fragment46(ctx) {
  let div;
  let t;
  let div_class_value;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      t = text(
        /*section*/
        ctx[1]
      );
      attr(div, "aria-label", "Reveal in editor");
      attr(div, "class", div_class_value = null_to_empty("tree-index " + /*activeStatus*/
      (ctx[0] ? (
        /*classes*/
        ctx[3][
          /*activeStatus*/
          ctx[0]
        ]
      ) : "")) + " svelte-zzekbz");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t);
      if (!mounted) {
        dispose = listen(
          div,
          "click",
          /*openFile*/
          ctx[2]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*section*/
      2)
        set_data(
          t,
          /*section*/
          ctx2[1]
        );
      if (dirty & /*activeStatus*/
      1 && div_class_value !== (div_class_value = null_to_empty("tree-index " + /*activeStatus*/
      (ctx2[0] ? (
        /*classes*/
        ctx2[3][
          /*activeStatus*/
          ctx2[0]
        ]
      ) : "")) + " svelte-zzekbz")) {
        attr(div, "class", div_class_value);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      mounted = false;
      dispose();
    }
  };
}
function instance46($$self, $$props, $$invalidate) {
  const view = getView();
  let { nodeId } = $$props;
  let { activeStatus } = $$props;
  let { section } = $$props;
  const openFile2 = () => __awaiter(void 0, void 0, void 0, function* () {
    if (!view.file)
      return;
    const format2 = getDocumentFormat(view);
    const i = format2 === "sections" ? findSectionPosition(view, nodeId) : findOutlinePosition(view, nodeId);
    if (typeof i === "undefined")
      return;
    const targetLine = i + (format2 === "sections" ? 1 : 0);
    const lines = view.data.split("\n");
    const nextLine = lines[targetLine] || "";
    yield openFileAndJumpToLine(view.plugin, view.file, targetLine, nextLine.length);
  });
  const classes = {
    ["node" /* node */]: "is-active",
    ["child" /* child */]: "is-active-child",
    ["parent" /* parent */]: "is-active-parent",
    ["sibling" /* sibling */]: "is-active-parent"
  };
  $$self.$$set = ($$props2) => {
    if ("nodeId" in $$props2)
      $$invalidate(4, nodeId = $$props2.nodeId);
    if ("activeStatus" in $$props2)
      $$invalidate(0, activeStatus = $$props2.activeStatus);
    if ("section" in $$props2)
      $$invalidate(1, section = $$props2.section);
  };
  return [activeStatus, section, openFile2, classes, nodeId];
}
var Tree_index_button = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance46, create_fragment46, safe_not_equal, { nodeId: 4, activeStatus: 0, section: 1 }, add_css8);
  }
};
var tree_index_button_default = Tree_index_button;

// src/view/components/container/column/components/group/components/card/components/card-buttons/card-buttons.svelte
function create_if_block3(ctx) {
  let t;
  let editnodebutton;
  let current;
  let if_block = !/*editing*/
  ctx[0] && create_if_block_12(ctx);
  editnodebutton = new edit_node_button_default({
    props: {
      editing: (
        /*editing*/
        ctx[0]
      ),
      nodeId: (
        /*nodeId*/
        ctx[2]
      )
    }
  });
  return {
    c() {
      if (if_block)
        if_block.c();
      t = space();
      create_component(editnodebutton.$$.fragment);
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, t, anchor);
      mount_component(editnodebutton, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (!/*editing*/
      ctx2[0]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*editing*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_12(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(t.parentNode, t);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      const editnodebutton_changes = {};
      if (dirty & /*editing*/
      1)
        editnodebutton_changes.editing = /*editing*/
        ctx2[0];
      if (dirty & /*nodeId*/
      4)
        editnodebutton_changes.nodeId = /*nodeId*/
        ctx2[2];
      editnodebutton.$set(editnodebutton_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      transition_in(editnodebutton.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      transition_out(editnodebutton.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t);
      }
      if (if_block)
        if_block.d(detaching);
      destroy_component(editnodebutton, detaching);
    }
  };
}
function create_if_block_12(ctx) {
  let createcardbutton0;
  let t0;
  let createcardbutton1;
  let t1;
  let createcardbutton2;
  let t2;
  let deletenodebutton;
  let current;
  createcardbutton0 = new create_card_button_default({ props: { position: "up" } });
  createcardbutton1 = new create_card_button_default({ props: { position: "right" } });
  createcardbutton2 = new create_card_button_default({ props: { position: "down" } });
  deletenodebutton = new delete_node_button_default({ props: { nodeId: (
    /*nodeId*/
    ctx[2]
  ) } });
  return {
    c() {
      create_component(createcardbutton0.$$.fragment);
      t0 = space();
      create_component(createcardbutton1.$$.fragment);
      t1 = space();
      create_component(createcardbutton2.$$.fragment);
      t2 = space();
      create_component(deletenodebutton.$$.fragment);
    },
    m(target, anchor) {
      mount_component(createcardbutton0, target, anchor);
      insert(target, t0, anchor);
      mount_component(createcardbutton1, target, anchor);
      insert(target, t1, anchor);
      mount_component(createcardbutton2, target, anchor);
      insert(target, t2, anchor);
      mount_component(deletenodebutton, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const deletenodebutton_changes = {};
      if (dirty & /*nodeId*/
      4)
        deletenodebutton_changes.nodeId = /*nodeId*/
        ctx2[2];
      deletenodebutton.$set(deletenodebutton_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(createcardbutton0.$$.fragment, local);
      transition_in(createcardbutton1.$$.fragment, local);
      transition_in(createcardbutton2.$$.fragment, local);
      transition_in(deletenodebutton.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(createcardbutton0.$$.fragment, local);
      transition_out(createcardbutton1.$$.fragment, local);
      transition_out(createcardbutton2.$$.fragment, local);
      transition_out(deletenodebutton.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
        detach(t2);
      }
      destroy_component(createcardbutton0, detaching);
      destroy_component(createcardbutton1, detaching);
      destroy_component(createcardbutton2, detaching);
      destroy_component(deletenodebutton, detaching);
    }
  };
}
function create_fragment47(ctx) {
  let t;
  let treeindex;
  let current;
  let if_block = (
    /*active*/
    ctx[1] === "node" /* node */ && create_if_block3(ctx)
  );
  treeindex = new tree_index_button_default({
    props: {
      activeStatus: (
        /*active*/
        ctx[1]
      ),
      nodeId: (
        /*nodeId*/
        ctx[2]
      ),
      section: (
        /*section*/
        ctx[3]
      )
    }
  });
  return {
    c() {
      if (if_block)
        if_block.c();
      t = space();
      create_component(treeindex.$$.fragment);
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, t, anchor);
      mount_component(treeindex, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*active*/
        ctx2[1] === "node" /* node */
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*active*/
          2) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block3(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(t.parentNode, t);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      const treeindex_changes = {};
      if (dirty & /*active*/
      2)
        treeindex_changes.activeStatus = /*active*/
        ctx2[1];
      if (dirty & /*nodeId*/
      4)
        treeindex_changes.nodeId = /*nodeId*/
        ctx2[2];
      if (dirty & /*section*/
      8)
        treeindex_changes.section = /*section*/
        ctx2[3];
      treeindex.$set(treeindex_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      transition_in(treeindex.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      transition_out(treeindex.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t);
      }
      if (if_block)
        if_block.d(detaching);
      destroy_component(treeindex, detaching);
    }
  };
}
function instance47($$self, $$props, $$invalidate) {
  let { editing } = $$props;
  let { active } = $$props;
  let { nodeId } = $$props;
  let { section } = $$props;
  $$self.$$set = ($$props2) => {
    if ("editing" in $$props2)
      $$invalidate(0, editing = $$props2.editing);
    if ("active" in $$props2)
      $$invalidate(1, active = $$props2.active);
    if ("nodeId" in $$props2)
      $$invalidate(2, nodeId = $$props2.nodeId);
    if ("section" in $$props2)
      $$invalidate(3, section = $$props2.section);
  };
  return [editing, active, nodeId, section];
}
var Card_buttons = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance47, create_fragment47, safe_not_equal, {
      editing: 0,
      active: 1,
      nodeId: 2,
      section: 3
    });
  }
};
var card_buttons_default = Card_buttons;

// src/view/components/container/column/components/group/components/card/card.svelte
function create_else_block2(ctx) {
  let draggable2;
  let current;
  draggable2 = new draggable_default({
    props: {
      nodeId: (
        /*node*/
        ctx[0]
      ),
      $$slots: { default: [create_default_slot_12] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(draggable2.$$.fragment);
    },
    m(target, anchor) {
      mount_component(draggable2, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const draggable_changes = {};
      if (dirty & /*node*/
      1)
        draggable_changes.nodeId = /*node*/
        ctx2[0];
      if (dirty & /*$$scope, node*/
      257) {
        draggable_changes.$$scope = { dirty, ctx: ctx2 };
      }
      draggable2.$set(draggable_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(draggable2.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(draggable2.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(draggable2, detaching);
    }
  };
}
function create_if_block4(ctx) {
  let inlineeditor;
  let current;
  inlineeditor = new inline_editor_default({ props: { nodeId: (
    /*node*/
    ctx[0]
  ) } });
  return {
    c() {
      create_component(inlineeditor.$$.fragment);
    },
    m(target, anchor) {
      mount_component(inlineeditor, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const inlineeditor_changes = {};
      if (dirty & /*node*/
      1)
        inlineeditor_changes.nodeId = /*node*/
        ctx2[0];
      inlineeditor.$set(inlineeditor_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(inlineeditor.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(inlineeditor.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(inlineeditor, detaching);
    }
  };
}
function create_default_slot_12(ctx) {
  let content;
  let current;
  content = new content_default({ props: { nodeId: (
    /*node*/
    ctx[0]
  ) } });
  return {
    c() {
      create_component(content.$$.fragment);
    },
    m(target, anchor) {
      mount_component(content, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const content_changes = {};
      if (dirty & /*node*/
      1)
        content_changes.nodeId = /*node*/
        ctx2[0];
      content.$set(content_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(content.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(content.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(content, detaching);
    }
  };
}
function create_default_slot38(ctx) {
  let current_block_type_index;
  let if_block;
  let t;
  let cardbuttons;
  let current;
  const if_block_creators = [create_if_block4, create_else_block2];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*active*/
      ctx2[2] === "node" /* node */ && /*editing*/
      ctx2[1]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  cardbuttons = new card_buttons_default({
    props: {
      active: (
        /*active*/
        ctx[2]
      ),
      editing: (
        /*editing*/
        ctx[1]
      ),
      nodeId: (
        /*node*/
        ctx[0]
      ),
      section: (
        /*section*/
        ctx[6]
      )
    }
  });
  return {
    c() {
      if_block.c();
      t = space();
      create_component(cardbuttons.$$.fragment);
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, t, anchor);
      mount_component(cardbuttons, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(t.parentNode, t);
      }
      const cardbuttons_changes = {};
      if (dirty & /*active*/
      4)
        cardbuttons_changes.active = /*active*/
        ctx2[2];
      if (dirty & /*editing*/
      2)
        cardbuttons_changes.editing = /*editing*/
        ctx2[1];
      if (dirty & /*node*/
      1)
        cardbuttons_changes.nodeId = /*node*/
        ctx2[0];
      if (dirty & /*section*/
      64)
        cardbuttons_changes.section = /*section*/
        ctx2[6];
      cardbuttons.$set(cardbuttons_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      transition_in(cardbuttons.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      transition_out(cardbuttons.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t);
      }
      if_blocks[current_block_type_index].d(detaching);
      destroy_component(cardbuttons, detaching);
    }
  };
}
function create_fragment48(ctx) {
  let droppable2;
  let current;
  droppable2 = new droppable_default({
    props: {
      active: (
        /*active*/
        ctx[2]
      ),
      disableEditConfirmation: (
        /*disableEditConfirmation*/
        ctx[5]
      ),
      editing: (
        /*editing*/
        ctx[1]
      ),
      hasChildren: (
        /*hasChildren*/
        ctx[3]
      ),
      nodeId: (
        /*node*/
        ctx[0]
      ),
      parentId: (
        /*parentId*/
        ctx[4]
      ),
      selected: (
        /*selected*/
        ctx[7]
      ),
      $$slots: { default: [create_default_slot38] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(droppable2.$$.fragment);
    },
    m(target, anchor) {
      mount_component(droppable2, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const droppable_changes = {};
      if (dirty & /*active*/
      4)
        droppable_changes.active = /*active*/
        ctx2[2];
      if (dirty & /*disableEditConfirmation*/
      32)
        droppable_changes.disableEditConfirmation = /*disableEditConfirmation*/
        ctx2[5];
      if (dirty & /*editing*/
      2)
        droppable_changes.editing = /*editing*/
        ctx2[1];
      if (dirty & /*hasChildren*/
      8)
        droppable_changes.hasChildren = /*hasChildren*/
        ctx2[3];
      if (dirty & /*node*/
      1)
        droppable_changes.nodeId = /*node*/
        ctx2[0];
      if (dirty & /*parentId*/
      16)
        droppable_changes.parentId = /*parentId*/
        ctx2[4];
      if (dirty & /*selected*/
      128)
        droppable_changes.selected = /*selected*/
        ctx2[7];
      if (dirty & /*$$scope, active, editing, node, section*/
      327) {
        droppable_changes.$$scope = { dirty, ctx: ctx2 };
      }
      droppable2.$set(droppable_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(droppable2.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(droppable2.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(droppable2, detaching);
    }
  };
}
function instance48($$self, $$props, $$invalidate) {
  let { node } = $$props;
  let { editing } = $$props;
  let { active } = $$props;
  let { hasChildren } = $$props;
  let { parentId } = $$props;
  let { disableEditConfirmation } = $$props;
  let { section } = $$props;
  let { selected } = $$props;
  $$self.$$set = ($$props2) => {
    if ("node" in $$props2)
      $$invalidate(0, node = $$props2.node);
    if ("editing" in $$props2)
      $$invalidate(1, editing = $$props2.editing);
    if ("active" in $$props2)
      $$invalidate(2, active = $$props2.active);
    if ("hasChildren" in $$props2)
      $$invalidate(3, hasChildren = $$props2.hasChildren);
    if ("parentId" in $$props2)
      $$invalidate(4, parentId = $$props2.parentId);
    if ("disableEditConfirmation" in $$props2)
      $$invalidate(5, disableEditConfirmation = $$props2.disableEditConfirmation);
    if ("section" in $$props2)
      $$invalidate(6, section = $$props2.section);
    if ("selected" in $$props2)
      $$invalidate(7, selected = $$props2.selected);
  };
  return [
    node,
    editing,
    active,
    hasChildren,
    parentId,
    disableEditConfirmation,
    section,
    selected
  ];
}
var Card = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance48, create_fragment48, safe_not_equal, {
      node: 0,
      editing: 1,
      active: 2,
      hasChildren: 3,
      parentId: 4,
      disableEditConfirmation: 5,
      section: 6,
      selected: 7
    });
  }
};
var card_default = Card;

// src/view/components/container/column/components/group/group.svelte
var import_classnames3 = __toESM(require_classnames());

// src/stores/document/derived/groups-store.ts
var findColumn = (columns, columnId) => {
  return columns.find((c) => c.id === columnId);
};
var groupsStore = (view, columnId) => {
  let column;
  let columns;
  return derived(view.documentStore, (state2) => {
    if (!column || columns !== state2.document.columns) {
      columns = state2.document.columns;
      column = findColumn(columns, columnId);
      if (!column)
        return [];
    }
    return column.groups;
  });
};

// src/stores/document/derived/nodes-store.ts
var findGroup = (columns, columnId, groupId) => {
  const column = findColumn(columns, columnId);
  if (column) {
    return column.groups.find((group) => group.parentId === groupId);
  }
};
var nodesStore = (view, columnId, groupId) => {
  let group;
  let columns;
  return derived(view.documentStore, (state2) => {
    if (!group || columns !== state2.document.columns) {
      columns = state2.document.columns;
      group = findGroup(columns, columnId, groupId);
      if (!group)
        return [];
    }
    return group.nodes;
  });
};

// src/view/components/container/column/components/group/group.svelte
function add_css9(target) {
  append_styles(target, "svelte-1yh6cqv", ".group.svelte-1yh6cqv{display:flex;flex-direction:column;width:fit-content;gap:4px;padding:8px;margin-bottom:2px}.group.svelte-1yh6cqv:last-child{margin-bottom:0}.group-has-active-parent.svelte-1yh6cqv{border-bottom-left-radius:6px;border-top-left-radius:6px}");
}
function get_each_context2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[17] = list[i];
  return child_ctx;
}
function create_if_block5(ctx) {
  let div;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let div_class_value;
  let div_id_value;
  let current;
  let each_value = ensure_array_like(
    /*$nodes*/
    ctx[12]
  );
  const get_key = (ctx2) => (
    /*node*/
    ctx2[17]
  );
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context2(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block2(key, child_ctx));
  }
  return {
    c() {
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(div, "class", div_class_value = null_to_empty((0, import_classnames3.default)(
        "group",
        /*activeChildGroups*/
        ctx[1].has(
          /*groupId*/
          ctx[0]
        ) && "group-has-active-parent",
        /*activeGroup*/
        ctx[4] === /*groupId*/
        ctx[0] && "group-has-active-node"
      )) + " svelte-1yh6cqv");
      attr(div, "id", div_id_value = "group-" + /*groupId*/
      ctx[0]);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div, null);
        }
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*$nodes, activeNode, parentNodes, activeChildGroups, groupId, activeGroup, editedNode, disableEditConfirmation, idSection, selectedNodes, searchQuery, searching, searchResults*/
      8191) {
        each_value = ensure_array_like(
          /*$nodes*/
          ctx2[12]
        );
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, div, outro_and_destroy_block, create_each_block2, null, get_each_context2);
        check_outros();
      }
      if (!current || dirty & /*activeChildGroups, groupId, activeGroup*/
      19 && div_class_value !== (div_class_value = null_to_empty((0, import_classnames3.default)(
        "group",
        /*activeChildGroups*/
        ctx2[1].has(
          /*groupId*/
          ctx2[0]
        ) && "group-has-active-parent",
        /*activeGroup*/
        ctx2[4] === /*groupId*/
        ctx2[0] && "group-has-active-node"
      )) + " svelte-1yh6cqv")) {
        attr(div, "class", div_class_value);
      }
      if (!current || dirty & /*groupId*/
      1 && div_id_value !== (div_id_value = "group-" + /*groupId*/
      ctx2[0])) {
        attr(div, "id", div_id_value);
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
    }
  };
}
function create_if_block_13(ctx) {
  let node_1;
  let current;
  node_1 = new card_default({
    props: {
      node: (
        /*node*/
        ctx[17]
      ),
      active: (
        /*node*/
        ctx[17] === /*activeNode*/
        ctx[5] ? "node" /* node */ : (
          /*parentNodes*/
          ctx[3].has(
            /*node*/
            ctx[17]
          ) ? "parent" /* parent */ : (
            /*activeChildGroups*/
            ctx[1].has(
              /*groupId*/
              ctx[0]
            ) ? "child" /* child */ : (
              /*activeGroup*/
              ctx[4] === /*groupId*/
              ctx[0] ? "sibling" /* sibling */ : null
            )
          )
        )
      ),
      editing: (
        /*editedNode*/
        ctx[6] === /*node*/
        ctx[17]
      ),
      hasChildren: (
        /*activeChildGroups*/
        ctx[1].size > 0
      ),
      parentId: (
        /*groupId*/
        ctx[0]
      ),
      disableEditConfirmation: (
        /*editedNode*/
        ctx[6] === /*node*/
        ctx[17] && /*disableEditConfirmation*/
        ctx[7]
      ),
      section: (
        /*idSection*/
        ctx[11][
          /*node*/
          ctx[17]
        ]
      ),
      selected: (
        /*selectedNodes*/
        ctx[2].has(
          /*node*/
          ctx[17]
        )
      )
    }
  });
  return {
    c() {
      create_component(node_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(node_1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const node_1_changes = {};
      if (dirty & /*$nodes*/
      4096)
        node_1_changes.node = /*node*/
        ctx2[17];
      if (dirty & /*$nodes, activeNode, parentNodes, activeChildGroups, groupId, activeGroup*/
      4155)
        node_1_changes.active = /*node*/
        ctx2[17] === /*activeNode*/
        ctx2[5] ? "node" /* node */ : (
          /*parentNodes*/
          ctx2[3].has(
            /*node*/
            ctx2[17]
          ) ? "parent" /* parent */ : (
            /*activeChildGroups*/
            ctx2[1].has(
              /*groupId*/
              ctx2[0]
            ) ? "child" /* child */ : (
              /*activeGroup*/
              ctx2[4] === /*groupId*/
              ctx2[0] ? "sibling" /* sibling */ : null
            )
          )
        );
      if (dirty & /*editedNode, $nodes*/
      4160)
        node_1_changes.editing = /*editedNode*/
        ctx2[6] === /*node*/
        ctx2[17];
      if (dirty & /*activeChildGroups*/
      2)
        node_1_changes.hasChildren = /*activeChildGroups*/
        ctx2[1].size > 0;
      if (dirty & /*groupId*/
      1)
        node_1_changes.parentId = /*groupId*/
        ctx2[0];
      if (dirty & /*editedNode, $nodes, disableEditConfirmation*/
      4288)
        node_1_changes.disableEditConfirmation = /*editedNode*/
        ctx2[6] === /*node*/
        ctx2[17] && /*disableEditConfirmation*/
        ctx2[7];
      if (dirty & /*idSection, $nodes*/
      6144)
        node_1_changes.section = /*idSection*/
        ctx2[11][
          /*node*/
          ctx2[17]
        ];
      if (dirty & /*selectedNodes, $nodes*/
      4100)
        node_1_changes.selected = /*selectedNodes*/
        ctx2[2].has(
          /*node*/
          ctx2[17]
        );
      node_1.$set(node_1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(node_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(node_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(node_1, detaching);
    }
  };
}
function create_each_block2(key_1, ctx) {
  let first;
  let show_if = (
    /*searchQuery*/
    ctx[8].length === 0 || !/*searching*/
    ctx[10] && /*searchResults*/
    ctx[9].has(
      /*node*/
      ctx[17]
    )
  );
  let if_block_anchor;
  let current;
  let if_block = show_if && create_if_block_13(ctx);
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*searchQuery, searching, searchResults, $nodes*/
      5888)
        show_if = /*searchQuery*/
        ctx[8].length === 0 || !/*searching*/
        ctx[10] && /*searchResults*/
        ctx[9].has(
          /*node*/
          ctx[17]
        );
      if (show_if) {
        if (if_block) {
          if_block.p(ctx, dirty);
          if (dirty & /*searchQuery, searching, searchResults, $nodes*/
          5888) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_13(ctx);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(first);
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function create_fragment49(ctx) {
  let show_if = (
    /*$nodes*/
    ctx[12].length > 0 && /*searchQuery*/
    (ctx[8].length === 0 || /*$nodes*/
    ctx[12].some(
      /*func*/
      ctx[15]
    ))
  );
  let if_block_anchor;
  let current;
  let if_block = show_if && create_if_block5(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (dirty & /*$nodes, searchQuery, searchResults*/
      4864)
        show_if = /*$nodes*/
        ctx2[12].length > 0 && /*searchQuery*/
        (ctx2[8].length === 0 || /*$nodes*/
        ctx2[12].some(
          /*func*/
          ctx2[15]
        ));
      if (show_if) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$nodes, searchQuery, searchResults*/
          4864) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block5(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function instance49($$self, $$props, $$invalidate) {
  let $nodes;
  let { groupId } = $$props;
  let { columnId } = $$props;
  let { activeChildGroups } = $$props;
  let { selectedNodes } = $$props;
  let { parentNodes } = $$props;
  let { activeGroup } = $$props;
  let { activeNode } = $$props;
  let { editedNode } = $$props;
  let { disableEditConfirmation } = $$props;
  let { searchQuery } = $$props;
  let { searchResults } = $$props;
  let { searching } = $$props;
  let { idSection } = $$props;
  const view = getView();
  const nodes = nodesStore(view, columnId, groupId);
  component_subscribe($$self, nodes, (value) => $$invalidate(12, $nodes = value));
  const func2 = (n) => searchResults.has(n);
  $$self.$$set = ($$props2) => {
    if ("groupId" in $$props2)
      $$invalidate(0, groupId = $$props2.groupId);
    if ("columnId" in $$props2)
      $$invalidate(14, columnId = $$props2.columnId);
    if ("activeChildGroups" in $$props2)
      $$invalidate(1, activeChildGroups = $$props2.activeChildGroups);
    if ("selectedNodes" in $$props2)
      $$invalidate(2, selectedNodes = $$props2.selectedNodes);
    if ("parentNodes" in $$props2)
      $$invalidate(3, parentNodes = $$props2.parentNodes);
    if ("activeGroup" in $$props2)
      $$invalidate(4, activeGroup = $$props2.activeGroup);
    if ("activeNode" in $$props2)
      $$invalidate(5, activeNode = $$props2.activeNode);
    if ("editedNode" in $$props2)
      $$invalidate(6, editedNode = $$props2.editedNode);
    if ("disableEditConfirmation" in $$props2)
      $$invalidate(7, disableEditConfirmation = $$props2.disableEditConfirmation);
    if ("searchQuery" in $$props2)
      $$invalidate(8, searchQuery = $$props2.searchQuery);
    if ("searchResults" in $$props2)
      $$invalidate(9, searchResults = $$props2.searchResults);
    if ("searching" in $$props2)
      $$invalidate(10, searching = $$props2.searching);
    if ("idSection" in $$props2)
      $$invalidate(11, idSection = $$props2.idSection);
  };
  return [
    groupId,
    activeChildGroups,
    selectedNodes,
    parentNodes,
    activeGroup,
    activeNode,
    editedNode,
    disableEditConfirmation,
    searchQuery,
    searchResults,
    searching,
    idSection,
    $nodes,
    nodes,
    columnId,
    func2
  ];
}
var Group = class extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance49,
      create_fragment49,
      safe_not_equal,
      {
        groupId: 0,
        columnId: 14,
        activeChildGroups: 1,
        selectedNodes: 2,
        parentNodes: 3,
        activeGroup: 4,
        activeNode: 5,
        editedNode: 6,
        disableEditConfirmation: 7,
        searchQuery: 8,
        searchResults: 9,
        searching: 10,
        idSection: 11
      },
      add_css9
    );
  }
};
var group_default = Group;

// src/view/actions/dnd/scroll-on-dnd-y.ts
var verticalScrollStep = 10;
var scrollDelay = 100;
var T = 20;
var scrollOnDndY = (column) => {
  let verticalScrollTimeout;
  let verticalScrollDirection = 0;
  let lastScrollTime = 0;
  const scrollVertically = (dir, bufferHeight, bufferBottom) => {
    const now2 = Date.now();
    if (now2 - lastScrollTime >= scrollDelay) {
      column.scrollTop += dir * verticalScrollStep;
      lastScrollTime = now2;
    }
    if (stop(dir, bufferHeight, bufferBottom))
      return;
    verticalScrollTimeout = requestAnimationFrame(
      () => scrollVertically(dir, bufferHeight, bufferBottom)
    );
  };
  let container = null;
  let buffer = null;
  const stop = (dir, bufferHeight, bufferBottom) => {
    if (dir === -1) {
      return column.scrollTop + 50 <= bufferHeight;
    } else if (dir === 1) {
      return column.scrollTop - 50 >= bufferBottom - bufferHeight;
    }
  };
  const handleDragEnter = (event) => {
    if (!container)
      container = column.closest("#columns-container");
    if (!container) {
      return;
    }
    const containerRect = container.getBoundingClientRect();
    const y = event.clientY - containerRect.top;
    verticalScrollDirection = y < T ? -1 : y > containerRect.height - T ? 1 : 0;
    if (verticalScrollDirection !== 0) {
      if (verticalScrollDirection === -1) {
        buffer = column.firstElementChild;
      } else
        buffer = column.lastElementChild;
      if (!buffer)
        return;
      const bufferRect = buffer.getBoundingClientRect();
      scrollVertically(
        verticalScrollDirection,
        bufferRect.height,
        bufferRect.bottom
      );
    }
  };
  const handleDragLeave = () => {
    cancelAnimationFrame(verticalScrollTimeout);
    verticalScrollDirection = 0;
  };
  column.addEventListener("dragenter", handleDragEnter);
  column.addEventListener("dragleave", handleDragLeave);
  return {
    destroy() {
      column.removeEventListener("dragenter", handleDragEnter);
      column.removeEventListener("dragleave", handleDragLeave);
    }
  };
};

// src/view/components/container/column/column.svelte
function add_css10(target) {
  append_styles(target, "svelte-wbqozg", ".column.svelte-wbqozg{min-width:fit-content;height:100vh;overflow-y:scroll;overflow-x:hidden}.column.svelte-wbqozg::-webkit-scrollbar{display:none}.column-buffer.svelte-wbqozg{height:90%;min-width:var(--node-width)}");
}
function get_each_context3(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[16] = list[i];
  return child_ctx;
}
function create_if_block6(ctx) {
  let group_1;
  let current;
  group_1 = new group_default({
    props: {
      groupId: (
        /*group*/
        ctx[16].parentId
      ),
      columnId: (
        /*columnId*/
        ctx[0]
      ),
      parentNodes: (
        /*parentNodes*/
        ctx[4]
      ),
      activeGroup: (
        /*activeGroup*/
        ctx[5]
      ),
      editedNode: (
        /*editedNode*/
        ctx[7]
      ),
      disableEditConfirmation: (
        /*disableEditConfirmation*/
        ctx[8]
      ),
      searchQuery: (
        /*searchQuery*/
        ctx[9]
      ),
      searchResults: (
        /*searchResults*/
        ctx[10]
      ),
      searching: (
        /*searching*/
        ctx[11]
      ),
      activeChildGroups: (
        /*activeChildGroups*/
        ctx[1]
      ),
      activeNode: (
        /*activeNode*/
        ctx[6]
      ),
      idSection: (
        /*idSection*/
        ctx[12]
      ),
      selectedNodes: (
        /*selectedNodes*/
        ctx[3]
      )
    }
  });
  return {
    c() {
      create_component(group_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(group_1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const group_1_changes = {};
      if (dirty & /*$groups*/
      8192)
        group_1_changes.groupId = /*group*/
        ctx2[16].parentId;
      if (dirty & /*columnId*/
      1)
        group_1_changes.columnId = /*columnId*/
        ctx2[0];
      if (dirty & /*parentNodes*/
      16)
        group_1_changes.parentNodes = /*parentNodes*/
        ctx2[4];
      if (dirty & /*activeGroup*/
      32)
        group_1_changes.activeGroup = /*activeGroup*/
        ctx2[5];
      if (dirty & /*editedNode*/
      128)
        group_1_changes.editedNode = /*editedNode*/
        ctx2[7];
      if (dirty & /*disableEditConfirmation*/
      256)
        group_1_changes.disableEditConfirmation = /*disableEditConfirmation*/
        ctx2[8];
      if (dirty & /*searchQuery*/
      512)
        group_1_changes.searchQuery = /*searchQuery*/
        ctx2[9];
      if (dirty & /*searchResults*/
      1024)
        group_1_changes.searchResults = /*searchResults*/
        ctx2[10];
      if (dirty & /*searching*/
      2048)
        group_1_changes.searching = /*searching*/
        ctx2[11];
      if (dirty & /*activeChildGroups*/
      2)
        group_1_changes.activeChildGroups = /*activeChildGroups*/
        ctx2[1];
      if (dirty & /*activeNode*/
      64)
        group_1_changes.activeNode = /*activeNode*/
        ctx2[6];
      if (dirty & /*idSection*/
      4096)
        group_1_changes.idSection = /*idSection*/
        ctx2[12];
      if (dirty & /*selectedNodes*/
      8)
        group_1_changes.selectedNodes = /*selectedNodes*/
        ctx2[3];
      group_1.$set(group_1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(group_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(group_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(group_1, detaching);
    }
  };
}
function create_each_block3(key_1, ctx) {
  let first;
  let show_if = !/*dndChildGroups*/
  ctx[2].has(
    /*group*/
    ctx[16].parentId
  );
  let if_block_anchor;
  let current;
  let if_block = show_if && create_if_block6(ctx);
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*dndChildGroups, $groups*/
      8196)
        show_if = !/*dndChildGroups*/
        ctx[2].has(
          /*group*/
          ctx[16].parentId
        );
      if (show_if) {
        if (if_block) {
          if_block.p(ctx, dirty);
          if (dirty & /*dndChildGroups, $groups*/
          8196) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block6(ctx);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(first);
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function create_fragment50(ctx) {
  let div2;
  let div0;
  let t0;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let t1;
  let div1;
  let scrollOnDndY_action;
  let current;
  let mounted;
  let dispose;
  let each_value = ensure_array_like(
    /*$groups*/
    ctx[13]
  );
  const get_key = (ctx2) => (
    /*group*/
    ctx2[16].parentId
  );
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context3(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block3(key, child_ctx));
  }
  return {
    c() {
      div2 = element("div");
      div0 = element("div");
      t0 = space();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t1 = space();
      div1 = element("div");
      attr(div0, "class", "column-buffer svelte-wbqozg");
      attr(div1, "class", "column-buffer svelte-wbqozg");
      attr(div2, "class", "column svelte-wbqozg");
      attr(
        div2,
        "id",
        /*columnId*/
        ctx[0]
      );
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div0);
      append(div2, t0);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div2, null);
        }
      }
      append(div2, t1);
      append(div2, div1);
      current = true;
      if (!mounted) {
        dispose = action_destroyer(scrollOnDndY_action = scrollOnDndY.call(null, div2));
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*$groups, columnId, parentNodes, activeGroup, editedNode, disableEditConfirmation, searchQuery, searchResults, searching, activeChildGroups, activeNode, idSection, selectedNodes, dndChildGroups*/
      16383) {
        each_value = ensure_array_like(
          /*$groups*/
          ctx2[13]
        );
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, div2, outro_and_destroy_block, create_each_block3, t1, get_each_context3);
        check_outros();
      }
      if (!current || dirty & /*columnId*/
      1) {
        attr(
          div2,
          "id",
          /*columnId*/
          ctx2[0]
        );
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
      mounted = false;
      dispose();
    }
  };
}
function instance50($$self, $$props, $$invalidate) {
  let $groups;
  let { columnId } = $$props;
  let { activeChildGroups } = $$props;
  let { dndChildGroups } = $$props;
  let { selectedNodes } = $$props;
  let { parentNodes } = $$props;
  let { activeGroup } = $$props;
  let { activeNode } = $$props;
  let { editedNode } = $$props;
  let { disableEditConfirmation } = $$props;
  let { searchQuery } = $$props;
  let { searchResults } = $$props;
  let { searching } = $$props;
  let { idSection } = $$props;
  const view = getView();
  const groups = groupsStore(view, columnId);
  component_subscribe($$self, groups, (value) => $$invalidate(13, $groups = value));
  $$self.$$set = ($$props2) => {
    if ("columnId" in $$props2)
      $$invalidate(0, columnId = $$props2.columnId);
    if ("activeChildGroups" in $$props2)
      $$invalidate(1, activeChildGroups = $$props2.activeChildGroups);
    if ("dndChildGroups" in $$props2)
      $$invalidate(2, dndChildGroups = $$props2.dndChildGroups);
    if ("selectedNodes" in $$props2)
      $$invalidate(3, selectedNodes = $$props2.selectedNodes);
    if ("parentNodes" in $$props2)
      $$invalidate(4, parentNodes = $$props2.parentNodes);
    if ("activeGroup" in $$props2)
      $$invalidate(5, activeGroup = $$props2.activeGroup);
    if ("activeNode" in $$props2)
      $$invalidate(6, activeNode = $$props2.activeNode);
    if ("editedNode" in $$props2)
      $$invalidate(7, editedNode = $$props2.editedNode);
    if ("disableEditConfirmation" in $$props2)
      $$invalidate(8, disableEditConfirmation = $$props2.disableEditConfirmation);
    if ("searchQuery" in $$props2)
      $$invalidate(9, searchQuery = $$props2.searchQuery);
    if ("searchResults" in $$props2)
      $$invalidate(10, searchResults = $$props2.searchResults);
    if ("searching" in $$props2)
      $$invalidate(11, searching = $$props2.searching);
    if ("idSection" in $$props2)
      $$invalidate(12, idSection = $$props2.idSection);
  };
  return [
    columnId,
    activeChildGroups,
    dndChildGroups,
    selectedNodes,
    parentNodes,
    activeGroup,
    activeNode,
    editedNode,
    disableEditConfirmation,
    searchQuery,
    searchResults,
    searching,
    idSection,
    $groups,
    groups
  ];
}
var Column = class extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance50,
      create_fragment50,
      safe_not_equal,
      {
        columnId: 0,
        activeChildGroups: 1,
        dndChildGroups: 2,
        selectedNodes: 3,
        parentNodes: 4,
        activeGroup: 5,
        activeNode: 6,
        editedNode: 7,
        disableEditConfirmation: 8,
        searchQuery: 9,
        searchResults: 10,
        searching: 11,
        idSection: 12
      },
      add_css10
    );
  }
};
var column_default = Column;

// src/view/actions/dnd/scroll-on-dnd-x.ts
var horizontalScrollStep = 25;
var scrollDelay2 = 200;
var scrollOnDndX = (node) => {
  let horizontalScrollTimeout;
  let horizontalScrollDirection = 0;
  let lastScrollTime = 0;
  const scrollHorizontally = (dir) => {
    const now2 = Date.now();
    if (now2 - lastScrollTime >= scrollDelay2) {
      node.scrollLeft += dir * horizontalScrollStep;
      lastScrollTime = now2;
    }
    horizontalScrollTimeout = requestAnimationFrame(
      () => scrollHorizontally(dir)
    );
  };
  const handleDragEnter = (event) => {
    const rect = node.getBoundingClientRect();
    const x = event.clientX - rect.left;
    horizontalScrollDirection = x < 50 ? -1 : x > rect.width - 50 ? 1 : 0;
    if (horizontalScrollDirection !== 0) {
      scrollHorizontally(horizontalScrollDirection);
    }
  };
  const handleDragLeave = () => {
    cancelAnimationFrame(horizontalScrollTimeout);
    horizontalScrollDirection = 0;
  };
  node.addEventListener("dragenter", handleDragEnter);
  node.addEventListener("dragleave", handleDragLeave);
  return {
    destroy() {
      node.removeEventListener("dragenter", handleDragEnter);
      node.removeEventListener("dragleave", handleDragLeave);
    }
  };
};

// src/stores/document/derived/columns-store.ts
var columnsStore = (view) => derived(view.documentStore, (state2) => state2.document.columns);

// src/view/components/container/buffers/columns-buffer.svelte
function create_fragment51(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      attr(div, "aria-label", "horizontal buffer");
      set_style(div, "min-height", "10px");
      set_style(div, "min-width", "90%");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
var Columns_buffer = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, null, create_fragment51, safe_not_equal, {});
  }
};
var columns_buffer_default = Columns_buffer;

// src/stores/settings/derived/scrolling-store.ts
var scrollingModeStore = (view) => derived(
  view.plugin.settings,
  (state2) => state2.view.scrolling.horizontalScrollingMode
);
var verticalOffsetStore = (view) => derived(
  view.plugin.settings,
  (state2) => state2.view.scrolling.verticalOffset
);

// src/stores/view/derived/dnd-store.ts
var dndStore = (view) => derived(view.viewStore, (state2) => state2.document.dnd);

// src/stores/view/derived/active-branch-store.ts
var activeBranchStore = (view) => derived(view.viewStore, (state2) => state2.document.activeBranch);

// src/stores/view/derived/active-node-store.ts
var activeNodeStore = (view) => derived(view.viewStore, (state2) => state2.document.activeNode);

// src/stores/view/derived/editing-store.ts
var documentStateStore = (view) => derived(view.viewStore, (state2) => state2.document.editing);

// src/stores/view/derived/search-store.ts
var searchStore = (view) => derived(view.viewStore, (state2) => state2.search);

// src/stores/settings/derived/limit-preview-height-store.ts
var limitPreviewHeightStore = (view) => derived(view.plugin.settings, (state2) => state2.view.limitPreviewHeight);

// src/stores/document/derived/id-section-store.ts
var idSectionStore = (view) => {
  return derived(view.documentStore, (state2) => {
    return state2.sections.id_section;
  });
};

// src/view/actions/context-menu/context-menu.ts
var import_obsidian12 = require("obsidian");

// src/view/actions/context-menu/helpers/on-long-press.ts
var onLongPress = (element2, callback, preventDefaultPredicate) => {
  const state2 = { timer: null, longPress: false };
  const onTouchEnd = (e) => {
    if (state2.longPress) {
      state2.longPress = false;
      if (preventDefaultPredicate(e)) {
        e.stopPropagation();
        e.preventDefault();
      }
    }
    if (state2.timer)
      clearTimeout(state2.timer);
  };
  const onTouchStart = (e) => {
    if (state2.timer)
      clearTimeout(state2.timer);
    state2.timer = setTimeout(() => {
      state2.longPress = true;
      callback(e);
    }, 500);
  };
  element2.addEventListener("touchstart", onTouchStart);
  element2.addEventListener("touchend", onTouchEnd);
  element2.addEventListener("touchmove", onTouchEnd);
  return () => {
    element2.removeEventListener("touchstart", onTouchStart);
    element2.removeEventListener("touchend", onTouchEnd);
    element2.removeEventListener("touchmove", onTouchEnd);
  };
};

// src/view/actions/context-menu/card-context-menu/show-card-context-menu.ts
var import_obsidian10 = require("obsidian");

// src/lib/tree-utils/get/get-sorted-child-groups.ts
var getSortedChildGroups = (columns, currentParentNode, remove = false) => {
  const childGroupsArray = [];
  traverseDown(childGroupsArray, columns, currentParentNode);
  const childGroups = new Set(childGroupsArray);
  const sortedChildGroups = [];
  for (const column of columns) {
    const childGroupsOfColumns = [];
    const groups = [];
    for (const group of column.groups) {
      if (childGroups.has(group.parentId)) {
        childGroupsOfColumns.push(group);
      } else {
        groups.push(group);
      }
    }
    if (remove)
      column.groups = groups;
    if (childGroupsOfColumns.length > 0)
      sortedChildGroups.push(childGroupsOfColumns);
  }
  return sortedChildGroups;
};

// src/lib/tree-utils/delete/delete-node-by-id.ts
var deleteNodeById = (columns, content, nodeId) => {
  for (const column of columns) {
    for (const group of column.groups) {
      for (let i = 0; i < group.nodes.length; i++) {
        const _nodeId = group.nodes[i];
        if (_nodeId === nodeId) {
          group.nodes.splice(i, 1);
          group.nodes = [...group.nodes];
          if (content)
            delete content[_nodeId];
          return;
        }
      }
    }
  }
};

// src/view/actions/keyboard-shortcuts/helpers/commands/commands/helpers/get-branch.ts
var getBranch = (columns, content, nodeId, mode) => {
  const cut = mode === "cut";
  const sortedChildGroups = getSortedChildGroups(columns, nodeId, cut);
  const newContent = {};
  for (const sortedChildGroup of sortedChildGroups) {
    for (const group of sortedChildGroup) {
      for (const node of group.nodes) {
        if (node in content) {
          newContent[node] = content[node];
          if (cut)
            delete content[node];
        }
      }
    }
  }
  newContent[nodeId] = content[nodeId];
  const branch = {
    sortedChildGroups,
    content: newContent,
    nodeId,
    mode
  };
  if (cut)
    deleteNodeById(columns, content, nodeId);
  return clone(branch);
};

// src/lib/data-conversion/json-to-sections.ts
var jsonToSections = (tree, parentNumber = "", text2 = "", includeStructure = true) => {
  for (let i = 0; i < tree.length; i++) {
    const node = tree[i];
    const content = node.content;
    const index = i + 1;
    if (text2)
      text2 = text2 + (includeStructure ? "\n" : "\n\n");
    if (includeStructure) {
      text2 += delimiter(parentNumber, index) + "\n" + content;
    } else {
      text2 += content;
    }
    if (node.children.length > 0) {
      text2 = jsonToSections(
        node.children,
        level(parentNumber, index),
        text2,
        includeStructure
      );
    }
  }
  return text2;
};

// src/helpers/id.ts
var id_size = 8;
var id = {
  rootNode: () => "r" + nanoid(id_size),
  node: () => "n" + nanoid(id_size),
  column: () => "c" + nanoid(id_size),
  snapshot: () => "s" + nanoid(id_size),
  view: () => "v" + nanoid(id_size)
};

// src/lib/tree-utils/create/create-column.ts
var createColumn = () => ({
  id: id.column(),
  groups: []
});

// src/lib/tree-utils/create/create-group.ts
var createGroup = (parentId) => ({
  nodes: [],
  parentId
});

// src/lib/data-conversion/branch-to-section.ts
var branchToColumns = (branch) => {
  const columns = [];
  columns.push(createColumn());
  columns[columns.length - 1].groups.push(createGroup("root"));
  columns[columns.length - 1].groups[0].nodes.push(branch.nodeId);
  for (const groups of branch.sortedChildGroups) {
    columns.push(createColumn());
    for (const group of groups) {
      columns[columns.length - 1].groups.push(group);
    }
  }
  return columns;
};
var branchToJson = (branches) => {
  const trees = [];
  for (const branch of branches) {
    const tree = columnsToJson(branchToColumns(branch), branch.content);
    trees.push(tree[0]);
  }
  return trees;
};
var branchToSection = (branches) => {
  return jsonToSections(branchToJson(branches));
};

// src/obsidian/events/workspace/effects/create-new-file.ts
var import_obsidian4 = require("obsidian");

// src/helpers/sanitize-file-name.ts
var sanitizeFileName = (path, replacement = "-") => {
  const illegalCharacters = /[*"\\/<>:|?]/g;
  const unsafeCharactersForObsidianLinks = /[#^[\]|]/g;
  const dotAtTheStart = /^\./g;
  const controlRe = /[\x00-\x1f\x80-\x9f]/g;
  const reservedRe = /^\.+$/;
  const windowsReservedRe = /^(con|prn|aux|nul|com[0-9]|lpt[0-9])(\..*)?$/i;
  const windowsTrailingRe = /[. ]+$/;
  let sanitized = path.replace(/"/g, "'").replace(illegalCharacters, replacement).replace(unsafeCharactersForObsidianLinks, replacement).replace(dotAtTheStart, replacement).replace(controlRe, replacement).replace(reservedRe, replacement).replace(windowsReservedRe, replacement).replace(windowsTrailingRe, replacement);
  if (replacement)
    sanitized = sanitized.replace(new RegExp(`${replacement}+`, "g"), replacement).replace(
      new RegExp(`^${replacement}(.)|(.)${replacement}$`, "g"),
      "$1$2"
    );
  return sanitized;
};

// src/obsidian/events/workspace/effects/get-unique-file-name.ts
var getUniqueFileName = (folderPath, files, basename = "Untitled") => {
  basename = sanitizeFileName(basename);
  let index = 1;
  let newFileName = basename;
  while (files.includes(`${newFileName}`)) {
    newFileName = `${basename} (${index})`;
    index++;
  }
  return `${folderPath}/${newFileName}`;
};

// src/obsidian/events/workspace/effects/create-new-file.ts
var createNewFile = async (plugin, folder, data = "", basename) => {
  invariant(folder);
  const children2 = folder.children.map(
    (c) => c instanceof import_obsidian4.TFile && c.extension === "md" ? c.basename : null
  ).filter((f) => f);
  const path = getUniqueFileName(folder.path, children2, basename);
  const newFilePath = path + ".md";
  const file = await plugin.app.vault.create(newFilePath, data);
  invariant(file);
  return file;
};

// src/obsidian/events/workspace/effects/open-file.ts
var openFile = async (plugin, file, newLeaf) => {
  const leaf = plugin.app.workspace.getLeaf(newLeaf);
  await leaf.openFile(file);
  return leaf;
};

// src/obsidian/events/workspace/effects/toggle-obsidian-view-type.ts
var toggleObsidianViewType = (plugin, leaf, type) => {
  setTimeout(() => {
    leaf.setViewState({
      type,
      popstate: true,
      state: leaf.view.getState()
    });
    const activeLeaf = plugin.app.workspace.getLeaf();
    if (activeLeaf !== leaf) {
      plugin.app.workspace.revealLeaf(leaf);
    }
    plugin.app.workspace.setActiveLeaf(leaf);
  }, 0);
};

// src/obsidian/events/workspace/actions/set-document-format.ts
var setDocumentFormat = (plugin, path, type) => {
  plugin.settings.dispatch({
    type: "SET_DOCUMENT_TYPE",
    payload: {
      path,
      format: type
    }
  });
};

// src/obsidian/events/workspace/effects/open-file-in-lineage.ts
var openFileInLineage = async (plugin, file, type, newLeaf) => {
  const leaf = await openFile(plugin, file, newLeaf);
  toggleObsidianViewType(plugin, leaf, "lineage");
  setDocumentFormat(plugin, file.path, type);
};

// src/obsidian/commands/helpers/extract-branch/helpers/get-file-name-of-extracted-branch/get-file-name-from-content.ts
var getFileNameFromContent = (text2) => {
  const lines = text2.split("\n").map((line) => line.trim().replace(/\s+/g, " ")).filter((line) => line);
  if (lines.length === 0)
    return;
  let result = void 0;
  if (lines[0].startsWith("# ")) {
    result = lines[0].replace(/^# /, "").substring(0, 100);
  } else if (lines[0].startsWith("- ")) {
    result = lines[0].replace(/^- /, "").substring(0, 100);
  } else {
    result = lines.join(" ");
  }
  return result.substring(0, 100);
};

// src/obsidian/commands/helpers/extract-branch/helpers/get-file-name-of-extracted-branch/get-file-name-of-extracted-branch.ts
var getFileNameOfExtractedBranch = (nodeContent, currentFileName, sectionNumber) => {
  const name = getFileNameFromContent(nodeContent);
  if (name)
    return name;
  if (sectionNumber) {
    return `${currentFileName} - ${sectionNumber}`;
  } else
    return `${currentFileName} - extracted-section`;
};

// src/lib/errors/errors.ts
var SilentError = class extends Error {
};

// src/lib/store/on-plugin-error.ts
var import_obsidian5 = require("obsidian");
var onPluginError = (error, location, action) => {
  if (!(error instanceof SilentError)) {
    console.error(`[${location}] action: `, action);
    console.error(`[${location}]`, error);
    const message = error.message.replace(/Invariant failed(: )?/, "");
    if (message)
      new import_obsidian5.Notice(message);
    else
      new import_obsidian5.Notice(lang.error_generic);
  }
};

// src/lib/data-conversion/branch-to-outline.ts
var branchToOutline = (branches) => {
  return jsonToOutline(branchToJson(branches));
};

// src/obsidian/commands/helpers/extract-branch/extract-branch.ts
var extractBranch = async (view) => {
  try {
    invariant(view.file);
    invariant(view.file.parent);
    const viewState = view.viewStore.getValue();
    const documentState = view.documentStore.getValue();
    const branch = getBranch(
      documentState.document.columns,
      documentState.document.content,
      viewState.document.activeNode,
      "copy"
    );
    const format2 = getDocumentFormat(view);
    const text2 = format2 === "outline" ? branchToOutline([branch]) : branchToSection([branch]);
    const newFile = await createNewFile(
      view.plugin,
      view.file.parent,
      text2,
      getFileNameOfExtractedBranch(
        branch.content[branch.nodeId].content,
        view.file.basename,
        documentState.sections.id_section[branch.nodeId]
      )
    );
    await openFileInLineage(view.plugin, newFile, format2, "split");
    view.documentStore.dispatch({
      type: "DOCUMENT/EXTRACT_BRANCH",
      payload: {
        nodeId: branch.nodeId,
        documentName: newFile.basename
      }
    });
  } catch (e) {
    onPluginError(e, "command", { type: "extract-branch" });
  }
};

// src/view/actions/keyboard-shortcuts/helpers/commands/commands/helpers/merge-node.ts
var mergeNode = (view, direction) => {
  saveNodeContent(view);
  if (view.viewStore.getValue().document.selectedNodes.size > 1) {
    throw new Error(lang.cant_merge_multiple_nodes);
  }
  view.documentStore.dispatch({
    type: "DOCUMENT/MERGE_NODE",
    payload: {
      direction,
      activeNodeId: view.viewStore.getValue().document.activeNode
    }
  });
};

// src/view/actions/keyboard-shortcuts/helpers/commands/commands/helpers/clipboard/map-active-branches-to-text.ts
var mapActiveBranchesToText = (document2, activeNode, selectedNodes, format2) => {
  const isSelection = selectedNodes.size > 1;
  const nodes = isSelection ? [...selectedNodes] : [activeNode];
  const branches = nodes.map(
    (node) => getBranch(document2.columns, document2.content, node, "copy")
  );
  return format2 === "outline" ? branchToOutline(branches) : branchToSection(branches);
};

// src/view/actions/keyboard-shortcuts/helpers/commands/commands/helpers/clipboard/copy-active-branches-to-clipboard.ts
var copyActiveBranchesToClipboard = async (view) => {
  const document2 = view.viewStore.getValue().document;
  const format2 = getDocumentFormat(view);
  const text2 = mapActiveBranchesToText(
    view.documentStore.getValue().document,
    document2.activeNode,
    document2.selectedNodes,
    format2
  );
  await navigator.clipboard.writeText(text2);
};

// src/view/actions/keyboard-shortcuts/helpers/commands/commands/helpers/copy-node.ts
var copyNode = async (view) => {
  const document2 = view.viewStore.getValue().document;
  await copyActiveBranchesToClipboard(view);
  view.documentStore.dispatch({
    type: "DOCUMENT/COPY_NODE",
    payload: {
      nodeId: document2.activeNode,
      selectedNodes: document2.selectedNodes
    }
  });
};

// src/view/actions/keyboard-shortcuts/helpers/commands/commands/helpers/cut-node.ts
var cutNode = async (view) => {
  const document2 = view.viewStore.getValue().document;
  await copyActiveBranchesToClipboard(view);
  view.documentStore.dispatch({
    type: "DOCUMENT/CUT_NODE",
    payload: {
      nodeId: document2.activeNode,
      selectedNodes: document2.selectedNodes
    }
  });
};

// src/view/actions/keyboard-shortcuts/helpers/commands/commands/helpers/paste-node.ts
var pasteNode = async (view) => {
  const viewState = view.viewStore.getValue();
  const text2 = (await navigator.clipboard.readText()).replace(/\r\n/g, "\n");
  view.documentStore.dispatch({
    type: "DOCUMENT/PASTE_NODE",
    payload: {
      targetNodeId: viewState.document.activeNode,
      text: text2
    }
  });
};

// src/view/modals/split-node-modal/split-node-modal.ts
var import_obsidian6 = require("obsidian");

// src/view/modals/split-node-modal/helpers/get-modal-state.ts
var getModalState = () => {
  return getContext("modal-state");
};

// src/view/modals/split-node-modal/components/components/content-preview.svelte
function add_css11(target) {
  append_styles(target, "svelte-20u69o", ".preview.svelte-20u69o{flex-grow:1;max-height:500px;overflow:auto}");
}
function create_if_block7(ctx) {
  let p;
  return {
    c() {
      p = element("p");
      p.textContent = "This card's content does not match any splitting pattern";
      attr(p, "class", "mod-warning");
    },
    m(target, anchor) {
      insert(target, p, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(p);
      }
    }
  };
}
function create_fragment52(ctx) {
  let div0;
  let t;
  let div1;
  let if_block = !/*$mode*/
  ctx[0] && create_if_block7(ctx);
  return {
    c() {
      div0 = element("div");
      if (if_block)
        if_block.c();
      t = space();
      div1 = element("div");
      attr(div1, "class", "preview svelte-20u69o");
    },
    m(target, anchor) {
      insert(target, div0, anchor);
      if (if_block)
        if_block.m(div0, null);
      insert(target, t, anchor);
      insert(target, div1, anchor);
      div1.innerHTML = /*$content*/
      ctx[1];
    },
    p(ctx2, [dirty]) {
      if (!/*$mode*/
      ctx2[0]) {
        if (if_block) {
        } else {
          if_block = create_if_block7(ctx2);
          if_block.c();
          if_block.m(div0, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty & /*$content*/
      2)
        div1.innerHTML = /*$content*/
        ctx2[1];
      ;
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(div0);
        detach(t);
        detach(div1);
      }
      if (if_block)
        if_block.d();
    }
  };
}
function instance51($$self, $$props, $$invalidate) {
  let $mode;
  let $content;
  const state2 = getModalState();
  const mode = state2.mode;
  component_subscribe($$self, mode, (value) => $$invalidate(0, $mode = value));
  const content = state2.content;
  component_subscribe($$self, content, (value) => $$invalidate(1, $content = value));
  return [$mode, $content, mode, content];
}
var Content_preview = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance51, create_fragment52, safe_not_equal, {}, add_css11);
  }
};
var content_preview_default = Content_preview;

// src/view/modals/split-node-modal/helpers/get-modal-props.ts
var getModalProps = () => {
  return getContext("modal-props");
};

// src/view/modals/split-node-modal/components/components/modal-buttons.svelte
function add_css12(target) {
  append_styles(target, "svelte-6fani8", ".split-content-footer.svelte-6fani8{display:flex;align-items:center;justify-content:space-between}.modes-container.svelte-6fani8{height:50px;display:flex;align-items:center}.buttons-container.svelte-6fani8{display:flex;gap:5px;width:fit-content}label.svelte-6fani8{display:block;text-transform:capitalize}label[data-disabled='true'].svelte-6fani8{opacity:0.6}");
}
function get_each_context4(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[10] = list[i];
  return child_ctx;
}
function create_each_block4(ctx) {
  let label;
  let input;
  let input_checked_value;
  let input_disabled_value;
  let input_value_value;
  let t0;
  let t1_value = (
    /*_mode*/
    ctx[10] + ""
  );
  let t1;
  let t2;
  let label_data_disabled_value;
  let mounted;
  let dispose;
  return {
    c() {
      label = element("label");
      input = element("input");
      t0 = space();
      t1 = text(t1_value);
      t2 = space();
      input.checked = input_checked_value = /*$mode*/
      ctx[0] === /*_mode*/
      ctx[10];
      input.disabled = input_disabled_value = /*disabledModes*/
      ctx[4].has(
        /*_mode*/
        ctx[10]
      );
      attr(input, "name", "mode");
      attr(input, "type", "radio");
      input.value = input_value_value = /*_mode*/
      ctx[10];
      attr(label, "data-disabled", label_data_disabled_value = /*disabledModes*/
      ctx[4].has(
        /*_mode*/
        ctx[10]
      ));
      attr(label, "class", "svelte-6fani8");
    },
    m(target, anchor) {
      insert(target, label, anchor);
      append(label, input);
      append(label, t0);
      append(label, t1);
      append(label, t2);
      if (!mounted) {
        dispose = listen(
          input,
          "change",
          /*change_handler*/
          ctx[6]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*$mode*/
      1 && input_checked_value !== (input_checked_value = /*$mode*/
      ctx2[0] === /*_mode*/
      ctx2[10])) {
        input.checked = input_checked_value;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(label);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_fragment53(ctx) {
  let div2;
  let div0;
  let t0;
  let div1;
  let button0;
  let t1;
  let button0_disabled_value;
  let t2;
  let button1;
  let mounted;
  let dispose;
  let each_value = ensure_array_like(
    /*modes*/
    ctx[5]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block4(get_each_context4(ctx, each_value, i));
  }
  return {
    c() {
      div2 = element("div");
      div0 = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t0 = space();
      div1 = element("div");
      button0 = element("button");
      t1 = text("Split");
      t2 = space();
      button1 = element("button");
      button1.textContent = "Cancel";
      attr(div0, "class", "modes-container svelte-6fani8");
      attr(button0, "class", "mod-cta");
      button0.disabled = button0_disabled_value = !/*$mode*/
      ctx[0];
      attr(div1, "class", "buttons-container svelte-6fani8");
      attr(div2, "class", "split-content-footer svelte-6fani8");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div0);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div0, null);
        }
      }
      append(div2, t0);
      append(div2, div1);
      append(div1, button0);
      append(button0, t1);
      append(div1, t2);
      append(div1, button1);
      if (!mounted) {
        dispose = [
          listen(
            button0,
            "click",
            /*click_handler*/
            ctx[7]
          ),
          listen(
            button1,
            "click",
            /*click_handler_1*/
            ctx[8]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*disabledModes, modes, $mode, onModeChange*/
      53) {
        each_value = ensure_array_like(
          /*modes*/
          ctx2[5]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context4(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block4(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(div0, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (dirty & /*$mode*/
      1 && button0_disabled_value !== (button0_disabled_value = !/*$mode*/
      ctx2[0])) {
        button0.disabled = button0_disabled_value;
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      destroy_each(each_blocks, detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance52($$self, $$props, $$invalidate) {
  let $mode;
  const state2 = getModalState();
  const props = getModalProps();
  const onModeChange = (value) => {
    state2.mode.set(value);
  };
  const mode = state2.mode;
  component_subscribe($$self, mode, (value) => $$invalidate(0, $mode = value));
  const disabledModes = state2.disabledModes;
  const modes = ["headings", "outline", "paragraphs"];
  const change_handler = (e) => onModeChange(e.currentTarget.value);
  const click_handler = () => props.callbacks.accept();
  const click_handler_1 = () => props.callbacks.reject();
  return [
    $mode,
    props,
    onModeChange,
    mode,
    disabledModes,
    modes,
    change_handler,
    click_handler,
    click_handler_1
  ];
}
var Modal_buttons = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance52, create_fragment53, safe_not_equal, {}, add_css12);
  }
};
var modal_buttons_default = Modal_buttons;

// src/view/modals/split-node-modal/components/modal-content.svelte
function add_css13(target) {
  append_styles(target, "svelte-1axt1o3", ".split-content-modal.svelte-1axt1o3{display:flex;flex-direction:column}");
}
function create_fragment54(ctx) {
  let div;
  let content;
  let t;
  let buttons;
  let current;
  content = new content_preview_default({});
  buttons = new modal_buttons_default({});
  return {
    c() {
      div = element("div");
      create_component(content.$$.fragment);
      t = space();
      create_component(buttons.$$.fragment);
      attr(div, "class", "split-content-modal svelte-1axt1o3");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(content, div, null);
      append(div, t);
      mount_component(buttons, div, null);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(content.$$.fragment, local);
      transition_in(buttons.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(content.$$.fragment, local);
      transition_out(buttons.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(content);
      destroy_component(buttons);
    }
  };
}
function instance53($$self, $$props, $$invalidate) {
  let { state: state2 } = $$props;
  let { props } = $$props;
  setContext("modal-state", state2);
  setContext("modal-props", props);
  $$self.$$set = ($$props2) => {
    if ("state" in $$props2)
      $$invalidate(0, state2 = $$props2.state);
    if ("props" in $$props2)
      $$invalidate(1, props = $$props2.props);
  };
  return [state2, props];
}
var Modal_content = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance53, create_fragment54, safe_not_equal, { state: 0, props: 1 }, add_css13);
  }
};
var modal_content_default = Modal_content;

// src/lib/format-detection/has-n-headings.ts
var hasNHeadings = (input, n = 2) => {
  const lines = input.split("\n");
  let count = 0;
  for (const line of lines) {
    if (/^((\t*)- )?#+ +/.test(line)) {
      count++;
      if (count >= n)
        return true;
    }
  }
  return false;
};

// src/lib/format-detection/is-outline.ts
var isOutline = (text2) => {
  const lines = text2.split("\n").filter((x) => x.trim());
  if (lines.length <= 1)
    return false;
  let level2 = 0;
  for (const line of lines) {
    if (!line)
      continue;
    const match = line.match(/^(\t*)- (.*)/);
    if (match) {
      const itemLevel = match[1].length + 1;
      if (itemLevel - level2 > 1) {
        return false;
      }
      level2 = itemLevel;
    } else {
      const match2 = line.match(/^(\t*) {2}/);
      if (match2) {
        const itemLevel = (match2[1] ? match2[1].length : 0) + 1;
        if (itemLevel !== level2) {
          return false;
        }
      } else {
        return false;
      }
    }
  }
  return true;
};

// node_modules/diff/lib/index.mjs
function Diff() {
}
Diff.prototype = {
  diff: function diff(oldString, newString) {
    var _options$timeout;
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    var callback = options.callback;
    if (typeof options === "function") {
      callback = options;
      options = {};
    }
    this.options = options;
    var self = this;
    function done(value) {
      if (callback) {
        setTimeout(function() {
          callback(void 0, value);
        }, 0);
        return true;
      } else {
        return value;
      }
    }
    oldString = this.castInput(oldString);
    newString = this.castInput(newString);
    oldString = this.removeEmpty(this.tokenize(oldString));
    newString = this.removeEmpty(this.tokenize(newString));
    var newLen = newString.length, oldLen = oldString.length;
    var editLength = 1;
    var maxEditLength = newLen + oldLen;
    if (options.maxEditLength) {
      maxEditLength = Math.min(maxEditLength, options.maxEditLength);
    }
    var maxExecutionTime = (_options$timeout = options.timeout) !== null && _options$timeout !== void 0 ? _options$timeout : Infinity;
    var abortAfterTimestamp = Date.now() + maxExecutionTime;
    var bestPath = [{
      oldPos: -1,
      lastComponent: void 0
    }];
    var newPos = this.extractCommon(bestPath[0], newString, oldString, 0);
    if (bestPath[0].oldPos + 1 >= oldLen && newPos + 1 >= newLen) {
      return done([{
        value: this.join(newString),
        count: newString.length
      }]);
    }
    var minDiagonalToConsider = -Infinity, maxDiagonalToConsider = Infinity;
    function execEditLength() {
      for (var diagonalPath = Math.max(minDiagonalToConsider, -editLength); diagonalPath <= Math.min(maxDiagonalToConsider, editLength); diagonalPath += 2) {
        var basePath = void 0;
        var removePath = bestPath[diagonalPath - 1], addPath = bestPath[diagonalPath + 1];
        if (removePath) {
          bestPath[diagonalPath - 1] = void 0;
        }
        var canAdd = false;
        if (addPath) {
          var addPathNewPos = addPath.oldPos - diagonalPath;
          canAdd = addPath && 0 <= addPathNewPos && addPathNewPos < newLen;
        }
        var canRemove = removePath && removePath.oldPos + 1 < oldLen;
        if (!canAdd && !canRemove) {
          bestPath[diagonalPath] = void 0;
          continue;
        }
        if (!canRemove || canAdd && removePath.oldPos + 1 < addPath.oldPos) {
          basePath = self.addToPath(addPath, true, void 0, 0);
        } else {
          basePath = self.addToPath(removePath, void 0, true, 1);
        }
        newPos = self.extractCommon(basePath, newString, oldString, diagonalPath);
        if (basePath.oldPos + 1 >= oldLen && newPos + 1 >= newLen) {
          return done(buildValues(self, basePath.lastComponent, newString, oldString, self.useLongestToken));
        } else {
          bestPath[diagonalPath] = basePath;
          if (basePath.oldPos + 1 >= oldLen) {
            maxDiagonalToConsider = Math.min(maxDiagonalToConsider, diagonalPath - 1);
          }
          if (newPos + 1 >= newLen) {
            minDiagonalToConsider = Math.max(minDiagonalToConsider, diagonalPath + 1);
          }
        }
      }
      editLength++;
    }
    if (callback) {
      (function exec() {
        setTimeout(function() {
          if (editLength > maxEditLength || Date.now() > abortAfterTimestamp) {
            return callback();
          }
          if (!execEditLength()) {
            exec();
          }
        }, 0);
      })();
    } else {
      while (editLength <= maxEditLength && Date.now() <= abortAfterTimestamp) {
        var ret = execEditLength();
        if (ret) {
          return ret;
        }
      }
    }
  },
  addToPath: function addToPath(path, added, removed, oldPosInc) {
    var last = path.lastComponent;
    if (last && last.added === added && last.removed === removed) {
      return {
        oldPos: path.oldPos + oldPosInc,
        lastComponent: {
          count: last.count + 1,
          added,
          removed,
          previousComponent: last.previousComponent
        }
      };
    } else {
      return {
        oldPos: path.oldPos + oldPosInc,
        lastComponent: {
          count: 1,
          added,
          removed,
          previousComponent: last
        }
      };
    }
  },
  extractCommon: function extractCommon(basePath, newString, oldString, diagonalPath) {
    var newLen = newString.length, oldLen = oldString.length, oldPos = basePath.oldPos, newPos = oldPos - diagonalPath, commonCount = 0;
    while (newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(newString[newPos + 1], oldString[oldPos + 1])) {
      newPos++;
      oldPos++;
      commonCount++;
    }
    if (commonCount) {
      basePath.lastComponent = {
        count: commonCount,
        previousComponent: basePath.lastComponent
      };
    }
    basePath.oldPos = oldPos;
    return newPos;
  },
  equals: function equals(left, right) {
    if (this.options.comparator) {
      return this.options.comparator(left, right);
    } else {
      return left === right || this.options.ignoreCase && left.toLowerCase() === right.toLowerCase();
    }
  },
  removeEmpty: function removeEmpty(array) {
    var ret = [];
    for (var i = 0; i < array.length; i++) {
      if (array[i]) {
        ret.push(array[i]);
      }
    }
    return ret;
  },
  castInput: function castInput(value) {
    return value;
  },
  tokenize: function tokenize(value) {
    return value.split("");
  },
  join: function join(chars) {
    return chars.join("");
  }
};
function buildValues(diff2, lastComponent, newString, oldString, useLongestToken) {
  var components = [];
  var nextComponent;
  while (lastComponent) {
    components.push(lastComponent);
    nextComponent = lastComponent.previousComponent;
    delete lastComponent.previousComponent;
    lastComponent = nextComponent;
  }
  components.reverse();
  var componentPos = 0, componentLen = components.length, newPos = 0, oldPos = 0;
  for (; componentPos < componentLen; componentPos++) {
    var component = components[componentPos];
    if (!component.removed) {
      if (!component.added && useLongestToken) {
        var value = newString.slice(newPos, newPos + component.count);
        value = value.map(function(value2, i) {
          var oldValue = oldString[oldPos + i];
          return oldValue.length > value2.length ? oldValue : value2;
        });
        component.value = diff2.join(value);
      } else {
        component.value = diff2.join(newString.slice(newPos, newPos + component.count));
      }
      newPos += component.count;
      if (!component.added) {
        oldPos += component.count;
      }
    } else {
      component.value = diff2.join(oldString.slice(oldPos, oldPos + component.count));
      oldPos += component.count;
      if (componentPos && components[componentPos - 1].added) {
        var tmp = components[componentPos - 1];
        components[componentPos - 1] = components[componentPos];
        components[componentPos] = tmp;
      }
    }
  }
  var finalComponent = components[componentLen - 1];
  if (componentLen > 1 && typeof finalComponent.value === "string" && (finalComponent.added || finalComponent.removed) && diff2.equals("", finalComponent.value)) {
    components[componentLen - 2].value += finalComponent.value;
    components.pop();
  }
  return components;
}
var characterDiff = new Diff();
function generateOptions(options, defaults) {
  if (typeof options === "function") {
    defaults.callback = options;
  } else if (options) {
    for (var name in options) {
      if (options.hasOwnProperty(name)) {
        defaults[name] = options[name];
      }
    }
  }
  return defaults;
}
var extendedWordChars = /^[A-Za-z\xC0-\u02C6\u02C8-\u02D7\u02DE-\u02FF\u1E00-\u1EFF]+$/;
var reWhitespace = /\S/;
var wordDiff = new Diff();
wordDiff.equals = function(left, right) {
  if (this.options.ignoreCase) {
    left = left.toLowerCase();
    right = right.toLowerCase();
  }
  return left === right || this.options.ignoreWhitespace && !reWhitespace.test(left) && !reWhitespace.test(right);
};
wordDiff.tokenize = function(value) {
  var tokens = value.split(/([^\S\r\n]+|[()[\]{}'"\r\n]|\b)/);
  for (var i = 0; i < tokens.length - 1; i++) {
    if (!tokens[i + 1] && tokens[i + 2] && extendedWordChars.test(tokens[i]) && extendedWordChars.test(tokens[i + 2])) {
      tokens[i] += tokens[i + 2];
      tokens.splice(i + 1, 2);
      i--;
    }
  }
  return tokens;
};
function diffWords(oldStr, newStr, options) {
  options = generateOptions(options, {
    ignoreWhitespace: true
  });
  return wordDiff.diff(oldStr, newStr, options);
}
var lineDiff = new Diff();
lineDiff.tokenize = function(value) {
  if (this.options.stripTrailingCr) {
    value = value.replace(/\r\n/g, "\n");
  }
  var retLines = [], linesAndNewlines = value.split(/(\n|\r\n)/);
  if (!linesAndNewlines[linesAndNewlines.length - 1]) {
    linesAndNewlines.pop();
  }
  for (var i = 0; i < linesAndNewlines.length; i++) {
    var line = linesAndNewlines[i];
    if (i % 2 && !this.options.newlineIsToken) {
      retLines[retLines.length - 1] += line;
    } else {
      if (this.options.ignoreWhitespace) {
        line = line.trim();
      }
      retLines.push(line);
    }
  }
  return retLines;
};
var sentenceDiff = new Diff();
sentenceDiff.tokenize = function(value) {
  return value.split(/(\S.+?[.!?])(?=\s+|$)/);
};
var cssDiff = new Diff();
cssDiff.tokenize = function(value) {
  return value.split(/([{}:;,]|\s+)/);
};
function _typeof(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof = function(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof(obj);
}
var objectPrototypeToString = Object.prototype.toString;
var jsonDiff = new Diff();
jsonDiff.useLongestToken = true;
jsonDiff.tokenize = lineDiff.tokenize;
jsonDiff.castInput = function(value) {
  var _this$options = this.options, undefinedReplacement = _this$options.undefinedReplacement, _this$options$stringi = _this$options.stringifyReplacer, stringifyReplacer = _this$options$stringi === void 0 ? function(k, v) {
    return typeof v === "undefined" ? undefinedReplacement : v;
  } : _this$options$stringi;
  return typeof value === "string" ? value : JSON.stringify(canonicalize(value, null, null, stringifyReplacer), stringifyReplacer, "  ");
};
jsonDiff.equals = function(left, right) {
  return Diff.prototype.equals.call(jsonDiff, left.replace(/,([\r\n])/g, "$1"), right.replace(/,([\r\n])/g, "$1"));
};
function canonicalize(obj, stack, replacementStack, replacer, key) {
  stack = stack || [];
  replacementStack = replacementStack || [];
  if (replacer) {
    obj = replacer(key, obj);
  }
  var i;
  for (i = 0; i < stack.length; i += 1) {
    if (stack[i] === obj) {
      return replacementStack[i];
    }
  }
  var canonicalizedObj;
  if ("[object Array]" === objectPrototypeToString.call(obj)) {
    stack.push(obj);
    canonicalizedObj = new Array(obj.length);
    replacementStack.push(canonicalizedObj);
    for (i = 0; i < obj.length; i += 1) {
      canonicalizedObj[i] = canonicalize(obj[i], stack, replacementStack, replacer, key);
    }
    stack.pop();
    replacementStack.pop();
    return canonicalizedObj;
  }
  if (obj && obj.toJSON) {
    obj = obj.toJSON();
  }
  if (_typeof(obj) === "object" && obj !== null) {
    stack.push(obj);
    canonicalizedObj = {};
    replacementStack.push(canonicalizedObj);
    var sortedKeys = [], _key;
    for (_key in obj) {
      if (obj.hasOwnProperty(_key)) {
        sortedKeys.push(_key);
      }
    }
    sortedKeys.sort();
    for (i = 0; i < sortedKeys.length; i += 1) {
      _key = sortedKeys[i];
      canonicalizedObj[_key] = canonicalize(obj[_key], stack, replacementStack, replacer, _key);
    }
    stack.pop();
    replacementStack.pop();
  } else {
    canonicalizedObj = obj;
  }
  return canonicalizedObj;
}
var arrayDiff = new Diff();
arrayDiff.tokenize = function(value) {
  return value.slice();
};
arrayDiff.join = arrayDiff.removeEmpty = function(value) {
  return value;
};

// src/lib/data-conversion/outilne-to-json.ts
var addNewNode = (state2, level2, text2, root = 1) => {
  state2.currentNode = {
    content: text2,
    children: []
  };
  for (const key of Object.keys(state2.currentParents)) {
    const parentLevel = +key;
    if (parentLevel >= level2) {
      delete state2.currentParents[key];
    }
  }
  if (level2 === root) {
    state2.tree.push(state2.currentNode);
  }
  state2.currentParents[level2] = state2.currentNode;
  const parent = state2.currentParents[level2 - 1];
  if (parent) {
    parent.children.push(state2.currentNode);
  } else if (level2 > root)
    throw new Error(`Item [${text2}] does not have a parent`);
};
var updateCurrentNode = (state2, text2) => {
  if (state2.currentNode) {
    if (state2.currentNode.content)
      state2.currentNode.content += "\n";
    state2.currentNode.content += text2;
  } else if (text2.trim()) {
    state2.currentNode = {
      content: text2,
      children: []
    };
    state2.tree.push(state2.currentNode);
  }
};
var outlineToJson = (input) => {
  const lines = input.split("\n");
  const state2 = {
    currentParents: {},
    currentNode: null,
    tree: []
  };
  for (const line of lines) {
    if (parseDelimiter(line))
      throw new Error("Outline has a section annotation");
    const outlineMatch = line.match(/^(\t*)- (.*)/);
    if (outlineMatch) {
      const level2 = outlineMatch[1].length + 1;
      addNewNode(state2, level2, outlineMatch[2]);
    } else {
      updateCurrentNode(state2, line.replace(/^\t* {2}|/g, ""));
    }
  }
  return state2.tree;
};

// src/lib/data-conversion/helpers/find-highest-heading-level.ts
var findHighestHeadingLevel = (lines) => {
  return lines.reduce((acc, val) => {
    const match = val.match(/^(#+) +(.*)$/);
    if (match) {
      const level2 = match[1].length;
      if (level2 < acc)
        acc = level2;
    }
    return acc;
  }, 6);
};

// src/lib/data-conversion/headings-to-json.ts
var headingsToJson = (input) => {
  const lines = input.split("\n");
  const highestHeadingLevel = findHighestHeadingLevel(lines);
  const state2 = {
    currentParents: {},
    currentNode: null,
    tree: []
  };
  for (const line of lines) {
    if (parseDelimiter(line))
      throw new Error("input has a section");
    const match = line.match(/^(#+) (.+)/);
    if (match) {
      const level2 = match[1].length;
      addNewNode(state2, level2, line, highestHeadingLevel);
    } else {
      updateCurrentNode(state2, line);
    }
  }
  return state2.tree;
};

// src/lib/data-conversion/helpers/correct-headings.ts
var correctHeadings = (markdown) => {
  const lines = markdown.split("\n");
  const headingRegex = /^(#+) +(.*)$/;
  const highestHeadingLevel = findHighestHeadingLevel(lines);
  const state2 = {
    previousLevel: 0,
    previousCorrectedLevel: 0,
    previousLevels: []
  };
  const updatedLines = [];
  for (const line of lines) {
    const match = line.match(headingRegex);
    let updatedLine = null;
    if (match) {
      const level2 = match[1].length;
      const text2 = match[2];
      let correctedLevel;
      const parentIndex = state2.previousLevels.findLastIndex(
        (l) => l.level < level2
      );
      const parent = state2.previousLevels[parentIndex];
      if (!parent) {
        correctedLevel = highestHeadingLevel;
      } else if (level2 > state2.previousLevel) {
        correctedLevel = state2.previousCorrectedLevel + 1;
      } else if (level2 < state2.previousLevel) {
        correctedLevel = Math.min(
          highestHeadingLevel,
          level2,
          state2.previousCorrectedLevel - 1
        );
        if (parent) {
          if (correctedLevel <= parent.level && level2 > parent.level) {
            correctedLevel = parent.correctedLevel + 1;
          }
        }
      } else if (level2 === state2.previousLevel) {
        correctedLevel = state2.previousCorrectedLevel;
      } else {
        correctedLevel = level2;
      }
      updatedLine = `${"#".repeat(correctedLevel)} ${text2}`;
      state2.previousLevel = level2;
      state2.previousCorrectedLevel = correctedLevel;
      state2.previousLevels.push({ level: level2, correctedLevel });
    }
    if (updatedLine)
      updatedLines.push(updatedLine);
    else
      updatedLines.push(line);
  }
  return updatedLines.join("\n");
};

// src/lib/data-conversion/headings-to-sections.ts
var headingsToSections = (input) => {
  const tree = headingsToJson(correctHeadings(input));
  if (tree.length === 1 && tree[0].children.length === 0)
    return input;
  return jsonToSections(tree);
};

// src/lib/data-conversion/paragraphs-to-sections.ts
var splitByParagraph = (text2) => {
  return text2.split(/\n\s*\n/);
};
var paragraphsToSections = (input) => {
  const paragraphs = splitByParagraph(input);
  if (paragraphs.length === 1)
    return input;
  const tree = paragraphs.map((p) => ({
    content: p,
    children: []
  }));
  return jsonToSections(tree);
};

// src/lib/data-conversion/outline-to-sections.ts
var outlineToSections = (input) => {
  const tree = outlineToJson(input);
  if (tree.length === 1 && tree[0].children.length === 0)
    return input;
  return jsonToSections(tree);
};

// src/stores/document/reducers/split-node/helpers/split-text.ts
var splitText = (text2, mode) => {
  if (mode === "headings") {
    return headingsToSections(text2);
  } else if (mode === "paragraphs") {
    return paragraphsToSections(text2);
  } else {
    return outlineToSections(text2);
  }
};

// src/view/modals/split-node-modal/helpers/map-content.ts
var escapeHtmlComment = (text2) => {
  return text2.replace(/</g, "&lt;").replace(/>/g, "&gt;");
};
var makeTabsVisible = (text2) => {
  return text2.replace(/\t/g, "&nbsp;&nbsp;&nbsp;&nbsp;");
};
var makeNewlinesVisible = (text2) => {
  return text2.replace(/\n/g, "<br>");
};
var mapContent = (text2, mode) => {
  let newContent = text2;
  if (mode) {
    try {
      newContent = splitText(text2, mode);
    } catch (e) {
      onPluginError(e, "command", { text: text2, mode });
    }
  }
  const differences = diffWords(text2, newContent);
  return differences.map((part) => {
    const style = part.added ? "color:green; background-color:lightgreen" : part.removed ? "color:red; background-color:#ffdddd" : "color: grey";
    const escapedComments = escapeHtmlComment(part.value);
    const visibleTabs = makeTabsVisible(escapedComments);
    const value = makeNewlinesVisible(visibleTabs);
    return `<span style="${style}">${value}</span>`;
  }).join("");
};

// src/lib/format-detection/has-n-paragraph.ts
var hasNParagraph = (text2, n = 2) => splitByParagraph(text2).length >= n;

// src/view/modals/split-node-modal/split-node-modal.ts
var SplitNodeModal = class extends import_obsidian6.Modal {
  constructor(props) {
    super(props.plugin.app);
    this.props = props;
    this.subscriptions = /* @__PURE__ */ new Set();
    this.open = () => {
      this.setTitle("Choose how to split this card");
      this.initState();
      new modal_content_default({
        target: this.contentEl,
        props: {
          state: this.state,
          props: this.props
        }
      });
      const promise = new Promise((resolve) => {
        this.resolve = resolve;
      });
      super.open();
      return promise;
    };
    this.close = () => {
      this.resolve(void 0);
      super.close();
      for (const unsub of this.subscriptions) {
        unsub();
      }
    };
    this.initState = () => {
      const content = this.props.nodeContent;
      this.state = {
        content: writable(content),
        mode: writable(null),
        disabledModes: /* @__PURE__ */ new Set()
      };
      const hasHeadings = hasNHeadings(content);
      const _isOutline = isOutline(content);
      const hasParagraphs = hasNParagraph(content);
      if (!hasHeadings) {
        this.state.disabledModes.add("headings");
      }
      if (!_isOutline) {
        this.state.disabledModes.add("outline");
      }
      if (!hasParagraphs) {
        this.state.disabledModes.add("paragraphs");
      }
      if (hasHeadings) {
        this.state.mode.set("headings");
      } else if (_isOutline) {
        this.state.mode.set("outline");
      } else if (hasParagraphs) {
        this.state.mode.set("paragraphs");
      }
      const unsubFromMod = this.state.mode.subscribe((mode) => {
        if (mode)
          this.state.content.set(mapContent(content, mode));
      });
      this.state.content.set(mapContent(content, get_store_value(this.state.mode)));
      this.subscriptions.add(unsubFromMod);
    };
  }
};

// src/view/modals/split-node-modal/open-split-node-modal.ts
var openSplitNodeModal = async (view) => {
  const activeNode = view.viewStore.getValue().document.activeNode;
  if (!activeNode)
    return;
  const nodeContent = view.documentStore.getValue().document.content[activeNode].content;
  const modal = new SplitNodeModal({
    plugin: view.plugin,
    callbacks: {
      accept: () => {
        modal.close();
        const newContent = get_store_value(modal.state.content);
        const mode = get_store_value(modal.state.mode);
        if (mode && newContent !== nodeContent) {
          view.documentStore.dispatch({
            type: "DOCUMENT/SPLIT_NODE",
            payload: {
              target: activeNode,
              mode
            }
          });
        }
      },
      reject: () => {
        modal.close();
      }
    },
    nodeContent
  });
  await modal.open();
};

// src/helpers/load-custom-icons.ts
var import_obsidian7 = require("obsidian");
var svgWrapper = (innerSVG, mode = "stroke") => `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="svg-icon" ${mode === "fill" ? 'stroke="transparent" fill="currentColor"' : 'stroke="currentColor" fill="transparent"'}> ${innerSVG.trim().replace(/\n/g, "")}</svg>`;
var cards = {
  name: "lineage-cards",
  svg: `
    <path
    d="m 13.115181,16.644424 h 6.605231 v 5.578301 H 13.115181 Z M 4.3082043,9.2066877 H 10.913436 V 14.784989 H 4.3082043 Z m 8.8069767,0 h 6.605231 v 5.5783013 h -6.605231 z m 0,-7.4377346 h 6.605231 V 7.347254 h -6.605231 z"
    />
  `,
  mode: "fill"
};
var split = {
  name: "lineage-split",
  svg: `<path d="M16 3h5v5"/><path d="M8 3H3v5"/><path d="M12 22v-8.3a4 4 0 0 0-1.172-2.872L3 3"/><path d="m15 9 6-6"/>`,
  mode: "stroke"
};
var customIcons = { cards, split };
var loadCustomIcons = () => {
  for (const icon of Object.values(customIcons)) {
    (0, import_obsidian7.addIcon)(icon.name, svgWrapper(icon.svg, icon.mode));
  }
};

// src/view/actions/context-menu/card-context-menu/helpers/insert-block-id.ts
var getExistingBlockId = (lines) => {
  const reversed = [...lines].reverse();
  for (let line of reversed) {
    line = line.trim();
    const match = /\s+\^([a-zA-Z0-9]{4,})$/.exec(line);
    if (match) {
      return match[1];
    }
  }
};
var generateBlockId = () => Math.random().toString(36).substring(2, 8);
var insertBlockId = (text2, __id__) => {
  const lines = text2.trimEnd().split("\n");
  const existingId = getExistingBlockId(lines);
  if (existingId) {
    return {
      blockId: existingId,
      text: text2
    };
  } else {
    const lastLine = lines[lines.length - 1];
    let blockId = null;
    if (lastLine) {
      blockId = __id__ || generateBlockId();
      lines[lines.length - 1] = lines[lines.length - 1] + ` ^${blockId}`;
      return {
        blockId,
        text: lines.join("\n")
      };
    }
  }
};

// src/view/actions/context-menu/card-context-menu/helpers/copy-link-to-block.ts
var import_obsidian8 = require("obsidian");
var copyLinkToBlock = async (view) => {
  const file = view.file;
  if (!file)
    return;
  const activeNode = view.viewStore.getValue().document.activeNode;
  const documentState = view.documentStore.getValue();
  const content = documentState.document.content[activeNode];
  const text2 = content?.content;
  const output = insertBlockId(text2);
  if (output) {
    const fileName = file.basename;
    view.documentStore.dispatch({
      type: "DOCUMENT/SET_NODE_CONTENT",
      payload: {
        content: output.text,
        nodeId: activeNode
      }
    });
    const link = `[[${fileName}#^${output.blockId}]]`;
    await navigator.clipboard.writeText(link);
    new import_obsidian8.Notice("Link copied to clipboard");
  } else {
    new import_obsidian8.Notice("Could not copy link to clipboard");
  }
};

// src/lib/tree-utils/find/find-node-column.ts
var findNodeColumn = (columns, nodeId) => {
  for (let i = 0; i < columns.length; i++) {
    const column = columns[i];
    for (const group of column.groups) {
      if (group.nodes.find((n) => n === nodeId))
        return i;
    }
  }
  return -1;
};

// src/view/actions/context-menu/card-context-menu/helpers/export-column.ts
var import_obsidian9 = require("obsidian");
var exportColumn = async (view) => {
  const activeNode = view.viewStore.getValue().document.activeNode;
  invariant(activeNode);
  const document2 = view.documentStore.getValue().document;
  const columnIndex = findNodeColumn(document2.columns, activeNode);
  const column = document2.columns[columnIndex];
  invariant(column);
  const nodes = column.groups.map((g) => g.nodes).flat();
  const content = nodes.map((n) => document2.content[n].content);
  const text2 = content.filter((c) => c.trim().length > 0).join("\n\n");
  if (!text2.trim()) {
    new import_obsidian9.Notice("This column is empty");
    return;
  }
  const file = view.file;
  invariant(file);
  invariant(file.parent);
  const newFile = await createNewFile(
    view.plugin,
    file.parent,
    text2,
    `${file.basename} - column ${columnIndex + 1}`
  );
  await openFile(view.plugin, newFile, "split");
};

// src/view/actions/context-menu/card-context-menu/show-card-context-menu.ts
var showCardContextMenu = (event, view) => {
  const menu = new import_obsidian10.Menu();
  const multipleNodesAreSelected = view.viewStore.getValue().document.selectedNodes.size > 1;
  menu.addItem(
    (item) => item.setTitle("Split card").setIcon(customIcons.split.name).onClick(() => {
      openSplitNodeModal(view);
    })
  );
  menu.addSeparator();
  menu.addItem(
    (item) => item.setTitle("Merge with the card above").setIcon("merge").onClick(() => {
      mergeNode(view, "up");
    }).setDisabled(multipleNodesAreSelected)
  );
  menu.addItem(
    (item) => item.setTitle("Merge with the card below").setIcon("merge").onClick(() => {
      mergeNode(view, "down");
    }).setDisabled(multipleNodesAreSelected)
  );
  menu.addSeparator();
  menu.addItem(
    (item) => item.setTitle("Copy link to block").setIcon("links-coming-in").onClick(() => {
      copyLinkToBlock(view);
    })
  );
  menu.addSeparator();
  menu.addItem(
    (item) => item.setTitle("Copy").setIcon("documents").onClick(() => {
      copyNode(view);
    })
  );
  menu.addItem(
    (item) => item.setTitle("Cut").setIcon("scissors").onClick(() => {
      cutNode(view);
    })
  );
  menu.addItem(
    (item) => item.setTitle("Paste").setIcon("paste").onClick(() => {
      pasteNode(view);
    })
  );
  menu.addSeparator();
  menu.addItem(
    (item) => item.setTitle("Extract branch").setIcon(customIcons.cards.name).onClick(() => {
      extractBranch(view);
    }).setDisabled(multipleNodesAreSelected)
  );
  menu.addItem(
    (item) => item.setTitle("Export column").setIcon("file-text").onClick(() => {
      exportColumn(view);
    }).setDisabled(multipleNodesAreSelected)
  );
  menu.showAtMouseEvent(event);
};

// src/view/actions/context-menu/card-context-menu/card-context-menu-predicate.ts
var cardContextMenuPredicate = (e) => {
  const target = e.target;
  return !target.hasClass("drag-handle") && Boolean(target.closest(".active-node.node-border--active"));
};

// src/view/actions/context-menu/view-context-menu/view-context-menu-predicate.ts
var viewContextMenuPredicate = (e) => {
  const target = e.target;
  return target.hasClass("column-buffer") || target.hasClass("columns") || target.hasClass("columns-container");
};

// src/view/actions/context-menu/view-context-menu/show-view-context-menu.ts
var import_obsidian11 = require("obsidian");

// src/lib/data-conversion/sections-to-json.ts
var depthLevel = (number) => {
  if (number.includes(".")) {
    return number.split(".").length;
  } else
    return /\d+/.test(number) ? 1 : 0;
};
var trimCurrentNode = (node) => {
  if (node) {
    node.content = node.content.trim();
  }
};
var sectionsToJson = (text2) => {
  const lines = text2.split("\n");
  const map = {};
  const tree = [];
  let currentNode = null;
  let currentParentNumber = "";
  for (const line of lines) {
    const sectionNumber = parseDelimiter(line);
    if (sectionNumber) {
      const [parent, , full] = sectionNumber;
      const isASibling = parent === currentParentNumber;
      const newNode = {
        content: "",
        children: []
      };
      map[full] = newNode;
      if (isASibling) {
        if (currentNode)
          trimCurrentNode(currentNode);
        const parentNode = map[parent];
        if (parentNode) {
          parentNode.children.push(newNode);
        } else {
          tree.push(newNode);
        }
        currentNode = newNode;
      } else {
        const isChild = depthLevel(parent) > depthLevel(currentParentNumber);
        if (isChild) {
          if (!currentNode) {
            throw new Error(lang.error_parent_not_found(full));
          }
          trimCurrentNode(currentNode);
          currentNode.children.push(newNode);
          currentNode = newNode;
        } else {
          if (!parent) {
            if (currentNode)
              trimCurrentNode(currentNode);
            tree.push(newNode);
            currentNode = newNode;
          } else {
            const parentNode = map[parent];
            if (!parentNode) {
              throw new Error(lang.error_parent_not_found(full));
            }
            if (currentNode)
              trimCurrentNode(currentNode);
            parentNode.children.push(newNode);
            currentNode = newNode;
          }
        }
      }
      currentParentNumber = parent;
    } else {
      if (currentNode) {
        if (currentNode.content)
          currentNode.content += "\n";
        currentNode.content += line;
      } else if (line.trim()) {
        currentNode = {
          content: line,
          children: []
        };
        tree.push(currentNode);
      }
    }
  }
  return tree;
};

// src/lib/data-conversion/json-to-text.ts
var jsonToText = (nodes) => {
  return jsonToSections(nodes, void 0, void 0, false);
};

// src/obsidian/commands/helpers/export-document/prepare-exported-document.ts
var prepareExportedDocument = (fileData, basename, format2) => {
  const { data, frontmatter } = extractFrontmatter(fileData);
  const tree = format2 === "outline" ? outlineToJson(data) : sectionsToJson(data);
  if (tree.length < 2 && tree[0].children.length == 0) {
    throw new Error(`File ${basename} does not appear to be a tree`);
  }
  return (frontmatter ? frontmatter + "\n" : "") + jsonToText(tree);
};

// src/obsidian/commands/helpers/export-document/export-document.ts
var exportDocument = async (view) => {
  try {
    const file = view.file;
    if (!file)
      return;
    if (!file.parent)
      return;
    const fileData = await view.plugin.app.vault.read(file);
    const format2 = getDocumentFormat(view);
    const output = prepareExportedDocument(fileData, file.basename, format2);
    const newFile = await createNewFile(
      view.plugin,
      file.parent,
      output,
      file.basename
    );
    if (newFile) {
      await openFile(view.plugin, newFile, "split");
    }
  } catch (e) {
    onPluginError(e, "command", { type: "export-document" });
  }
};

// src/view/actions/context-menu/view-context-menu/show-view-context-menu.ts
var showViewContextMenu = (event, view) => {
  const file = view.file;
  if (!file)
    return;
  const menu = new import_obsidian11.Menu();
  const format2 = getDocumentFormat(view);
  const isOutline2 = format2 === "outline";
  const _hasHeading = hasNHeadings(view.data, 1);
  menu.addItem(
    (item) => item.setTitle(lang.format_headings).setIcon("heading-1").onClick(() => {
      saveNodeContent(view);
      view.documentStore.dispatch({
        type: "DOCUMENT/FORMAT_HEADINGS"
      });
    }).setDisabled(!_hasHeading)
  );
  menu.addSeparator();
  menu.addItem(
    (item) => item.setTitle(lang.change_format_to_document).setIcon("file-cog").onClick(() => {
      setDocumentFormat(view.plugin, file.path, "sections");
    }).setChecked(!isOutline2)
  );
  menu.addItem(
    (item) => item.setTitle(lang.change_format_to_outline).setIcon("file-cog").onClick(() => {
      setDocumentFormat(view.plugin, file.path, "outline");
    }).setChecked(isOutline2)
  );
  menu.addSeparator();
  menu.addItem(
    (item) => item.setTitle(lang.export_document).setIcon("file-symlink").onClick(() => {
      exportDocument(view);
    })
  );
  menu.showAtMouseEvent(event);
};

// src/view/actions/context-menu/context-menu.ts
var contextMenu = (element2, view) => {
  const listener = (e) => {
    if (cardContextMenuPredicate(e)) {
      if (e instanceof MouseEvent)
        showCardContextMenu(e, view);
      else
        showCardContextMenu(new MouseEvent("contextmenu", e), view);
    } else if (viewContextMenuPredicate(e)) {
      if (e instanceof MouseEvent)
        showViewContextMenu(e, view);
      else
        showViewContextMenu(new MouseEvent("contextmenu", e), view);
    }
  };
  element2.addEventListener("contextmenu", listener);
  let unsubFromLongPress = null;
  if (import_obsidian12.Platform.isMobile) {
    unsubFromLongPress = onLongPress(
      element2,
      listener,
      cardContextMenuPredicate
    );
  }
  return {
    destroy: () => {
      element2.removeEventListener("contextmenu", listener);
      if (unsubFromLongPress) {
        unsubFromLongPress();
      }
    }
  };
};

// src/view/actions/close-modals-when-clicking-outside.ts
var closeModalsWhenClickingOutside = (element2, view) => {
  const onClick = (e) => {
    if (e.button === 0) {
      view.viewStore.dispatch({
        type: "CLOSE_MODALS"
      });
    }
  };
  element2.addEventListener("mouseup", onClick);
  return {
    destroy: () => {
      element2.removeEventListener("mouseup", onClick);
    }
  };
};

// src/stores/view/derived/selected-nodes-store.ts
var selectedNodesStore = (view) => derived(view.viewStore, (state2) => state2.document.selectedNodes);

// src/view/components/container/container.svelte
function add_css14(target) {
  append_styles(target, "svelte-ttmvm9", ":root{--container-left-padding:100px}.columns-container.svelte-ttmvm9{position:relative;flex:1;height:100%;width:100%;display:flex;align-items:center;justify-content:start;padding-left:var(--container-left-padding);overflow-y:hidden;overflow-x:auto}.is-mobile{--container-left-padding:10px}.columns.svelte-ttmvm9{display:flex;align-items:center;width:100%}.hide-scrollbars.svelte-ttmvm9{--scrollbar-thumb-bg:transparent;--scrollbar-active-thumb-bg:transparent;--scrollbar-bg:transparent}.hide-scrollbars.svelte-ttmvm9::-webkit-scrollbar{display:none}.limit-card-height.svelte-ttmvm9{& .preview-container {\n            max-height: 65vh;\n        };& .editor-container {\n            max-height: 65vh;\n        }}");
}
function get_each_context5(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[22] = list[i];
  return child_ctx;
}
function create_if_block_14(ctx) {
  let columnsbuffer;
  let current;
  columnsbuffer = new columns_buffer_default({});
  return {
    c() {
      create_component(columnsbuffer.$$.fragment);
    },
    m(target, anchor) {
      mount_component(columnsbuffer, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(columnsbuffer.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(columnsbuffer.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(columnsbuffer, detaching);
    }
  };
}
function create_each_block5(key_1, ctx) {
  let first;
  let column_1;
  let current;
  column_1 = new column_default({
    props: {
      columnId: (
        /*column*/
        ctx[22].id
      ),
      dndChildGroups: (
        /*$dnd*/
        ctx[5].childGroups
      ),
      parentNodes: (
        /*parentNodes*/
        ctx[1]
      ),
      activeGroup: (
        /*$activeBranch*/
        ctx[0].group
      ),
      activeChildGroups: (
        /*$activeBranch*/
        ctx[0].childGroups
      ),
      activeNode: (
        /*$activeNode*/
        ctx[6]
      ),
      editedNode: (
        /*$editing*/
        ctx[7].activeNodeId
      ),
      disableEditConfirmation: (
        /*$editing*/
        ctx[7].disableEditConfirmation
      ),
      searchQuery: (
        /*$search*/
        ctx[8].query
      ),
      searchResults: (
        /*$search*/
        ctx[8].results
      ),
      searching: (
        /*$search*/
        ctx[8].searching
      ),
      idSection: (
        /*$idSection*/
        ctx[9]
      ),
      selectedNodes: (
        /*$selectedNodes*/
        ctx[10]
      )
    }
  });
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      create_component(column_1.$$.fragment);
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      mount_component(column_1, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const column_1_changes = {};
      if (dirty & /*$columns*/
      16)
        column_1_changes.columnId = /*column*/
        ctx[22].id;
      if (dirty & /*$dnd*/
      32)
        column_1_changes.dndChildGroups = /*$dnd*/
        ctx[5].childGroups;
      if (dirty & /*parentNodes*/
      2)
        column_1_changes.parentNodes = /*parentNodes*/
        ctx[1];
      if (dirty & /*$activeBranch*/
      1)
        column_1_changes.activeGroup = /*$activeBranch*/
        ctx[0].group;
      if (dirty & /*$activeBranch*/
      1)
        column_1_changes.activeChildGroups = /*$activeBranch*/
        ctx[0].childGroups;
      if (dirty & /*$activeNode*/
      64)
        column_1_changes.activeNode = /*$activeNode*/
        ctx[6];
      if (dirty & /*$editing*/
      128)
        column_1_changes.editedNode = /*$editing*/
        ctx[7].activeNodeId;
      if (dirty & /*$editing*/
      128)
        column_1_changes.disableEditConfirmation = /*$editing*/
        ctx[7].disableEditConfirmation;
      if (dirty & /*$search*/
      256)
        column_1_changes.searchQuery = /*$search*/
        ctx[8].query;
      if (dirty & /*$search*/
      256)
        column_1_changes.searchResults = /*$search*/
        ctx[8].results;
      if (dirty & /*$search*/
      256)
        column_1_changes.searching = /*$search*/
        ctx[8].searching;
      if (dirty & /*$idSection*/
      512)
        column_1_changes.idSection = /*$idSection*/
        ctx[9];
      if (dirty & /*$selectedNodes*/
      1024)
        column_1_changes.selectedNodes = /*$selectedNodes*/
        ctx[10];
      column_1.$set(column_1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(column_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(column_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(first);
      }
      destroy_component(column_1, detaching);
    }
  };
}
function create_else_block3(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      set_style(div, "min-width", "50px");
      set_style(div, "min-height", "10px");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
function create_if_block8(ctx) {
  let columnsbuffer;
  let current;
  columnsbuffer = new columns_buffer_default({});
  return {
    c() {
      create_component(columnsbuffer.$$.fragment);
    },
    m(target, anchor) {
      mount_component(columnsbuffer, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(columnsbuffer.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(columnsbuffer.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(columnsbuffer, detaching);
    }
  };
}
function create_fragment55(ctx) {
  let div1;
  let div0;
  let t0;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let t1;
  let current_block_type_index;
  let if_block1;
  let div1_class_value;
  let closeModalsWhenClickingOutside_action;
  let contextMenu_action;
  let scrollOnDndX_action;
  let current;
  let mounted;
  let dispose;
  let if_block0 = (
    /*$scrolling*/
    (ctx[2] === "fixed-position" || /*$scrolling*/
    ctx[2] === "keep-active-card-at-center") && create_if_block_14(ctx)
  );
  let each_value = ensure_array_like(
    /*$columns*/
    ctx[4]
  );
  const get_key = (ctx2) => (
    /*column*/
    ctx2[22].id
  );
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context5(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block5(key, child_ctx));
  }
  const if_block_creators = [create_if_block8, create_else_block3];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*$scrolling*/
      ctx2[2] === "fixed-position" || /*$scrolling*/
      ctx2[2] === "keep-active-card-at-center"
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t1 = space();
      if_block1.c();
      attr(div0, "class", "columns svelte-ttmvm9");
      attr(div1, "class", div1_class_value = null_to_empty("columns-container " + /*$scrolling*/
      (ctx[2] === "fixed-position" || /*$scrolling*/
      ctx[2] === "keep-active-card-at-center" ? "hide-scrollbars" : "") + /*$limitPreviewHeight*/
      (ctx[3] ? " limit-card-height" : "")) + " svelte-ttmvm9");
      attr(div1, "id", "columns-container");
      attr(div1, "tabindex", "0");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      if (if_block0)
        if_block0.m(div0, null);
      append(div0, t0);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div0, null);
        }
      }
      append(div0, t1);
      if_blocks[current_block_type_index].m(div0, null);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(closeModalsWhenClickingOutside_action = closeModalsWhenClickingOutside.call(
            null,
            div1,
            /*view*/
            ctx[11]
          )),
          action_destroyer(contextMenu_action = contextMenu.call(
            null,
            div1,
            /*view*/
            ctx[11]
          )),
          action_destroyer(scrollOnDndX_action = scrollOnDndX.call(null, div1))
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (
        /*$scrolling*/
        ctx2[2] === "fixed-position" || /*$scrolling*/
        ctx2[2] === "keep-active-card-at-center"
      ) {
        if (if_block0) {
          if (dirty & /*$scrolling*/
          4) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_14(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div0, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (dirty & /*$columns, $dnd, parentNodes, $activeBranch, $activeNode, $editing, $search, $idSection, $selectedNodes*/
      2035) {
        each_value = ensure_array_like(
          /*$columns*/
          ctx2[4]
        );
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, div0, outro_and_destroy_block, create_each_block5, t1, get_each_context5);
        check_outros();
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index !== previous_block_index) {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block1 = if_blocks[current_block_type_index];
        if (!if_block1) {
          if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block1.c();
        } else {
        }
        transition_in(if_block1, 1);
        if_block1.m(div0, null);
      }
      if (!current || dirty & /*$scrolling, $limitPreviewHeight*/
      12 && div1_class_value !== (div1_class_value = null_to_empty("columns-container " + /*$scrolling*/
      (ctx2[2] === "fixed-position" || /*$scrolling*/
      ctx2[2] === "keep-active-card-at-center" ? "hide-scrollbars" : "") + /*$limitPreviewHeight*/
      (ctx2[3] ? " limit-card-height" : "")) + " svelte-ttmvm9")) {
        attr(div1, "class", div1_class_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      if (if_block0)
        if_block0.d();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
      if_blocks[current_block_type_index].d();
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance54($$self, $$props, $$invalidate) {
  let $activeBranch;
  let $scrolling;
  let $limitPreviewHeight;
  let $columns;
  let $dnd;
  let $activeNode;
  let $editing;
  let $search;
  let $idSection;
  let $selectedNodes;
  const view = getView();
  const columns = columnsStore(view);
  component_subscribe($$self, columns, (value) => $$invalidate(4, $columns = value));
  const scrolling = scrollingModeStore(view);
  component_subscribe($$self, scrolling, (value) => $$invalidate(2, $scrolling = value));
  const dnd = dndStore(view);
  component_subscribe($$self, dnd, (value) => $$invalidate(5, $dnd = value));
  const activeBranch = activeBranchStore(view);
  component_subscribe($$self, activeBranch, (value) => $$invalidate(0, $activeBranch = value));
  const activeNode = activeNodeStore(view);
  component_subscribe($$self, activeNode, (value) => $$invalidate(6, $activeNode = value));
  const selectedNodes = selectedNodesStore(view);
  component_subscribe($$self, selectedNodes, (value) => $$invalidate(10, $selectedNodes = value));
  const editing = documentStateStore(view);
  component_subscribe($$self, editing, (value) => $$invalidate(7, $editing = value));
  const search2 = searchStore(view);
  component_subscribe($$self, search2, (value) => $$invalidate(8, $search = value));
  const limitPreviewHeight = limitPreviewHeightStore(view);
  component_subscribe($$self, limitPreviewHeight, (value) => $$invalidate(3, $limitPreviewHeight = value));
  const idSection = idSectionStore(view);
  component_subscribe($$self, idSection, (value) => $$invalidate(9, $idSection = value));
  let parentNodes = /* @__PURE__ */ new Set();
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$activeBranch*/
    1) {
      $:
        $$invalidate(1, parentNodes = new Set($activeBranch.sortedParentNodes));
    }
  };
  return [
    $activeBranch,
    parentNodes,
    $scrolling,
    $limitPreviewHeight,
    $columns,
    $dnd,
    $activeNode,
    $editing,
    $search,
    $idSection,
    $selectedNodes,
    view,
    columns,
    scrolling,
    dnd,
    activeBranch,
    activeNode,
    selectedNodes,
    editing,
    search2,
    limitPreviewHeight,
    idSection
  ];
}
var Container = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance54, create_fragment55, safe_not_equal, {}, add_css14);
  }
};
var container_default = Container;

// src/view/components/container/breadcrumbs/breadcrumbs-item.svelte
function add_css15(target) {
  append_styles(target, "svelte-1q9w33n", ".separator.svelte-1q9w33n{padding:2px 1px;color:var(--text-faint);min-width:8px}.breadcrumbs-item.svelte-1q9w33n{height:30px;border-bottom:1px solid var(--background-modifier-border);color:var(--text-muted);background-color:var(--interactive-normal);cursor:pointer;padding:2px 4px;border-radius:var(--radius-s);max-width:350px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;font-size:14px;line-height:25px}.breadcrumbs-item.svelte-1q9w33n:hover{background-color:var(--interactive-hover)}.breadcrumbs-item.svelte-1q9w33n:last-child{border-bottom:none}.section-number.svelte-1q9w33n{font-style:italic;color:var(--text-faint)}");
}
function create_if_block9(ctx) {
  let span;
  return {
    c() {
      span = element("span");
      span.textContent = "/";
      attr(span, "class", "separator svelte-1q9w33n");
    },
    m(target, anchor) {
      insert(target, span, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_fragment56(ctx) {
  let t0;
  let span;
  let t1_value = (
    /*content*/
    (ctx[2] || /*section*/
    ctx[1]) + ""
  );
  let t1;
  let span_aria_label_value;
  let span_class_value;
  let mounted;
  let dispose;
  let if_block = (
    /*index*/
    ctx[0] > 0 && create_if_block9(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      t0 = space();
      span = element("span");
      t1 = text(t1_value);
      attr(span, "aria-label", span_aria_label_value = /*section*/
      ctx[1] + "\n" + /*content*/
      ctx[2]);
      attr(span, "class", span_class_value = null_to_empty(`breadcrumbs-item ${/*content*/
      ctx[2] ? "" : "section-number"}`) + " svelte-1q9w33n");
      attr(span, "data-tooltip-position", "top");
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, t0, anchor);
      insert(target, span, anchor);
      append(span, t1);
      if (!mounted) {
        dispose = listen(
          span,
          "click",
          /*onClick*/
          ctx[3]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (
        /*index*/
        ctx2[0] > 0
      ) {
        if (if_block) {
        } else {
          if_block = create_if_block9(ctx2);
          if_block.c();
          if_block.m(t0.parentNode, t0);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty & /*content, section*/
      6 && t1_value !== (t1_value = /*content*/
      (ctx2[2] || /*section*/
      ctx2[1]) + ""))
        set_data(t1, t1_value);
      if (dirty & /*section, content*/
      6 && span_aria_label_value !== (span_aria_label_value = /*section*/
      ctx2[1] + "\n" + /*content*/
      ctx2[2])) {
        attr(span, "aria-label", span_aria_label_value);
      }
      if (dirty & /*content*/
      4 && span_class_value !== (span_class_value = null_to_empty(`breadcrumbs-item ${/*content*/
      ctx2[2] ? "" : "section-number"}`) + " svelte-1q9w33n")) {
        attr(span, "class", span_class_value);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(span);
      }
      if (if_block)
        if_block.d(detaching);
      mounted = false;
      dispose();
    }
  };
}
function instance55($$self, $$props, $$invalidate) {
  let { parentId } = $$props;
  let { index } = $$props;
  let { section } = $$props;
  let { content } = $$props;
  const view = getView();
  const viewStore = view.viewStore;
  const onClick = () => {
    viewStore.dispatch({
      type: "DOCUMENT/SET_ACTIVE_NODE",
      payload: { id: parentId }
    });
  };
  $$self.$$set = ($$props2) => {
    if ("parentId" in $$props2)
      $$invalidate(4, parentId = $$props2.parentId);
    if ("index" in $$props2)
      $$invalidate(0, index = $$props2.index);
    if ("section" in $$props2)
      $$invalidate(1, section = $$props2.section);
    if ("content" in $$props2)
      $$invalidate(2, content = $$props2.content);
  };
  return [index, section, content, onClick, parentId];
}
var Breadcrumbs_item = class extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance55,
      create_fragment56,
      safe_not_equal,
      {
        parentId: 4,
        index: 0,
        section: 1,
        content: 2
      },
      add_css15
    );
  }
};
var breadcrumbs_item_default = Breadcrumbs_item;

// src/view/components/container/breadcrumbs/breadcrumbs.svelte
function add_css16(target) {
  append_styles(target, "svelte-576atj", ".breadcrumbs-container.svelte-576atj{z-index:var(--z-index-breadcrumbs);left:var(--size-4-2);bottom:var(--size-4-2);display:flex;position:absolute;max-width:calc(100% - var(--size-4-2) * 2)}.breadcrumbs.svelte-576atj{display:flex;align-items:center;justify-content:center;border-radius:var(--radius-s);background-color:var(--interactive-normal);box-shadow:var(--input-shadow);max-width:100%;overflow:auto;font-size:var(--file-header-font-size);color:var(--text-muted);gap:0}");
}
function get_each_context6(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[7] = list[i];
  child_ctx[9] = i;
  return child_ctx;
}
function create_each_block6(key_1, ctx) {
  let first;
  let item;
  let current;
  item = new breadcrumbs_item_default({
    props: {
      parentId: (
        /*parentId*/
        ctx[7]
      ),
      index: (
        /*index*/
        ctx[9]
      ),
      content: (
        /*$contents*/
        ctx[1][
          /*parentId*/
          ctx[7]
        ]?.content
      ),
      section: (
        /*$sections*/
        ctx[2][
          /*parentId*/
          ctx[7]
        ]
      )
    }
  });
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      create_component(item.$$.fragment);
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      mount_component(item, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const item_changes = {};
      if (dirty & /*$activeBranch*/
      1)
        item_changes.parentId = /*parentId*/
        ctx[7];
      if (dirty & /*$activeBranch*/
      1)
        item_changes.index = /*index*/
        ctx[9];
      if (dirty & /*$contents, $activeBranch*/
      3)
        item_changes.content = /*$contents*/
        ctx[1][
          /*parentId*/
          ctx[7]
        ]?.content;
      if (dirty & /*$sections, $activeBranch*/
      5)
        item_changes.section = /*$sections*/
        ctx[2][
          /*parentId*/
          ctx[7]
        ];
      item.$set(item_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(item.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(item.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(first);
      }
      destroy_component(item, detaching);
    }
  };
}
function create_fragment57(ctx) {
  let div1;
  let div0;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let current;
  let each_value = ensure_array_like(
    /*$activeBranch*/
    ctx[0].sortedParentNodes
  );
  const get_key = (ctx2) => (
    /*parentId*/
    ctx2[7]
  );
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context6(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block6(key, child_ctx));
  }
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(div0, "class", "breadcrumbs svelte-576atj");
      attr(div1, "class", "breadcrumbs-container svelte-576atj");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div0, null);
        }
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (dirty & /*$activeBranch, $contents, $sections*/
      7) {
        each_value = ensure_array_like(
          /*$activeBranch*/
          ctx2[0].sortedParentNodes
        );
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, div0, outro_and_destroy_block, create_each_block6, null, get_each_context6);
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
    }
  };
}
function instance56($$self, $$props, $$invalidate) {
  let $activeBranch;
  let $contents;
  let $sections;
  const view = getView();
  const activeBranch = activeBranchStore(view);
  component_subscribe($$self, activeBranch, (value) => $$invalidate(0, $activeBranch = value));
  const contents = documentContentStore(view);
  component_subscribe($$self, contents, (value) => $$invalidate(1, $contents = value));
  const sections = idSectionStore(view);
  component_subscribe($$self, sections, (value) => $$invalidate(2, $sections = value));
  return [$activeBranch, $contents, $sections, activeBranch, contents, sections];
}
var Breadcrumbs = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance56, create_fragment57, safe_not_equal, {}, add_css16);
  }
};
var breadcrumbs_default = Breadcrumbs;

// src/stores/view/derived/navigation-history-store.ts
var navigationHistoryStore = (view) => derived(view.viewStore, (state2) => state2.navigationHistory);

// src/view/components/container/toolbar/components/navigation-buttons.svelte
function add_css17(target) {
  append_styles(target, "svelte-13yyztm", ".navigation-history.svelte-13yyztm{display:flex;align-items:center;justify-content:center}");
}
function create_default_slot_13(ctx) {
  let arrowleft;
  let current;
  arrowleft = new arrow_left_default({ props: { class: "svg-icon", size: "12" } });
  return {
    c() {
      create_component(arrowleft.$$.fragment);
    },
    m(target, anchor) {
      mount_component(arrowleft, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(arrowleft.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(arrowleft.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(arrowleft, detaching);
    }
  };
}
function create_default_slot39(ctx) {
  let arrowright;
  let current;
  arrowright = new arrow_right_default({ props: { class: "svg-icon", size: "12" } });
  return {
    c() {
      create_component(arrowright.$$.fragment);
    },
    m(target, anchor) {
      mount_component(arrowright, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(arrowright.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(arrowright.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(arrowright, detaching);
    }
  };
}
function create_fragment58(ctx) {
  let div;
  let button0;
  let t;
  let button1;
  let current;
  button0 = new button_default({
    props: {
      disabled: !/*$navigationHistory*/
      ctx[0].state.canGoBack,
      label: "Navigate back",
      tooltipPosition: "bottom",
      $$slots: { default: [create_default_slot_13] },
      $$scope: { ctx }
    }
  });
  button0.$on(
    "click",
    /*click_handler*/
    ctx[3]
  );
  button1 = new button_default({
    props: {
      disabled: !/*$navigationHistory*/
      ctx[0].state.canGoForward,
      label: "Navigate forward",
      tooltipPosition: "bottom",
      $$slots: { default: [create_default_slot39] },
      $$scope: { ctx }
    }
  });
  button1.$on(
    "click",
    /*click_handler_1*/
    ctx[4]
  );
  return {
    c() {
      div = element("div");
      create_component(button0.$$.fragment);
      t = space();
      create_component(button1.$$.fragment);
      attr(div, "class", "navigation-history buttons-group svelte-13yyztm");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(button0, div, null);
      append(div, t);
      mount_component(button1, div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const button0_changes = {};
      if (dirty & /*$navigationHistory*/
      1)
        button0_changes.disabled = !/*$navigationHistory*/
        ctx2[0].state.canGoBack;
      if (dirty & /*$$scope*/
      64) {
        button0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button0.$set(button0_changes);
      const button1_changes = {};
      if (dirty & /*$navigationHistory*/
      1)
        button1_changes.disabled = !/*$navigationHistory*/
        ctx2[0].state.canGoForward;
      if (dirty & /*$$scope*/
      64) {
        button1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button1.$set(button1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(button0.$$.fragment, local);
      transition_in(button1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(button0.$$.fragment, local);
      transition_out(button1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(button0);
      destroy_component(button1);
    }
  };
}
function instance57($$self, $$props, $$invalidate) {
  let $navigationHistory;
  const view = getView();
  const viewStore = view.viewStore;
  const navigationHistory = navigationHistoryStore(view);
  component_subscribe($$self, navigationHistory, (value) => $$invalidate(0, $navigationHistory = value));
  const click_handler = () => {
    viewStore.dispatch({ type: "NAVIGATION/NAVIGATE_BACK" });
  };
  const click_handler_1 = () => {
    viewStore.dispatch({ type: "NAVIGATION/NAVIGATE_FORWARD" });
  };
  return [
    $navigationHistory,
    viewStore,
    navigationHistory,
    click_handler,
    click_handler_1
  ];
}
var Navigation_buttons = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance57, create_fragment58, safe_not_equal, {}, add_css17);
  }
};
var navigation_buttons_default = Navigation_buttons;

// src/view/components/container/toolbar/components/search-toggle.svelte
function add_css18(target) {
  append_styles(target, "svelte-17l9x5j", ".search-container.svelte-17l9x5j{display:flex;align-items:center;justify-content:center;gap:var(--size-4-2)}");
}
function create_default_slot40(ctx) {
  let search_1;
  let current;
  search_1 = new search_default({ props: { class: "svg-icon", size: "12" } });
  return {
    c() {
      create_component(search_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(search_1, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(search_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(search_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(search_1, detaching);
    }
  };
}
function create_fragment59(ctx) {
  let div;
  let button;
  let current;
  button = new button_default({
    props: {
      active: (
        /*$search*/
        ctx[0].showInput
      ),
      label: "Toggle search input",
      tooltipPosition: "bottom",
      $$slots: { default: [create_default_slot40] },
      $$scope: { ctx }
    }
  });
  button.$on(
    "click",
    /*click_handler*/
    ctx[3]
  );
  return {
    c() {
      div = element("div");
      create_component(button.$$.fragment);
      attr(div, "class", "search-container buttons-group svelte-17l9x5j");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(button, div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const button_changes = {};
      if (dirty & /*$search*/
      1)
        button_changes.active = /*$search*/
        ctx2[0].showInput;
      if (dirty & /*$$scope*/
      32) {
        button_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button.$set(button_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(button.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(button.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(button);
    }
  };
}
function instance58($$self, $$props, $$invalidate) {
  let $search;
  const view = getView();
  const viewStore = view.viewStore;
  const search2 = searchStore(view);
  component_subscribe($$self, search2, (value) => $$invalidate(0, $search = value));
  const click_handler = () => {
    viewStore.dispatch({ type: "SEARCH/TOGGLE_INPUT" });
  };
  return [$search, viewStore, search2, click_handler];
}
var Search_toggle = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance58, create_fragment59, safe_not_equal, {}, add_css18);
  }
};
var search_toggle_default = Search_toggle;

// src/view/components/container/toolbar/components/search-input.svelte
function add_css19(target) {
  append_styles(target, "svelte-1cou308", ".search-input-element.svelte-1cou308{height:34px;padding-right:64px;padding-left:12px}@media(max-width: 568px){.search-input-element.svelte-1cou308{width:100%}.search-input-wrapper.svelte-1cou308{width:100%}}.search-input-wrapper.svelte-1cou308{max-width:100%}.search-input-container.svelte-1cou308::before{display:none}");
}
function create_fragment60(ctx) {
  let div2;
  let input;
  let input_autofocus_value;
  let input_placeholder_value;
  let input_value_value;
  let t0;
  let div0;
  let div0_aria_label_value;
  let div0_style_value;
  let t1;
  let div1;
  let text_1;
  let div1_class_value;
  let current;
  let mounted;
  let dispose;
  text_1 = new text_default({ props: { class: "svg-icon" } });
  return {
    c() {
      div2 = element("div");
      input = element("input");
      t0 = space();
      div0 = element("div");
      t1 = space();
      div1 = element("div");
      create_component(text_1.$$.fragment);
      attr(input, "aria-label", "Search document");
      input.autofocus = input_autofocus_value = true;
      attr(input, "class", "search-input search-input-element svelte-1cou308");
      attr(input, "enterkeyhint", "search");
      attr(input, "placeholder", input_placeholder_value = "search");
      attr(input, "spellcheck", "false");
      attr(input, "type", "search");
      input.value = input_value_value = /*$search*/
      ctx[0].query;
      attr(div0, "aria-label", div0_aria_label_value = "Clear");
      attr(div0, "class", "search-input-clear-button");
      attr(div0, "style", div0_style_value = /*$search*/
      ctx[0].query ? "" : "display: none");
      attr(div1, "aria-label", "Fuzzy search");
      attr(div1, "class", div1_class_value = null_to_empty("input-right-decorator clickable-icon" + /*$search*/
      (ctx[0].fuzzySearch ? " is-active" : "")) + " svelte-1cou308");
      attr(div2, "class", "search-input-wrapper search-input-container svelte-1cou308");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, input);
      append(div2, t0);
      append(div2, div0);
      append(div2, t1);
      append(div2, div1);
      mount_component(text_1, div1, null);
      current = true;
      if (true)
        input.focus();
      if (!mounted) {
        dispose = [
          listen(
            input,
            "input",
            /*onInput*/
            ctx[3]
          ),
          listen(
            div0,
            "click",
            /*click_handler*/
            ctx[4]
          ),
          listen(
            div1,
            "click",
            /*click_handler_1*/
            ctx[5]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (!current || dirty & /*$search*/
      1 && input_value_value !== (input_value_value = /*$search*/
      ctx2[0].query) && input.value !== input_value_value) {
        input.value = input_value_value;
      }
      if (!current || dirty & /*$search*/
      1 && div0_style_value !== (div0_style_value = /*$search*/
      ctx2[0].query ? "" : "display: none")) {
        attr(div0, "style", div0_style_value);
      }
      if (!current || dirty & /*$search*/
      1 && div1_class_value !== (div1_class_value = null_to_empty("input-right-decorator clickable-icon" + /*$search*/
      (ctx2[0].fuzzySearch ? " is-active" : "")) + " svelte-1cou308")) {
        attr(div1, "class", div1_class_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(text_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(text_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      destroy_component(text_1);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance59($$self, $$props, $$invalidate) {
  let $search;
  const view = getView();
  const viewStore = view.viewStore;
  const search2 = searchStore(view);
  component_subscribe($$self, search2, (value) => $$invalidate(0, $search = value));
  let focusTimeout;
  const onInput = (
    // eslint-disable-next-line no-undef
    (e) => {
      viewStore.dispatch({
        type: "SEARCH/SET_QUERY",
        payload: { query: e.currentTarget.value }
      });
      clearTimeout(focusTimeout);
      focusTimeout = setTimeout(
        () => {
          if (e.currentTarget)
            e.currentTarget.focus();
        },
        500
      );
    }
  );
  const click_handler = () => {
    viewStore.dispatch({
      type: "SEARCH/SET_QUERY",
      payload: { query: "" }
    });
  };
  const click_handler_1 = () => {
    viewStore.dispatch({ type: "SEARCH/TOGGLE_FUZZY_MODE" });
    viewStore.dispatch({
      type: "SEARCH/SET_QUERY",
      payload: { query: viewStore.getValue().search.query }
    });
  };
  return [$search, viewStore, search2, onInput, click_handler, click_handler_1];
}
var Search_input = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance59, create_fragment60, safe_not_equal, {}, add_css19);
  }
};
var search_input_default = Search_input;

// src/view/components/container/toolbar/toolbar.svelte
function add_css20(target) {
  append_styles(target, "svelte-zbwcn1", ".navigation-history-container.svelte-zbwcn1{z-index:var(--z-index-breadcrumbs);left:var(--size-4-2);top:var(--size-4-2);display:flex;position:absolute;gap:var(--size-4-2);flex-wrap:wrap;max-width:90%\n    }");
}
function create_if_block10(ctx) {
  let searchinput;
  let current;
  searchinput = new search_input_default({});
  return {
    c() {
      create_component(searchinput.$$.fragment);
    },
    m(target, anchor) {
      mount_component(searchinput, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(searchinput.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(searchinput.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(searchinput, detaching);
    }
  };
}
function create_fragment61(ctx) {
  let div;
  let navigationhistory;
  let t0;
  let searchtoggle;
  let t1;
  let current;
  navigationhistory = new navigation_buttons_default({});
  searchtoggle = new search_toggle_default({});
  let if_block = (
    /*$search*/
    ctx[0].showInput && create_if_block10(ctx)
  );
  return {
    c() {
      div = element("div");
      create_component(navigationhistory.$$.fragment);
      t0 = space();
      create_component(searchtoggle.$$.fragment);
      t1 = space();
      if (if_block)
        if_block.c();
      attr(div, "class", "navigation-history-container svelte-zbwcn1");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(navigationhistory, div, null);
      append(div, t0);
      mount_component(searchtoggle, div, null);
      append(div, t1);
      if (if_block)
        if_block.m(div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*$search*/
        ctx2[0].showInput
      ) {
        if (if_block) {
          if (dirty & /*$search*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block10(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(navigationhistory.$$.fragment, local);
      transition_in(searchtoggle.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(navigationhistory.$$.fragment, local);
      transition_out(searchtoggle.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(navigationhistory);
      destroy_component(searchtoggle);
      if (if_block)
        if_block.d();
    }
  };
}
function instance60($$self, $$props, $$invalidate) {
  let $search;
  const view = getView();
  const search2 = searchStore(view);
  component_subscribe($$self, search2, (value) => $$invalidate(0, $search = value));
  return [$search, search2];
}
var Toolbar = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance60, create_fragment61, safe_not_equal, {}, add_css20);
  }
};
var toolbar_default = Toolbar;

// src/view/actions/settings/components/font-size.ts
var import_obsidian13 = require("obsidian");
var FontSize = (element2, settingsStore) => {
  const settingsState = settingsStore.getValue();
  let input;
  const setValue = () => {
    input.setValue(settingsState.view.fontSize);
  };
  new import_obsidian13.Setting(element2).setName("Font size").addSlider((cb) => {
    input = cb;
    cb.onChange((fontSize) => {
      settingsStore.dispatch({
        type: "SET_FONT_SIZE",
        payload: {
          fontSize
        }
      });
    });
    cb.setLimits(8, 36, 1).setDynamicTooltip();
    setValue();
  }).addExtraButton((cb) => {
    cb.setIcon("reset").onClick(() => {
      settingsStore.dispatch({
        type: "SET_FONT_SIZE",
        payload: {
          fontSize: 16
        }
      });
      setValue();
    }).setTooltip("Reset");
  });
};

// src/view/actions/settings/components/background-color.ts
var import_obsidian14 = require("obsidian");

// src/obsidian/helpers/get-theme.ts
var getTheme = () => {
  if (document.body.hasClass("theme-light"))
    return "light";
  else if (document.body.hasClass("theme-dark"))
    return "dark";
  throw new Error("could not detect theme");
};

// src/stores/view/subscriptions/effects/css-variables/helpers/get-default-theme.ts
var darkTheme = {
  containerBg: "#373d4c",
  activeBranchBg: "#5b637a"
};
var lightTheme = {
  containerBg: "#899cb3",
  activeBranchBg: "#cedbeb"
};
var getDefaultTheme = () => {
  const theme = getTheme();
  return theme === "light" ? lightTheme : darkTheme;
};

// src/view/actions/settings/components/background-color.ts
var BackgroundColor = (element2, settingsStore) => {
  const settingsState = settingsStore.getValue();
  let colorPicker;
  const onChange = (color) => {
    settingsStore.dispatch({
      type: "SET_CONTAINER_BG",
      payload: {
        backgroundColor: color
      }
    });
  };
  const setValue = () => {
    colorPicker.onChange(() => void 0);
    colorPicker.setValue(
      settingsState.view.theme.containerBg || getDefaultTheme().containerBg
    );
    colorPicker.onChange(onChange);
  };
  new import_obsidian14.Setting(element2).setName("Background color").addColorPicker((cb) => {
    colorPicker = cb;
    setValue();
  }).addExtraButton((cb) => {
    cb.setIcon("reset").onClick(() => {
      settingsStore.dispatch({
        type: "SET_CONTAINER_BG",
        payload: {
          backgroundColor: void 0
        }
      });
      setValue();
    }).setTooltip("Reset");
  });
};

// src/view/actions/settings/components/active-branch-color.ts
var import_obsidian15 = require("obsidian");
var ActiveBranchColor = (container, settingsStore) => {
  const settingsState = settingsStore.getValue();
  let input;
  const onChange = (color) => {
    settingsStore.dispatch({
      type: "SET_ACTIVE_BRANCH_BG",
      payload: {
        backgroundColor: color
      }
    });
  };
  const setValue = () => {
    input.onChange(() => void 0);
    input.setValue(
      settingsState.view.theme.activeBranchBg || getDefaultTheme().activeBranchBg
    );
    input.onChange(onChange);
  };
  new import_obsidian15.Setting(container).setName("Active branch color").addColorPicker((cb) => {
    input = cb;
    setValue();
  }).addExtraButton((cb) => {
    cb.setIcon("reset").onClick(() => {
      settingsStore.dispatch({
        type: "SET_ACTIVE_BRANCH_BG",
        payload: {
          backgroundColor: void 0
        }
      });
      setValue();
    }).setTooltip("Reset");
  });
};

// src/view/actions/settings/components/card-width.ts
var import_obsidian16 = require("obsidian");

// src/stores/settings/default-settings.ts
var DEFAULT_CARD_WIDTH = 550;
var DEFAULT_SETTINGS = () => ({
  documents: {},
  hotkeys: {
    customHotkeys: {}
  },
  view: {
    fontSize: 16,
    theme: {},
    cardWidth: DEFAULT_CARD_WIDTH,
    scrolling: {
      horizontalOffset: 0,
      verticalOffset: 0,
      horizontalScrollingMode: "keep-active-card-at-center"
    },
    limitPreviewHeight: true,
    zoomLevel: 1
  },
  general: {
    defaultDocumentFormat: "sections"
  },
  backup: {}
});

// src/view/actions/settings/components/card-width.ts
var CardWidth = (element2, settingsStore) => {
  const settingsState = settingsStore.getValue();
  let input;
  const setValue = () => {
    input.setValue(settingsState.view.cardWidth);
  };
  new import_obsidian16.Setting(element2).setName("Card width").addSlider((cb) => {
    input = cb;
    cb.setLimits(200, 1e3, 10);
    cb.onChange((width) => {
      settingsStore.dispatch({
        type: "SET_CARD_WIDTH",
        payload: {
          width
        }
      });
    }).setDynamicTooltip();
    setValue();
  }).addExtraButton((cb) => {
    cb.setIcon("reset").onClick(() => {
      settingsStore.dispatch({
        type: "SET_CARD_WIDTH",
        payload: {
          width: DEFAULT_CARD_WIDTH
        }
      });
      setValue();
    }).setTooltip("Reset");
  });
};

// src/view/actions/settings/components/scrolling-behavior.ts
var import_obsidian17 = require("obsidian");
var ScrollingBehavior = (element2, settingsStore) => {
  const settingsState = settingsStore.getValue();
  const setting = new import_obsidian17.Setting(element2).setName("Scrolling behavior");
  setting.addDropdown((cb) => {
    const value = settingsState.view.scrolling.horizontalScrollingMode;
    cb.addOptions({
      "reveal-active-card": "Reveal active card",
      "reveal-active-card-and-direct-child": "Reveal active card and its children",
      "keep-active-card-at-center": "Keep active card in the center",
      "fixed-position": "Keep active card in a fixed position"
    }).setValue(value).onChange((mode) => {
      settingsStore.dispatch({
        type: "SET_HORIZONTAL_SCROLLING_MODE",
        payload: {
          mode
        }
      });
    });
  });
};

// src/view/actions/settings/components/limit-card-height.ts
var import_obsidian18 = require("obsidian");
var LimitCardHeight = (element2, settingsStore) => {
  const settingsState = settingsStore.getValue();
  new import_obsidian18.Setting(element2).setName("Limit card height").addToggle((cb) => {
    cb.setValue(settingsState.view.limitPreviewHeight).onChange((limit) => {
      settingsStore.dispatch({
        type: "SET_LIMIT_PREVIEW_HEIGHT",
        payload: {
          limit
        }
      });
    });
  });
};

// src/view/actions/settings/components/default-document-format.ts
var import_obsidian19 = require("obsidian");
var DefaultDocumentFormat = (element2, settingsStore) => {
  const settingsState = settingsStore.getValue();
  const setting = new import_obsidian19.Setting(element2).setName("Default format");
  setting.addDropdown((cb) => {
    const value = settingsState.general.defaultDocumentFormat;
    cb.addOptions({
      sections: "Sections",
      outline: "Outline (experimental)"
    }).setValue(value).onChange((value2) => {
      settingsStore.dispatch({
        type: "GENERAL/SET_DEFAULT_DOCUMENT_FORMAT",
        payload: {
          format: value2
        }
      });
    });
  });
};

// src/view/actions/settings/render-settings.ts
var renderSettings = (element2) => {
  const view = getView();
  const settingsStore = view.plugin.settings;
  const render = () => {
    BackgroundColor(element2, settingsStore);
    ActiveBranchColor(element2, settingsStore);
    FontSize(element2, settingsStore);
    CardWidth(element2, settingsStore);
    LimitCardHeight(element2, settingsStore);
    ScrollingBehavior(element2, settingsStore);
    DefaultDocumentFormat(element2, settingsStore);
  };
  render();
  return {
    update: () => {
      render();
    }
  };
};

// src/view/components/container/controls-bar/modals/settings/settings.svelte
function add_css21(target) {
  append_styles(target, "svelte-1o0j9qb", ".setting-items.svelte-1o0j9qb{display:flex;flex-direction:column;padding:20px;& .setting-item {\n            padding: 10px 0;\n        }}.is-mobile{& .setting-items {\n            padding: 5px 10px;\n        };& :global(.setting-item) {\n            display: flex;\n            flex-direction: column;\n            gap: 4px;\n        };& :global(.setting-item-control) {\n            width: 100%;\n            justify-content: center;\n        }}");
}
function create_fragment62(ctx) {
  let div1;
  let div0;
  let renderSettings_action;
  let mounted;
  let dispose;
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      attr(div0, "class", "setting-items svelte-1o0j9qb");
      attr(div1, "class", "lineage-modal");
      attr(div1, "id", "lineage-view-settings");
      attr(div1, "tabindex", "0");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      if (!mounted) {
        dispose = action_destroyer(renderSettings_action = renderSettings.call(null, div0));
        mounted = true;
      }
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      mounted = false;
      dispose();
    }
  };
}
var Settings2 = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, null, create_fragment62, safe_not_equal, {}, add_css21);
  }
};
var settings_default2 = Settings2;

// src/helpers/relative-time.ts
var rtf1 = new Intl.RelativeTimeFormat("en", { style: "long" });
var relativeTime = (updated) => {
  const difference = Date.now() - updated;
  const days = Math.floor(difference / (1e3 * 60 * 60 * 24));
  const hours = Math.floor(difference / (1e3 * 60 * 60));
  const minutes = Math.floor(difference / (1e3 * 60));
  let relativeTime2;
  if (days > 0) {
    relativeTime2 = rtf1.format(-days, "day");
  } else if (hours > 0) {
    relativeTime2 = rtf1.format(-hours, "hour");
  } else if (minutes > 0) {
    relativeTime2 = rtf1.format(-minutes, "minute");
  } else {
    relativeTime2 = "Just now";
  }
  return relativeTime2;
};

// src/view/components/container/controls-bar/modals/snapshots-list/components/helpers/action-info.ts
var actionInfo = {
  "DOCUMENT/SET_NODE_CONTENT": (snapshot) => ({
    label: "Updated card " + snapshot.context.affectedSection,
    icon: file_pen_default
  }),
  "DOCUMENT/INSERT_NODE": (snapshot) => ({
    label: "Created card " + snapshot.context.affectedSection,
    icon: file_plus_default
  }),
  "DOCUMENT/DROP_NODE": (snapshot) => ({
    label: "Dropped card " + snapshot.context.affectedSection,
    icon: file_output_default
  }),
  "DOCUMENT/LOAD_FILE": () => ({
    label: "Loaded document",
    icon: file_up_default
  }),
  "DOCUMENT/DELETE_NODE": (snapshot) => ({
    label: "Deleted card " + snapshot.context.affectedSection,
    icon: file_minus_default
  }),
  "DOCUMENT/MOVE_NODE": (snapshot) => ({
    label: "Moved card " + snapshot.context.affectedSection,
    icon: file_output_default
  }),
  "DOCUMENT/MERGE_NODE": (snapshot) => ({
    label: "Merged card " + snapshot.context.affectedSection,
    icon: merge_default
  }),
  "DOCUMENT/FORMAT_HEADINGS": () => ({
    label: "Formatted headings",
    icon: heading_1_default
  }),
  "DOCUMENT/CUT_NODE": (snapshot) => ({
    label: "Cut card " + snapshot.context.affectedSection,
    icon: scissors_default
  }),
  "DOCUMENT/PASTE_NODE": (snapshot) => ({
    label: "Pasted card " + snapshot.context.affectedSection,
    icon: clipboard_paste_default
  }),
  "DOCUMENT/EXTRACT_BRANCH": (snapshot) => ({
    label: "Extracted card " + snapshot.context.affectedSection,
    icon: file_symlink_default
  }),
  "DOCUMENT/SPLIT_NODE": (snapshot) => ({
    label: "Split card " + snapshot.context.affectedSection,
    icon: split_default
  })
};

// src/view/components/container/controls-bar/modals/snapshots-list/components/snapshot-button.svelte
var import_obsidian20 = require("obsidian");
function add_css22(target) {
  append_styles(target, "svelte-1659s7i", ":root{--icon-wrapper-width:32px}.snapshot.svelte-1659s7i{padding:var(--size-4-2);cursor:pointer;display:flex;align-items:center;border-radius:4px;gap:4px;height:66px;width:330px;background-color:var(--background-secondary)}.selected.svelte-1659s7i{background-color:var(--nav-item-background-selected)}.icon-wrapper.svelte-1659s7i{width:32px;display:flex;align-items:center;justify-content:center}.snapshot-content.svelte-1659s7i{display:flex;flex-direction:column;gap:5px;flex:1}.snapshot-body.svelte-1659s7i{display:flex;justify-content:space-between;gap:5px;width:100%}.snapshot-label.svelte-1659s7i{font-size:14px;color:var(--color-base-70);display:block;flex:1;max-width:210px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}.snapshot-card-content.svelte-1659s7i{font-size:14px;color:var(--color-base-60);display:block;white-space:nowrap;overflow:hidden;max-width:190px;text-overflow:ellipsis;font-style:italic;opacity:0.9}.snapshot-context.svelte-1659s7i{display:flex;flex-direction:column;align-items:end;height:100%;justify-content:space-between}.snapshot-section-number.svelte-1659s7i{font-size:11px;color:var(--color-base-40);min-width:16px;text-align:left;margin-left:auto}.snapshot-time.svelte-1659s7i{font-size:11px;color:var(--color-base-60)}");
}
function create_fragment63(ctx) {
  let div6;
  let div0;
  let switch_instance;
  let t0;
  let div4;
  let div2;
  let div1;
  let t2;
  let div3;
  let t3_value = (
    /*snapshot*/
    ctx[0].context.contentOfAffectedSection + ""
  );
  let t3;
  let t4;
  let div5;
  let span0;
  let t6;
  let span1;
  let t8;
  let span2;
  let t9_value = relativeTime(
    /*snapshot*/
    ctx[0].created
  ) + "";
  let t9;
  let span2_data_created_value;
  let div6_aria_label_value;
  let current;
  let mounted;
  let dispose;
  var switch_value = (
    /*info*/
    ctx[4].icon
  );
  function switch_props(ctx2, dirty) {
    return { props: { class: "svg-icon label" } };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
  }
  return {
    c() {
      div6 = element("div");
      div0 = element("div");
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      t0 = space();
      div4 = element("div");
      div2 = element("div");
      div1 = element("div");
      div1.textContent = `${/*info*/
      ctx[4].label}`;
      t2 = space();
      div3 = element("div");
      t3 = text(t3_value);
      t4 = space();
      div5 = element("div");
      span0 = element("span");
      span0.textContent = `${/*sections*/
      ctx[5]}`;
      t6 = space();
      span1 = element("span");
      span1.textContent = `${/*chars*/
      ctx[6]}`;
      t8 = space();
      span2 = element("span");
      t9 = text(t9_value);
      attr(div0, "class", "icon-wrapper svelte-1659s7i");
      attr(div1, "class", "snapshot-label svelte-1659s7i");
      attr(div2, "class", "snapshot-body svelte-1659s7i");
      attr(div3, "class", "snapshot-card-content svelte-1659s7i");
      attr(div4, "class", "snapshot-content svelte-1659s7i");
      attr(span0, "class", "snapshot-section-number svelte-1659s7i");
      attr(span1, "class", "snapshot-section-number svelte-1659s7i");
      attr(span2, "class", "snapshot-time svelte-1659s7i");
      attr(span2, "data-created", span2_data_created_value = /*snapshot*/
      ctx[0].created);
      attr(div5, "class", "snapshot-context svelte-1659s7i");
      attr(div6, "aria-label", div6_aria_label_value = /*snapshot*/
      ctx[0].context.contentOfAffectedSection);
      attr(div6, "class", "snapshot svelte-1659s7i");
      toggle_class(
        div6,
        "selected",
        /*active*/
        ctx[1]
      );
    },
    m(target, anchor) {
      insert(target, div6, anchor);
      append(div6, div0);
      if (switch_instance)
        mount_component(switch_instance, div0, null);
      append(div6, t0);
      append(div6, div4);
      append(div4, div2);
      append(div2, div1);
      append(div4, t2);
      append(div4, div3);
      append(div3, t3);
      append(div6, t4);
      append(div6, div5);
      append(div5, span0);
      append(div5, t6);
      append(div5, span1);
      append(div5, t8);
      append(div5, span2);
      append(span2, t9);
      current = true;
      if (!mounted) {
        dispose = listen(
          div6,
          "click",
          /*click_handler*/
          ctx[7]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (switch_value !== (switch_value = /*info*/
      ctx2[4].icon)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props(ctx2, dirty));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, div0, null);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
      }
      if ((!current || dirty & /*snapshot*/
      1) && t3_value !== (t3_value = /*snapshot*/
      ctx2[0].context.contentOfAffectedSection + ""))
        set_data(t3, t3_value);
      if ((!current || dirty & /*snapshot*/
      1) && t9_value !== (t9_value = relativeTime(
        /*snapshot*/
        ctx2[0].created
      ) + ""))
        set_data(t9, t9_value);
      if (!current || dirty & /*snapshot*/
      1 && span2_data_created_value !== (span2_data_created_value = /*snapshot*/
      ctx2[0].created)) {
        attr(span2, "data-created", span2_data_created_value);
      }
      if (!current || dirty & /*snapshot*/
      1 && div6_aria_label_value !== (div6_aria_label_value = /*snapshot*/
      ctx2[0].context.contentOfAffectedSection)) {
        attr(div6, "aria-label", div6_aria_label_value);
      }
      if (!current || dirty & /*active*/
      2) {
        toggle_class(
          div6,
          "selected",
          /*active*/
          ctx2[1]
        );
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div6);
      }
      if (switch_instance)
        destroy_component(switch_instance);
      mounted = false;
      dispose();
    }
  };
}
function instance61($$self, $$props, $$invalidate) {
  let { snapshot } = $$props;
  let { active } = $$props;
  const view = getView();
  const documentStore = view.documentStore;
  const viewStore = view.viewStore;
  const infoFactory = actionInfo[snapshot.context.action.type];
  invariant(infoFactory);
  const info = infoFactory(snapshot);
  const numberOfCharacters = snapshot.context.numberOfCharacters;
  const numberOfSections = snapshot.context.numberOfSections;
  const sections = `${numberOfSections} card${numberOfSections === 1 ? "" : "s"}`;
  const chars = `${numberOfCharacters} char${numberOfCharacters === 1 ? "" : "s"}`;
  const click_handler = () => {
    if (viewStore.getValue().document.editing.activeNodeId)
      new import_obsidian20.Notice(lang.error_apply_snapshot_while_editing);
    else
      documentStore.dispatch({
        type: "HISTORY/SELECT_SNAPSHOT",
        payload: { snapshotId: snapshot.id }
      });
  };
  $$self.$$set = ($$props2) => {
    if ("snapshot" in $$props2)
      $$invalidate(0, snapshot = $$props2.snapshot);
    if ("active" in $$props2)
      $$invalidate(1, active = $$props2.active);
  };
  return [
    snapshot,
    active,
    documentStore,
    viewStore,
    info,
    sections,
    chars,
    click_handler
  ];
}
var Snapshot_button = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance61, create_fragment63, safe_not_equal, { snapshot: 0, active: 1 }, add_css22);
  }
};
var snapshot_button_default = Snapshot_button;

// src/view/actions/update-relative-time.ts
var updateRelativeTime = (element2) => {
  const interval = setInterval(() => {
    const children2 = Array.from(
      element2.querySelectorAll("[data-created]")
    );
    for (const child of children2) {
      const created = child.dataset["created"];
      if (created && !isNaN(+created))
        child.textContent = relativeTime(+created);
    }
  }, 30 * 1e3);
  return {
    destroy: () => {
      clearInterval(interval);
    }
  };
};

// src/view/components/container/controls-bar/modals/snapshots-list/file-histoy.svelte
function add_css23(target) {
  append_styles(target, "svelte-1t5m48g", ".snapshots-list.svelte-1t5m48g{display:flex;flex-direction:column;gap:var(--size-4-2);height:fit-content;max-height:400px;overflow-y:auto;padding-left:var(--size-4-2);padding-right:var(--size-4-2)}");
}
function get_each_context7(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[3] = list[i];
  child_ctx[5] = i;
  return child_ctx;
}
function create_each_block7(key_1, ctx) {
  let first;
  let snapshotbutton;
  let current;
  snapshotbutton = new snapshot_button_default({
    props: {
      snapshot: (
        /*snapshot*/
        ctx[3]
      ),
      active: (
        /*$history*/
        ctx[0].items.length - /*index*/
        ctx[5] - 1 === /*$history*/
        ctx[0].state.activeIndex
      )
    }
  });
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      create_component(snapshotbutton.$$.fragment);
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      mount_component(snapshotbutton, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const snapshotbutton_changes = {};
      if (dirty & /*$history*/
      1)
        snapshotbutton_changes.snapshot = /*snapshot*/
        ctx[3];
      if (dirty & /*$history*/
      1)
        snapshotbutton_changes.active = /*$history*/
        ctx[0].items.length - /*index*/
        ctx[5] - 1 === /*$history*/
        ctx[0].state.activeIndex;
      snapshotbutton.$set(snapshotbutton_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(snapshotbutton.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(snapshotbutton.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(first);
      }
      destroy_component(snapshotbutton, detaching);
    }
  };
}
function create_fragment64(ctx) {
  let div1;
  let div0;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let updateRelativeTime_action;
  let current;
  let mounted;
  let dispose;
  let each_value = ensure_array_like([.../*$history*/
  ctx[0].items].sort(func));
  const get_key = (ctx2) => (
    /*snapshot*/
    ctx2[3].id
  );
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context7(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block7(key, child_ctx));
  }
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(div0, "class", "snapshots-list svelte-1t5m48g");
      attr(div1, "class", "lineage-modal");
      set_style(div1, "padding-left", "0");
      set_style(div1, "padding-right", "0");
      attr(div1, "tabindex", "0");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div0, null);
        }
      }
      current = true;
      if (!mounted) {
        dispose = action_destroyer(updateRelativeTime_action = updateRelativeTime.call(null, div0));
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*$history*/
      1) {
        each_value = ensure_array_like([.../*$history*/
        ctx2[0].items].sort(func));
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, div0, outro_and_destroy_block, create_each_block7, null, get_each_context7);
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
      mounted = false;
      dispose();
    }
  };
}
var func = (a, b) => b.created - a.created;
function instance62($$self, $$props, $$invalidate) {
  let $history;
  const view = getView();
  const history = historyStore(view);
  component_subscribe($$self, history, (value) => $$invalidate(0, $history = value));
  return [$history, history];
}
var File_histoy = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance62, create_fragment64, safe_not_equal, {}, add_css23);
  }
};
var file_histoy_default = File_histoy;

// src/lib/store/derived-on-action.ts
var derivedOnAction = (source, mapper, actions) => {
  const set = new Set(actions);
  const subscribers = /* @__PURE__ */ new Set();
  let derivedValue;
  let unsub = null;
  return {
    subscribe: (run2) => {
      subscribers.add(run2);
      if (!unsub) {
        unsub = source.subscribe((value, action, initialRun) => {
          if (action && set.has(action?.type) || initialRun) {
            derivedValue = mapper(value, action);
            for (const sub of subscribers) {
              sub(derivedValue, action, initialRun);
            }
          }
        });
      }
      run2(derivedValue, void 0, true);
      return () => {
        subscribers.delete(run2);
        if (unsub && subscribers.size === 0) {
          unsub();
          unsub = null;
        }
      };
    }
  };
};

// src/lib/store/store.ts
var Store = class {
  constructor(initialValue2, reducer, onError) {
    this.subscribers = /* @__PURE__ */ new Set();
    this.isProcessing = false;
    this.actionQueue = [];
    this.reducer = () => this.value;
    // eslint-disable-next-line no-console
    this.onError = (error) => console.error(error);
    this.value = initialValue2;
    if (reducer)
      this.reducer = reducer;
    if (onError)
      this.onError = onError;
  }
  getValue() {
    return this.value;
  }
  dispatch(action) {
    this.actionQueue.push(action);
    if (!this.isProcessing) {
      this.processActionQueue();
    }
  }
  set(value) {
    this.value = value;
    this.notifySubscribers();
  }
  subscribe(run2) {
    this.subscribers.add(run2);
    try {
      run2(this.value, void 0, true);
    } catch (error) {
      this.onError(error, "subscriber");
    }
    return () => {
      this.subscribers.delete(run2);
    };
  }
  update(updater) {
    this.value = updater(this.value);
    this.notifySubscribers();
  }
  processActionQueue() {
    this.isProcessing = true;
    while (this.actionQueue.length > 0) {
      const action = this.actionQueue.shift();
      try {
        this.value = this.reducer(this.value, action);
        this.notifySubscribers(action);
      } catch (error) {
        this.onError(error, "reducer", action);
      }
    }
    this.isProcessing = false;
  }
  notifySubscribers(action) {
    for (const subscriber of this.subscribers) {
      try {
        subscriber(this.value, action);
      } catch (error) {
        this.onError(error, "subscriber", action);
      }
    }
  }
};

// src/view/actions/keyboard-shortcuts/helpers/commands/commands/navigate-commands.ts
var navigateCommands = () => {
  const commands = [];
  commands.push(
    {
      name: "go_right",
      check: isActiveAndNotEditing,
      callback: (view, event) => {
        event.preventDefault();
        view.viewStore.dispatch({
          type: "DOCUMENT/NAVIGATE_USING_KEYBOARD",
          payload: {
            direction: "right",
            columns: view.documentStore.getValue().document.columns
          }
        });
      },
      hotkeys: [
        { key: "L", modifiers: [] },
        { key: "ArrowRight", modifiers: [] }
      ]
    },
    {
      name: "go_down",
      check: isActiveAndNotEditing,
      callback: (view, event) => {
        event.preventDefault();
        view.viewStore.dispatch({
          type: "DOCUMENT/NAVIGATE_USING_KEYBOARD",
          payload: {
            direction: "down",
            columns: view.documentStore.getValue().document.columns
          }
        });
      },
      hotkeys: [
        { key: "J", modifiers: [] },
        { key: "ArrowDown", modifiers: [] }
      ]
    },
    {
      name: "go_left",
      check: isActiveAndNotEditing,
      callback: (view, event) => {
        event.preventDefault();
        view.viewStore.dispatch({
          type: "DOCUMENT/NAVIGATE_USING_KEYBOARD",
          payload: {
            direction: "left",
            columns: view.documentStore.getValue().document.columns
          }
        });
      },
      hotkeys: [
        { key: "H", modifiers: [] },
        { key: "ArrowLeft", modifiers: [] }
      ]
    },
    {
      name: "go_up",
      check: isActiveAndNotEditing,
      callback: (view, event) => {
        event.preventDefault();
        view.viewStore.dispatch({
          type: "DOCUMENT/NAVIGATE_USING_KEYBOARD",
          payload: {
            direction: "up",
            columns: view.documentStore.getValue().document.columns
          }
        });
      },
      hotkeys: [
        { key: "K", modifiers: [] },
        { key: "ArrowUp", modifiers: [] }
      ]
    },
    {
      name: "go_to_beginning_of_group",
      check: isActiveAndNotEditing,
      callback: (view, e) => {
        e.preventDefault();
        e.stopPropagation();
        view.viewStore.dispatch({
          type: "DOCUMENT/JUMP_TO_NODE",
          payload: {
            target: "start-of-group",
            columns: view.documentStore.getValue().document.columns
          }
        });
      },
      hotkeys: [{ key: "PageUp", modifiers: [] }]
    },
    {
      name: "go_to_end_of_group",
      check: isActiveAndNotEditing,
      callback: (view, e) => {
        e.preventDefault();
        e.stopPropagation();
        view.viewStore.dispatch({
          type: "DOCUMENT/JUMP_TO_NODE",
          payload: {
            target: "end-of-group",
            columns: view.documentStore.getValue().document.columns
          }
        });
      },
      hotkeys: [{ key: "PageDown", modifiers: [] }]
    },
    {
      name: "go_to_beginning_of_column",
      check: isActiveAndNotEditing,
      callback: (view, e) => {
        e.preventDefault();
        e.stopPropagation();
        view.viewStore.dispatch({
          type: "DOCUMENT/JUMP_TO_NODE",
          payload: {
            target: "start-of-column",
            columns: view.documentStore.getValue().document.columns
          }
        });
      },
      hotkeys: [{ key: "Home", modifiers: [] }]
    },
    {
      name: "go_to_end_of_column",
      check: isActiveAndNotEditing,
      callback: (view, e) => {
        e.preventDefault();
        e.stopPropagation();
        view.viewStore.dispatch({
          type: "DOCUMENT/JUMP_TO_NODE",
          payload: {
            target: "end-of-column",
            columns: view.documentStore.getValue().document.columns
          }
        });
      },
      hotkeys: [{ key: "End", modifiers: [] }]
    },
    {
      name: "navigate_back",
      check: isActive,
      callback: (view, event) => {
        event.preventDefault();
        view.viewStore.dispatch({
          type: "NAVIGATION/NAVIGATE_BACK"
        });
      },
      hotkeys: [{ key: "J", modifiers: ["Alt"] }]
    },
    {
      name: "navigate_forward",
      check: isActive,
      callback: (view, event) => {
        event.preventDefault();
        view.viewStore.dispatch({
          type: "NAVIGATION/NAVIGATE_FORWARD"
        });
      },
      hotkeys: [{ key: "K", modifiers: ["Alt"] }]
    },
    {
      name: "navigate_to_next_node",
      check: isActiveAndNotEditing,
      callback: (view, event) => {
        event.preventDefault();
        view.viewStore.dispatch({
          type: "NAVIGATION/SELECT_NEXT_NODE",
          payload: {
            direction: "forward",
            sections: view.documentStore.getValue().sections
          }
        });
      },
      hotkeys: [{ key: "N", modifiers: [] }]
    },
    {
      name: "navigate_to_previous_node",
      check: isActiveAndNotEditing,
      callback: (view, event) => {
        event.preventDefault();
        view.viewStore.dispatch({
          type: "NAVIGATION/SELECT_NEXT_NODE",
          payload: {
            direction: "back",
            sections: view.documentStore.getValue().sections
          }
        });
      },
      hotkeys: [{ key: "B", modifiers: [] }]
    }
  );
  return commands;
};

// src/view/actions/keyboard-shortcuts/helpers/commands/commands/edit-commands.ts
var editCommands = () => {
  return [
    {
      name: "enable_edit_mode",
      check: isActiveAndNotEditing,
      callback: (view, event) => {
        event.preventDefault();
        view.viewStore.dispatch({
          type: "DOCUMENT/ENABLE_EDIT_MODE",
          payload: {
            nodeId: view.viewStore.getValue().document.activeNode
          }
        });
      },
      hotkeys: [{ key: "Enter", modifiers: [] }]
    },
    {
      name: "enable_edit_mode_and_place_cursor_at_start",
      check: isActiveAndNotEditing,
      callback: (view, event) => {
        event.preventDefault();
        view.inlineEditor.overrideCursor({ line: 0, ch: 0 });
        view.viewStore.dispatch({
          type: "DOCUMENT/ENABLE_EDIT_MODE",
          payload: {
            nodeId: view.viewStore.getValue().document.activeNode
          }
        });
      },
      hotkeys: [{ key: "Enter", modifiers: ["Shift"] }]
    },
    {
      name: "save_changes_and_exit_card",
      check: isActiveAndEditing,
      callback: (view) => {
        saveNodeContent(view);
      },
      hotkeys: [{ key: "Enter", modifiers: ["Shift", "Mod"] }]
    },
    {
      name: "disable_edit_mode",
      check: isActiveAndEditing,
      callback: (view) => {
        cancelChanges(view);
      },
      hotkeys: [{ key: "Escape", modifiers: [] }]
    }
  ];
};

// src/view/actions/keyboard-shortcuts/helpers/commands/commands/helpers/add-node-and-split-at-cursor.ts
var flattenEditorPosition = (value, cursor) => {
  const lines = value.split("\n");
  let total = 0;
  for (let i = 0; i < lines.length; i++) {
    if (cursor.line === i) {
      return total + cursor.ch;
    } else {
      total += lines[i].length + 1;
    }
  }
  throw new Error(`invalid cursor line: ${cursor.line} ch: ${cursor.ch}`);
};
var addNodeAndSplitAtCursor = (view, direction) => {
  let text2 = "";
  let firstHalf = "", secondHalf = "";
  const value = view.inlineEditor.getContent();
  const cursor = flattenEditorPosition(value, view.inlineEditor.getCursor());
  if (cursor < value.length) {
    firstHalf = value.substring(0, cursor);
    secondHalf = value.substring(cursor);
    if (direction === "up") {
      view.inlineEditor.setContent(secondHalf.trimStart());
      text2 = firstHalf.trimEnd();
    } else {
      view.inlineEditor.setContent(firstHalf.trimEnd());
      text2 = secondHalf.trimStart();
    }
  }
  saveNodeAndInsertNode(view, direction, text2);
};

// src/view/actions/keyboard-shortcuts/helpers/commands/commands/create-commands.ts
var createCommands = () => {
  return [
    {
      name: "add_above",
      check: isActiveAndNotEditing,
      callback: (view) => {
        saveNodeAndInsertNode(view, "up");
      },
      hotkeys: [
        {
          key: "ArrowUp",
          modifiers: ["Mod"]
        }
      ]
    },
    {
      name: "add_below",
      check: isActiveAndNotEditing,
      callback: (view) => {
        saveNodeAndInsertNode(view, "down");
      },
      hotkeys: [
        {
          key: "ArrowDown",
          modifiers: ["Mod"]
        }
      ]
    },
    {
      name: "add_child",
      check: isActiveAndNotEditing,
      callback: (view) => {
        saveNodeAndInsertNode(view, "right");
      },
      hotkeys: [
        {
          key: "ArrowRight",
          modifiers: ["Mod"]
        }
      ]
    },
    {
      name: "add_above_and_split",
      check: isActive,
      callback: (view) => {
        if (isEditing(view))
          addNodeAndSplitAtCursor(view, "up");
        else
          saveNodeAndInsertNode(view, "up");
      },
      hotkeys: [{ key: "K", modifiers: ["Mod"] }]
    },
    {
      name: "add_below_and_split",
      check: isActive,
      callback: (view) => {
        if (isEditing(view))
          addNodeAndSplitAtCursor(view, "down");
        else
          saveNodeAndInsertNode(view, "down");
      },
      hotkeys: [{ key: "J", modifiers: ["Mod"] }]
    },
    {
      name: "add_child_and_split",
      check: isActive,
      callback: (view) => {
        if (isEditing(view))
          addNodeAndSplitAtCursor(view, "right");
        else
          saveNodeAndInsertNode(view, "right");
      },
      hotkeys: [{ key: "L", modifiers: ["Mod"] }]
    }
  ];
};

// src/view/actions/keyboard-shortcuts/helpers/commands/commands/helpers/move-node.ts
var restoreEditingState = (view, state2) => {
  setTimeout(() => {
    view.inlineEditor.overrideCursor(state2.cursor);
    view.viewStore.dispatch({
      type: "DOCUMENT/ENABLE_EDIT_MODE",
      payload: {
        nodeId: state2.editedNode
      }
    });
  });
};
var moveNode = async (view, direction) => {
  let state2 = null;
  if (view.inlineEditor.activeNode) {
    state2 = {
      cursor: view.inlineEditor.getCursor(),
      editedNode: view.inlineEditor.activeNode
    };
  }
  saveNodeContent(view);
  const document2 = view.viewStore.getValue().document;
  view.documentStore.dispatch({
    type: "DOCUMENT/MOVE_NODE",
    payload: {
      direction,
      activeNodeId: document2.activeNode,
      selectedNodes: document2.selectedNodes
    }
  });
  if (state2)
    restoreEditingState(view, state2);
};

// src/view/actions/keyboard-shortcuts/helpers/commands/commands/move-commands.ts
var moveCommands = () => {
  return [
    {
      name: "move_node_up",
      check: isActive,
      callback: (view) => {
        moveNode(view, "up");
      },
      hotkeys: [
        { key: "K", modifiers: ["Alt", "Shift"] },
        { key: "ArrowUp", modifiers: ["Alt", "Shift"] }
      ]
    },
    {
      name: "move_node_down",
      check: isActive,
      callback: (view) => {
        moveNode(view, "down");
      },
      hotkeys: [
        { key: "J", modifiers: ["Alt", "Shift"] },
        { key: "ArrowDown", modifiers: ["Alt", "Shift"] }
      ]
    },
    {
      name: "move_node_right",
      check: isActive,
      callback: (view) => {
        moveNode(view, "right");
      },
      hotkeys: [
        { key: "L", modifiers: ["Alt", "Shift"] },
        { key: "ArrowRight", modifiers: ["Alt", "Shift"] }
      ]
    },
    {
      name: "move_node_left",
      check: isActive,
      callback: (view) => {
        moveNode(view, "left");
      },
      hotkeys: [
        { key: "H", modifiers: ["Alt", "Shift"] },
        { key: "ArrowLeft", modifiers: ["Alt", "Shift"] }
      ]
    }
  ];
};

// src/view/actions/keyboard-shortcuts/helpers/commands/commands/merge-commands.ts
var mergeCommands = () => {
  return [
    {
      name: "merge_with_node_above",
      check: isActiveAndNotEditing,
      callback: (view) => {
        mergeNode(view, "up");
      },
      hotkeys: [
        { key: "K", modifiers: ["Mod", "Shift"] },
        { key: "ArrowUp", modifiers: ["Mod", "Shift"] }
      ]
    },
    {
      name: "merge_with_node_below",
      check: isActiveAndNotEditing,
      callback: (view) => {
        mergeNode(view, "down");
      },
      hotkeys: [
        { key: "J", modifiers: ["Mod", "Shift"] },
        { key: "ArrowDown", modifiers: ["Mod", "Shift"] }
      ]
    }
  ];
};

// src/view/actions/keyboard-shortcuts/helpers/commands/commands/history-commands.ts
var historyCommands = () => {
  return [
    {
      name: "undo_change",
      check: isActiveAndNotEditingAndHasFile,
      callback: (view) => {
        const path = view.documentStore.getValue().file.path;
        if (path)
          view.documentStore.dispatch({
            type: "HISTORY/APPLY_PREVIOUS_SNAPSHOT"
          });
      },
      hotkeys: [{ key: "Z", modifiers: ["Mod", "Shift"] }]
    },
    {
      name: "redo_change",
      check: isActiveAndNotEditingAndHasFile,
      callback: (view) => {
        const path = view.documentStore.getValue().file.path;
        if (path)
          view.documentStore.dispatch({
            type: "HISTORY/APPLY_NEXT_SNAPSHOT"
          });
      },
      hotkeys: [{ key: "Y", modifiers: ["Mod", "Shift"] }]
    }
  ];
};

// src/view/actions/keyboard-shortcuts/helpers/commands/commands/clipboard-commands.ts
var clipboardCommands = () => {
  return [
    {
      name: "copy_node",
      check: isActiveAndNotEditing,
      callback: async (view, event) => {
        event.preventDefault();
        copyNode(view);
      },
      hotkeys: [{ key: "C", modifiers: ["Mod"] }]
    },
    {
      name: "cut_node",
      check: isActiveAndNotEditing,
      callback: async (view, event) => {
        event.preventDefault();
        cutNode(view);
      },
      hotkeys: [{ key: "X", modifiers: ["Mod"] }]
    },
    {
      name: "paste_node",
      check: isActiveAndNotEditing,
      callback: async (view, event) => {
        event.preventDefault();
        pasteNode(view);
      },
      hotkeys: [{ key: "V", modifiers: ["Mod"] }]
    }
  ];
};

// src/stores/settings/migrations/map-ctrl-to-mod.ts
var mapCtrlToMod = (customHotkeys) => {
  if (!isMacLike) {
    for (const value of Object.values(customHotkeys)) {
      const hotkey = value.primary || value.secondary;
      if (hotkey) {
        hotkey.modifiers = hotkey.modifiers.map(
          (m) => m === "Ctrl" ? "Mod" : m
        );
      }
    }
  }
  return customHotkeys;
};

// src/view/actions/keyboard-shortcuts/helpers/commands/commands/selection-commands.ts
var selectionCommands = () => {
  const commands = [];
  commands.push(
    {
      name: "extend_select_up",
      check: isActiveAndNotEditing,
      callback: (view, event) => {
        event.preventDefault();
        view.viewStore.dispatch({
          type: "DOCUMENT/NAVIGATE_USING_KEYBOARD",
          payload: {
            direction: "up",
            columns: view.documentStore.getValue().document.columns
          },
          context: {
            shiftKey: true
          }
        });
      },
      hotkeys: [
        { key: "K", modifiers: ["Shift"] },
        { key: "ArrowUp", modifiers: ["Shift"] }
      ]
    },
    {
      name: "extend_select_down",
      check: isActiveAndNotEditing,
      callback: (view, event) => {
        event.preventDefault();
        view.viewStore.dispatch({
          type: "DOCUMENT/NAVIGATE_USING_KEYBOARD",
          payload: {
            direction: "down",
            columns: view.documentStore.getValue().document.columns
          },
          context: {
            shiftKey: true
          }
        });
      },
      hotkeys: [
        { key: "J", modifiers: ["Shift"] },
        { key: "ArrowDown", modifiers: ["Shift"] }
      ]
    },
    {
      name: "extend_select_to_end_of_column",
      check: isActiveAndNotEditing,
      callback: (view, e) => {
        e.preventDefault();
        e.stopPropagation();
        view.viewStore.dispatch({
          type: "DOCUMENT/JUMP_TO_NODE",
          payload: {
            target: "end-of-column",
            columns: view.documentStore.getValue().document.columns
          },
          context: {
            shiftKey: true
          }
        });
      },
      hotkeys: [{ key: "End", modifiers: ["Shift"] }]
    },
    {
      name: "extend_select_to_start_of_column",
      check: isActiveAndNotEditing,
      callback: (view, e) => {
        e.preventDefault();
        e.stopPropagation();
        view.viewStore.dispatch({
          type: "DOCUMENT/JUMP_TO_NODE",
          payload: {
            target: "start-of-column",
            columns: view.documentStore.getValue().document.columns
          },
          context: {
            shiftKey: true
          }
        });
      },
      hotkeys: [{ key: "Home", modifiers: ["Shift"] }]
    },
    {
      name: "extend_select_to_end_of_group",
      check: isActiveAndNotEditing,
      callback: (view, e) => {
        e.preventDefault();
        e.stopPropagation();
        view.viewStore.dispatch({
          type: "DOCUMENT/JUMP_TO_NODE",
          payload: {
            target: "end-of-group",
            columns: view.documentStore.getValue().document.columns
          },
          context: {
            shiftKey: true
          }
        });
      },
      hotkeys: [{ key: "PageDown", modifiers: ["Shift"] }]
    },
    {
      name: "extend_select_to_start_of_group",
      check: isActiveAndNotEditing,
      callback: (view, e) => {
        e.preventDefault();
        e.stopPropagation();
        view.viewStore.dispatch({
          type: "DOCUMENT/JUMP_TO_NODE",
          payload: {
            target: "start-of-group",
            columns: view.documentStore.getValue().document.columns
          },
          context: {
            shiftKey: true
          }
        });
      },
      hotkeys: [{ key: "PageUp", modifiers: ["Shift"] }]
    }
  );
  return commands;
};

// src/stores/view/subscriptions/effects/align-branch/helpers/get-node-element.ts
var getNodeElement = (container, nodeId) => {
  return container.querySelector("#" + nodeId);
};

// src/view/actions/keyboard-shortcuts/helpers/commands/commands/helpers/scroll-node.ts
var STEP = 20;
var scrollNode = (view, direction) => {
  const container = view.container;
  if (!container)
    return;
  const element2 = getNodeElement(
    container,
    view.viewStore.getValue().document.activeNode
  );
  if (!element2)
    return;
  if (direction === "down" || direction === "up") {
    const column = element2.matchParent(".column");
    if (!column)
      return;
    const scrollTop = direction === "up" ? STEP : -STEP;
    requestAnimationFrame(() => {
      column.scrollBy({
        top: scrollTop,
        behavior: "smooth"
      });
    });
  } else {
    const scrollLeft = direction === "left" ? STEP : -STEP;
    requestAnimationFrame(() => {
      container.scrollBy({
        left: scrollLeft,
        behavior: "smooth"
      });
    });
  }
};

// src/stores/view/subscriptions/effects/align-branch/helpers/align-element/helpers/calculate-scroll-top.ts
var VERTICAL_PADDING = 20;
var calculateScrollTop = (elementRect, containerRect, settings) => {
  const viewPortIsTallEnough = containerRect.height >= elementRect.height;
  const deltaTop = containerRect.top + VERTICAL_PADDING - elementRect.top;
  let scrollTop = 0;
  if (!viewPortIsTallEnough) {
    scrollTop = deltaTop;
  } else if (settings.horizontalScrollingMode === "fixed-position") {
    scrollTop = containerRect.top + settings.verticalOffset * containerRect.height - elementRect.top;
  } else {
    const verticalMiddle = containerRect.height / 2;
    scrollTop = verticalMiddle - (elementRect.top - containerRect.top + elementRect.height / 2);
  }
  return scrollTop;
};

// src/stores/view/subscriptions/effects/align-branch/helpers/align-element/helpers/calculate-scroll-left.ts
var HORIZONTAL_PADDING = 100;
var calculateScrollLeft = (elementRect, containerRect, settings, childRect) => {
  const viewPortIsWideEnough = containerRect.width > elementRect.width;
  const viewPortIsWideEnoughForChild = childRect ? containerRect.width > childRect.right - elementRect.left + HORIZONTAL_PADDING : true;
  const deltaRight = containerRect.right - HORIZONTAL_PADDING - elementRect.right;
  const deltaRightOfChild = !childRect ? 0 : containerRect.right - HORIZONTAL_PADDING - childRect.right;
  const deltaLeft = containerRect.left + HORIZONTAL_PADDING - elementRect.left;
  const leftSideIsVisible = deltaLeft < 0;
  const rightSideIsVisible = deltaRight > 0;
  const rightSideOfChildIsVisible = !childRect || deltaRightOfChild > 0;
  let scrollLeft = 0;
  if (!viewPortIsWideEnough) {
    scrollLeft = deltaLeft;
  } else if (settings.horizontalScrollingMode === "fixed-position") {
    scrollLeft = containerRect.left + settings.horizontalOffset * containerRect.width - elementRect.left;
  } else if (settings.horizontalScrollingMode === "keep-active-card-at-center") {
    const horizontalMiddle = containerRect.left + containerRect.width / 2;
    const elementMiddle = elementRect.left + elementRect.width / 2;
    scrollLeft = horizontalMiddle - elementMiddle;
  } else if (!leftSideIsVisible) {
    scrollLeft = deltaLeft;
  } else if (settings.horizontalScrollingMode === "reveal-active-card-and-direct-child" && !rightSideOfChildIsVisible) {
    if (viewPortIsWideEnoughForChild) {
      scrollLeft = deltaRightOfChild;
    } else {
      scrollLeft = deltaLeft;
    }
  } else if (!rightSideIsVisible) {
    scrollLeft = deltaRight;
  }
  return scrollLeft;
};

// src/stores/view/subscriptions/effects/align-branch/helpers/align-element/align-element.ts
var THRESHOLD = 5;
var alignElement = (container, elements, settings, behavior = "smooth", mode = "vertical", horizontalChild) => {
  if (!container)
    return;
  const isArray2 = Array.isArray(elements);
  const element2 = isArray2 ? elements[0] : elements;
  if (!element2)
    return;
  const column = element2.matchParent(".column");
  if (column) {
    const elementRect = isArray2 ? getCombinedBoundingClientRect(elements) : element2.getBoundingClientRect();
    const containerRect = container.parentElement.getBoundingClientRect();
    if (mode === "horizontal" || mode === "both") {
      const childRect = horizontalChild ? horizontalChild.getBoundingClientRect() : null;
      const scrollLeft = calculateScrollLeft(
        elementRect,
        containerRect,
        settings.view.scrolling,
        childRect
      );
      if (Math.abs(scrollLeft) > THRESHOLD)
        container.scrollBy({
          left: scrollLeft * -1,
          behavior
        });
    }
    if (mode === "vertical" || mode === "both") {
      const scrollTop = calculateScrollTop(
        elementRect,
        containerRect,
        settings.view.scrolling
      );
      if (Math.abs(scrollTop) > THRESHOLD)
        column.scrollBy({
          top: scrollTop * -1,
          behavior
        });
    }
    return column.id;
  }
};

// src/stores/view/subscriptions/effects/align-branch/align-parents-nodes.ts
var alignParentsNodes = (viewState, container, localState, settings, behavior) => {
  for (const id2 of viewState.document.activeBranch.sortedParentNodes) {
    const element2 = getNodeElement(container, id2);
    if (element2) {
      const columnId = alignElement(
        container,
        element2,
        settings,
        behavior
      );
      if (columnId)
        localState.columns.add(columnId);
    }
  }
};

// src/stores/view/subscriptions/effects/align-branch/helpers/apply-zoom.ts
var calculateOffset = (container, activeNode) => {
  const elementRect = activeNode?.getBoundingClientRect();
  const containerRect = container.parentElement.getBoundingClientRect();
  const horizontalMiddle = containerRect.left + containerRect.width / 2;
  const elementMiddle = elementRect.left + elementRect.width / 2;
  const scrollLeft = horizontalMiddle - elementMiddle;
  const verticalMiddle = containerRect.height / 2;
  const verticalElementMiddle = elementRect.top + elementRect.height / 2;
  const scrollTop = verticalMiddle - verticalElementMiddle;
  return { scrollLeft, scrollTop };
};
var adjustColumnsHeight = (zoomLevel, columnsContainer) => {
  const columns = Array.from(
    columnsContainer.querySelectorAll(".column")
  );
  for (const column of columns) {
    column.style.height = `${100 / zoomLevel}vh`;
  }
};
var adjustSkewedCenter = (viewState, container, columnsContainer, zoomLevel) => {
  const activeNodeId = viewState.document.activeNode;
  const activeNode = getNodeElement(container, activeNodeId);
  invariant(activeNode);
  const offset = calculateOffset(container, activeNode);
  const scaledOffsetLeft = offset.scrollLeft / zoomLevel;
  const scaledOffsetTop = (offset.scrollTop + 100) / zoomLevel;
  columnsContainer.style.transform = `scale(${zoomLevel}) translate(${scaledOffsetLeft}px,${scaledOffsetTop}px)`;
};
var applyZoom = (viewState, container, zoomLevel, adjustColumns = false) => {
  const columnsContainer = container.querySelector(".columns");
  requestAnimationFrame(() => {
    if (zoomLevel === 1) {
      columnsContainer.style.transform = "none";
    } else {
      columnsContainer.style.transform = `scale(${zoomLevel}) `;
      adjustSkewedCenter(
        viewState,
        container,
        columnsContainer,
        zoomLevel
      );
    }
    if (adjustColumns)
      adjustColumnsHeight(zoomLevel, columnsContainer);
  });
};

// src/stores/view/subscriptions/effects/align-branch/align-child-group-of-column.ts
var alignChildGroupOfColumn = (viewState, container, columnId, settings, behavior) => {
  const columnElement = getNodeElement(container, columnId);
  if (!columnElement)
    return;
  const elements = [];
  if (columnElement) {
    for (const childGroup of viewState.document.activeBranch.childGroups) {
      const element2 = getNodeElement(
        columnElement,
        "group-" + childGroup
      );
      if (element2) {
        elements.push(element2);
      }
    }
    alignElement(
      container,
      elements.length > 1 ? elements : elements[0],
      settings,
      behavior
    );
  }
};

// src/stores/view/subscriptions/effects/align-branch/align-inactive-column.ts
var alignInactiveColumn = (column, container, settings, behavior) => {
  const nodes = column.groups.map((g) => g.nodes).flat();
  if (nodes.length > 0) {
    const element2 = getNodeElement(container, nodes[nodes.length - 1]);
    if (element2)
      alignElement(container, element2, settings, behavior);
  }
};

// src/stores/view/subscriptions/effects/align-branch/align-child-columns.ts
var alignChildColumns = (viewState, documentState, container, localState, settings, behavior, alignInactiveColumns = false) => {
  let activeBranchNodeOfPreviousColumn = viewState.document.activeNode;
  for (const column of documentState.document.columns) {
    if (localState.columns.has(column.id))
      continue;
    const activeNodesOfColumn = viewState.document.activeNodesOfColumn[column.id];
    const activeBranchNode = activeNodesOfColumn && activeBranchNodeOfPreviousColumn ? activeNodesOfColumn[activeBranchNodeOfPreviousColumn] : null;
    activeBranchNodeOfPreviousColumn = activeBranchNode;
    if (activeBranchNode) {
      const element2 = getNodeElement(container, activeBranchNode);
      if (element2) {
        const columnId = alignElement(
          container,
          element2,
          settings,
          behavior
        );
        if (columnId)
          localState.columns.add(columnId);
      }
    } else {
      const childGroup = column.groups.find(
        (g) => viewState.document.activeBranch.childGroups.has(g.parentId)
      );
      if (childGroup) {
        alignChildGroupOfColumn(
          viewState,
          container,
          column.id,
          settings,
          behavior
        );
      } else if (alignInactiveColumns) {
        alignInactiveColumn(column, container, settings, behavior);
      }
    }
  }
};

// src/stores/view/subscriptions/effects/align-branch/align-active-node.ts
var alignActiveNode = (viewState, container, localState, settings, behavior) => {
  const activeNodeId = viewState.document.activeNode;
  const element2 = getNodeElement(container, activeNodeId);
  if (element2) {
    const childGroupElement = viewState.document.activeBranch.childGroups.size > 0 ? getNodeElement(container, "group-" + activeNodeId) : void 0;
    const columnId = alignElement(
      container,
      element2,
      settings,
      behavior,
      "both",
      childGroupElement
    );
    if (columnId)
      localState.columns.add(columnId);
  }
};

// src/stores/view/subscriptions/effects/align-branch/align-branch.ts
var align = async (view, behavior, alignInactiveColumns = false) => {
  const container = view.container;
  if (!container)
    return;
  const documentState = view.documentStore.getValue();
  const viewState = view.viewStore.getValue();
  const settings = view.plugin.settings.getValue();
  const zooming = settings.view.zoomLevel !== 1;
  if (zooming)
    behavior = "instant";
  const localState = {
    columns: /* @__PURE__ */ new Set()
  };
  await view.inlineEditor.mounting;
  alignActiveNode(viewState, container, localState, settings, behavior);
  alignParentsNodes(viewState, container, localState, settings, behavior);
  alignChildColumns(
    viewState,
    documentState,
    container,
    localState,
    settings,
    behavior,
    alignInactiveColumns
  );
};
var alignBranch = (view, behavior, alignInactiveColumns = false, delay = 0) => {
  const container = view.container;
  if (!container)
    return;
  const viewState = view.viewStore.getValue();
  const zoomLevel = view.plugin.settings.getValue().view.zoomLevel;
  if (!delay && zoomLevel === 1) {
    requestAnimationFrame(() => {
      align(view, behavior, alignInactiveColumns);
    });
  } else {
    setTimeout(() => {
      resetZoom(container);
      align(view, behavior, alignInactiveColumns).finally(() => {
        applyZoom(viewState, container, zoomLevel);
      });
    }, delay || 16);
  }
};

// src/view/actions/keyboard-shortcuts/helpers/commands/commands/scroll-commands.ts
var scrollCommands = () => {
  const modifiers = ["Mod", "Alt"];
  return [
    {
      name: "scroll_right",
      check: isActive,
      callback: (view) => {
        scrollNode(view, "right");
      },
      hotkeys: [{ key: "L", modifiers }]
    },
    {
      name: "scroll_left",
      check: isActive,
      callback: (view) => {
        scrollNode(view, "left");
      },
      hotkeys: [{ key: "H", modifiers }]
    },
    {
      name: "scroll_up",
      check: isActive,
      callback: (view) => {
        scrollNode(view, "up");
      },
      hotkeys: [{ key: "K", modifiers }]
    },
    {
      name: "scroll_down",
      check: isActive,
      callback: (view) => {
        scrollNode(view, "down");
      },
      hotkeys: [{ key: "J", modifiers }]
    },
    {
      name: "align_branch",
      check: isActive,
      callback: (view) => {
        alignBranch(view);
      },
      hotkeys: [{ key: "G", modifiers }]
    }
  ];
};

// src/view/actions/keyboard-shortcuts/helpers/commands/load-commands.ts
var pluginCommands = {
  current: null
};
var loadCommands = (plugin) => {
  pluginCommands.current = [
    ...navigateCommands(),
    ...editCommands(),
    ...createCommands(),
    ...moveCommands(),
    ...mergeCommands(),
    ...clipboardCommands(),
    ...historyCommands(),
    ...selectionCommands(),
    ...scrollCommands(),
    {
      name: "delete_card",
      check: isActiveAndNotEditing,
      callback: (view) => {
        const document2 = view.viewStore.getValue().document;
        view.documentStore.dispatch({
          type: "DOCUMENT/DELETE_NODE",
          payload: {
            activeNodeId: document2.activeNode,
            selectedNodes: document2.selectedNodes
          }
        });
      },
      hotkeys: [{ key: "Backspace", modifiers: ["Mod"] }]
    },
    {
      name: "toggle_search_input",
      check: isActiveAndNotEditing,
      callback: (view, e) => {
        e.preventDefault();
        e.stopPropagation();
        view.viewStore.dispatch({ type: "SEARCH/TOGGLE_INPUT" });
      },
      hotkeys: [{ key: "/", modifiers: [] }]
    }
  ];
  hotkeyStore.dispatch({
    type: "SETTINGS/LOAD_CUSTOM_HOTKEYS",
    payload: {
      customHotkeys: mapCtrlToMod(
        plugin.settings.getValue().hotkeys.customHotkeys
      )
    }
  });
};

// src/view/actions/keyboard-shortcuts/helpers/keyboard-events/hotkey-to-string.ts
var hotkeyToString = (hotkey) => hotkey.key.toUpperCase() + hotkey.modifiers.sort().join("");

// src/stores/hotkeys/reducers/update-hotkey.ts
var updateHotkey = (state2, action) => {
  const commandToUpdate = state2.hotkeys.find(
    (hotkey) => hotkey.name === action.payload.command
  );
  if (!commandToUpdate)
    return;
  let existingCustomHotkey = state2.customHotkeys[action.payload.command];
  if (!existingCustomHotkey) {
    existingCustomHotkey = {};
    state2.customHotkeys[action.payload.command] = existingCustomHotkey;
  }
  const newHotkey = {
    modifiers: action.payload.hotkey.modifiers,
    key: action.payload.hotkey.key,
    string_representation: hotkeyToString(action.payload.hotkey),
    isCustom: true
  };
  const hotkeyPosition = action.payload.primary ? 0 : 1;
  commandToUpdate.hotkeys[hotkeyPosition] = newHotkey;
  if (action.payload.primary) {
    existingCustomHotkey.primary = action.payload.hotkey;
  } else {
    existingCustomHotkey.secondary = action.payload.hotkey;
  }
};

// src/view/actions/keyboard-shortcuts/helpers/commands/command-names.ts
var hotkeysLang = {
  save_changes_and_exit_card: "Save changes and exit card",
  // toggle_edit_mode: 'Toggle edit',
  enable_edit_mode: "Edit card",
  enable_edit_mode_and_place_cursor_at_start: "Edit card and place cursor at the start",
  disable_edit_mode: "Cancel changes",
  add_child: "Add child",
  add_below: "Add card below",
  add_above: "Add card above",
  add_child_and_split: "Add child and split at cursor",
  add_below_and_split: "Add card below and split at cursor",
  add_above_and_split: "Add card above and split at cursor",
  delete_card: "Delete card",
  go_up: "Go up",
  go_down: "Go down",
  go_right: "Go right",
  go_left: "Go left",
  undo_change: "Undo change",
  redo_change: "Redo change",
  move_node_up: "Move card up",
  move_node_down: "Move card down",
  move_node_right: "Move card right",
  move_node_left: "Move card left",
  merge_with_node_above: "Merge with card above",
  merge_with_node_below: "Merge with card below",
  toggle_search_input: "Search",
  go_to_beginning_of_group: "Go to start of group",
  go_to_end_of_group: "Go to end of group",
  go_to_beginning_of_column: "Go to start of column",
  go_to_end_of_column: "Go to end of column",
  copy_node: "Copy branch",
  cut_node: "Cut branch",
  paste_node: "Paste branch",
  navigate_back: "Navigate back",
  navigate_forward: "Navigate forward",
  navigate_to_next_node: "Select next card",
  navigate_to_previous_node: "Select previous card",
  extend_select_up: "Extend selection up",
  extend_select_down: "Extend selection down",
  extend_select_to_start_of_group: "Extend selection to start of group",
  extend_select_to_end_of_group: "Extend selection to end of group",
  extend_select_to_start_of_column: "Extend selection to start of column",
  extend_select_to_end_of_column: "Extend selection to end of column",
  scroll_left: "Scroll left",
  scroll_right: "Scroll right",
  scroll_up: "Scroll up",
  scroll_down: "Scroll down",
  align_branch: "Align active branch"
};
var groupedHotkeys = {
  "Create cards": /* @__PURE__ */ new Set([
    "add_child",
    "add_below",
    "add_above",
    "add_child_and_split",
    "add_below_and_split",
    "add_above_and_split"
  ]),
  "Edit cards": /* @__PURE__ */ new Set([
    "enable_edit_mode",
    "enable_edit_mode_and_place_cursor_at_start",
    "disable_edit_mode",
    "save_changes_and_exit_card"
  ]),
  "Move cards": /* @__PURE__ */ new Set([
    "move_node_up",
    "move_node_down",
    "move_node_right",
    "move_node_left"
  ]),
  "Merge cards": /* @__PURE__ */ new Set(["merge_with_node_above", "merge_with_node_below"]),
  "Delete cards": /* @__PURE__ */ new Set(["delete_card"]),
  Navigation: /* @__PURE__ */ new Set([
    "go_up",
    "go_down",
    "go_right",
    "go_left",
    "go_to_beginning_of_group",
    "go_to_end_of_group",
    "go_to_beginning_of_column",
    "go_to_end_of_column",
    "navigate_back",
    "navigate_forward",
    "navigate_to_previous_node",
    "navigate_to_next_node"
  ]),
  Selection: /* @__PURE__ */ new Set([
    "extend_select_up",
    "extend_select_down",
    "extend_select_to_start_of_group",
    "extend_select_to_end_of_group",
    "extend_select_to_start_of_column",
    "extend_select_to_end_of_column"
  ]),
  History: /* @__PURE__ */ new Set(["undo_change", "redo_change"]),
  Search: /* @__PURE__ */ new Set(["toggle_search_input"]),
  Clipboard: /* @__PURE__ */ new Set(["copy_node", "cut_node", "paste_node"]),
  Scrolling: /* @__PURE__ */ new Set([
    "scroll_left",
    "scroll_right",
    "scroll_up",
    "scroll_down",
    "align_branch"
  ])
};
var hotkeysGroups = Object.fromEntries(
  Object.entries(groupedHotkeys).map(([group, commands]) => Array.from(commands).map((c) => [c, group])).flat()
);

// src/stores/hotkeys/reducers/helpers/command-to-hotkeys.ts
var commandToHotkeys = (command) => {
  return {
    name: command.name,
    hotkeys: command.hotkeys.map((h) => ({
      string_representation: hotkeyToString(h),
      key: h.key,
      modifiers: [...h.modifiers]
    })),
    group: hotkeysGroups[command.name]
  };
};

// src/stores/hotkeys/reducers/load-custom-hotkeys.ts
var loadCustomHotkeys = (state2, action) => {
  for (const [name, customHotkey] of Object.entries(
    action.payload.customHotkeys
  )) {
    if (customHotkey.primary || customHotkey.secondary) {
      state2.customHotkeys[name] = customHotkey;
    }
  }
  invariant(pluginCommands.current);
  state2.hotkeys = [];
  for (const pluginCommand of pluginCommands.current) {
    const hotkey = commandToHotkeys(pluginCommand);
    state2.hotkeys.push(hotkey);
    const customHotkey = state2.customHotkeys[hotkey.name];
    if (customHotkey) {
      updateHotkey(state2, {
        type: "HOTKEY/UPDATE",
        payload: {
          command: hotkey.name,
          hotkey: customHotkey.primary || customHotkey.secondary,
          primary: !!customHotkey.primary
        }
      });
    }
  }
};

// src/stores/hotkeys/reducers/reset-hotkey.ts
var resetHotkey = (state2, action) => {
  const hotkey = state2.hotkeys.find(
    (hotkey2) => hotkey2.name === action.payload.command
  );
  if (!hotkey)
    return;
  if (pluginCommands.current) {
    const command = pluginCommands.current.find(
      (command2) => command2.name === action.payload.command
    );
    if (command) {
      const defaultHotkeys = commandToHotkeys(command).hotkeys;
      const index = action.payload.primary ? 0 : 1;
      hotkey.hotkeys[index] = defaultHotkeys[index];
      const customHotkeys = state2.customHotkeys[action.payload.command];
      if (customHotkeys)
        if (action.payload.primary) {
          delete customHotkeys.primary;
        } else {
          delete customHotkeys.secondary;
        }
    }
  }
};

// src/stores/hotkeys/reducers/update-conflicting-hotkeys.ts
var updateConflictingHotkeys = (state2, action) => {
  let numberOfConflictingHotkeys = 0;
  const groupedByHotkey = /* @__PURE__ */ new Map();
  for (const pluginHotkey of state2.hotkeys) {
    for (const hotkey of pluginHotkey.hotkeys) {
      delete hotkey.obsidianConflict;
      delete hotkey.pluginConflict;
      const conflict = action.payload.conflictingHotkeys.get(
        hotkey.string_representation
      );
      if (conflict) {
        hotkey.obsidianConflict = conflict;
        numberOfConflictingHotkeys++;
      } else {
        let set = groupedByHotkey.get(hotkey.string_representation);
        if (!set) {
          set = /* @__PURE__ */ new Set();
          groupedByHotkey.set(hotkey.string_representation, set);
        }
        set.add(pluginHotkey);
      }
    }
  }
  const conflicting = [...groupedByHotkey.entries()].filter(
    (v) => v[1].size > 1
  );
  for (const [string_representation, hotkeys] of conflicting) {
    const conflicting2 = Array.from(hotkeys).map((h) => h.name).join(", ");
    for (const pluginHotkey of hotkeys) {
      for (const hotkey of pluginHotkey.hotkeys) {
        if (hotkey.string_representation === string_representation) {
          hotkey.pluginConflict = conflicting2;
          numberOfConflictingHotkeys++;
        }
      }
    }
  }
  state2.numberOfConflictingHotkeys = numberOfConflictingHotkeys;
};

// src/stores/hotkeys/hotkey-reducer.ts
var updateState = (state2, action) => {
  if (action.type === "UI/SET_SEARCH_TERM") {
    state2.searchTerm = action.payload.searchTerm.toLowerCase();
  } else if (action.type === "SETTINGS/LOAD_CUSTOM_HOTKEYS") {
    loadCustomHotkeys(state2, action);
  } else if (action.type === "HOTKEY/UPDATE") {
    updateHotkey(state2, action);
  } else if (action.type === "HOTKEY/RESET") {
    resetHotkey(state2, action);
  } else if (action.type === "SET_CONFLICTING_HOTKEYS") {
    updateConflictingHotkeys(state2, action);
  }
};
var hotkeyReducer = (store, action) => {
  updateState(store, action);
  return store;
};

// src/stores/hotkeys/hotkey-store.ts
var initialValue = {
  hotkeys: [],
  searchTerm: "",
  customHotkeys: {},
  numberOfConflictingHotkeys: 0
};
var hotkeyStore = new Store(
  initialValue,
  hotkeyReducer
);

// src/helpers/group-array-by-property.ts
var groupArrayByProperty = (array, property, grouped = {}) => {
  for (const item of array) {
    const key = String(item[property]);
    if (!grouped[key]) {
      grouped[key] = [];
    }
    grouped[key].push(item);
  }
  for (const key of Object.keys(grouped)) {
    if (grouped[key].length === 0) {
      delete grouped[key];
    }
  }
  return grouped;
};

// src/stores/hotkeys/derived/filtered-hotkeys.ts
var filteredHotkeys = derivedOnAction(
  hotkeyStore,
  (store) => {
    let array = [];
    if (store.searchTerm) {
      array = store.hotkeys.filter((c) => {
        const fullName = hotkeysLang[c.name].toLowerCase();
        return fullName.includes(store.searchTerm) || c.group.toLowerCase().includes(store.searchTerm);
      });
    } else
      array = store.hotkeys;
    return groupArrayByProperty(array, "group", {
      "Create cards": [],
      "Edit cards": [],
      "Move cards": [],
      "Merge cards": [],
      "Delete cards": [],
      Clipboard: [],
      Navigation: [],
      Selection: [],
      Scrolling: [],
      History: [],
      Search: []
    });
  },
  ["UI/SET_SEARCH_TERM", "SET_CONFLICTING_HOTKEYS"]
);

// src/view/actions/keyboard-shortcuts/helpers/keyboard-events/mod-key-dictionary.ts
var modKeyDictionary = {
  Mod: modKey,
  Alt: "Alt",
  Ctrl: "Ctrl",
  Meta: "Meta",
  Shift: "Shift"
};

// src/view/components/container/controls-bar/modals/hotkeys/components/hotkey/render-hotkey.svelte
function add_css24(target) {
  append_styles(target, "svelte-xx7tpf", ".hotkey-buttons.svelte-xx7tpf{width:100%;height:100%;position:absolute;left:0;right:0;top:0;bottom:0;display:flex;align-items:center;justify-content:center;gap:5px;opacity:0;background-color:var(--color-base-70)}.hotkey-button.svelte-xx7tpf{border:none;width:16px;height:16px;box-shadow:none;padding:2px;cursor:pointer}.hotkey-buttons.svelte-xx7tpf:hover{opacity:0.8}.hotkey-key.svelte-xx7tpf{color:var(--text-on-accent);background-color:#175c5a}");
}
function get_each_context8(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[2] = list[i];
  return child_ctx;
}
function create_each_block8(ctx) {
  let kbd;
  let t_value = modKeyDictionary[
    /*modifier*/
    ctx[2]
  ] + "";
  let t;
  return {
    c() {
      kbd = element("kbd");
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, kbd, anchor);
      append(kbd, t);
    },
    p(ctx2, dirty) {
      if (dirty & /*hotkey*/
      2 && t_value !== (t_value = modKeyDictionary[
        /*modifier*/
        ctx2[2]
      ] + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(kbd);
      }
    }
  };
}
function create_fragment65(ctx) {
  let div;
  let button;
  let pen;
  let t0;
  let kbd;
  let t1_value = (
    /*hotkey*/
    ctx[1].key + ""
  );
  let t1;
  let t2;
  let each_1_anchor;
  let current;
  let mounted;
  let dispose;
  pen = new pen_default({ props: { class: "svg-icon", size: 8 } });
  let each_value = ensure_array_like(
    /*hotkey*/
    ctx[1].modifiers
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block8(get_each_context8(ctx, each_value, i));
  }
  return {
    c() {
      div = element("div");
      button = element("button");
      create_component(pen.$$.fragment);
      t0 = space();
      kbd = element("kbd");
      t1 = text(t1_value);
      t2 = space();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
      attr(button, "class", "hotkey-button svelte-xx7tpf");
      attr(div, "class", "hotkey-buttons svelte-xx7tpf");
      attr(kbd, "class", "hotkey-key svelte-xx7tpf");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, button);
      mount_component(pen, button, null);
      insert(target, t0, anchor);
      insert(target, kbd, anchor);
      append(kbd, t1);
      insert(target, t2, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
      if (!mounted) {
        dispose = listen(button, "click", function() {
          if (is_function(
            /*enableEditing*/
            ctx[0]
          ))
            ctx[0].apply(this, arguments);
        });
        mounted = true;
      }
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      if ((!current || dirty & /*hotkey*/
      2) && t1_value !== (t1_value = /*hotkey*/
      ctx[1].key + ""))
        set_data(t1, t1_value);
      if (dirty & /*hotkey*/
      2) {
        each_value = ensure_array_like(
          /*hotkey*/
          ctx[1].modifiers
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context8(ctx, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block8(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(pen.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(pen.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
        detach(t0);
        detach(kbd);
        detach(t2);
        detach(each_1_anchor);
      }
      destroy_component(pen);
      destroy_each(each_blocks, detaching);
      mounted = false;
      dispose();
    }
  };
}
function instance63($$self, $$props, $$invalidate) {
  let { enableEditing } = $$props;
  let { hotkey } = $$props;
  $$self.$$set = ($$props2) => {
    if ("enableEditing" in $$props2)
      $$invalidate(0, enableEditing = $$props2.enableEditing);
    if ("hotkey" in $$props2)
      $$invalidate(1, hotkey = $$props2.hotkey);
  };
  return [enableEditing, hotkey];
}
var Render_hotkey = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance63, create_fragment65, safe_not_equal, { enableEditing: 0, hotkey: 1 }, add_css24);
  }
};
var render_hotkey_default = Render_hotkey;

// src/view/actions/keyboard-shortcuts/helpers/commands/update-commands-dictionary.ts
var commandsDictionary = {
  current: {}
};
var updateCommandsDictionary = (pluginHotkeys) => {
  if (!pluginCommands.current)
    return;
  const dictByName = Object.fromEntries(
    pluginCommands.current.map((command) => [command.name, command])
  );
  commandsDictionary.current = {};
  for (const pluginHotkey of pluginHotkeys) {
    for (const hotkey of pluginHotkey.hotkeys) {
      commandsDictionary.current[hotkeyToString(hotkey)] = {
        ...dictByName[pluginHotkey.name],
        hotkeys: pluginHotkey.hotkeys
      };
    }
  }
};

// src/stores/view/subscriptions/effects/focus-container.ts
var import_obsidian21 = require("obsidian");
var focusContainer = (view) => {
  setTimeout(() => {
    if (view.container) {
      const isEditing2 = Boolean(view.inlineEditor.activeNode);
      const isEditingOnMobile = import_obsidian21.Platform.isMobile && isEditing2;
      if (!isEditingOnMobile) {
        if (isEditing2)
          view.inlineEditor.focus();
        else
          view.container.focus();
      }
    }
  }, 16);
};

// src/view/components/container/controls-bar/modals/hotkeys/components/hotkey/edit-hotkey.svelte
function add_css25(target) {
  append_styles(target, "svelte-imuvuj", ".container.svelte-imuvuj{display:flex;gap:5px;align-items:center;justify-content:center}.hotkey-container.svelte-imuvuj{display:flex;flex-direction:column;align-items:center;gap:5px}.input.svelte-imuvuj{width:115px;height:25px;text-align:center;font-size:14px}.modifiers.svelte-imuvuj{display:flex;gap:5px;width:100%;justify-content:center}.disabled.svelte-imuvuj{background-color:var(--color-base-50)}button.svelte-imuvuj:disabled{cursor:not-allowed}.save-and-cancel-buttons.svelte-imuvuj{display:flex;gap:5px;flex-direction:column}.hotkey-button.svelte-imuvuj{background-color:transparent;color:var(--color-base-25);border:none;width:20px;height:20px;box-shadow:none;padding:2px;cursor:pointer}.hotkey-key.svelte-imuvuj{color:lightgrey;background-color:#175c5a;border-color:#227f7d\n    }");
}
function create_if_block11(ctx) {
  let kbd;
  let t_value = "Ctrl" /* Ctrl */ + "";
  let t;
  let kbd_class_value;
  let mounted;
  let dispose;
  return {
    c() {
      kbd = element("kbd");
      t = text(t_value);
      attr(kbd, "class", kbd_class_value = null_to_empty(!/*CTRL*/
      ctx[6] ? "disabled" : "") + " svelte-imuvuj");
    },
    m(target, anchor) {
      insert(target, kbd, anchor);
      append(kbd, t);
      if (!mounted) {
        dispose = listen(
          kbd,
          "click",
          /*toggleCtrl*/
          ctx[11]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*CTRL*/
      64 && kbd_class_value !== (kbd_class_value = null_to_empty(!/*CTRL*/
      ctx2[6] ? "disabled" : "") + " svelte-imuvuj")) {
        attr(kbd, "class", kbd_class_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(kbd);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_fragment66(ctx) {
  let div3;
  let div1;
  let div0;
  let t0;
  let kbd0;
  let t1;
  let kbd0_class_value;
  let t2;
  let kbd1;
  let t3_value = "Alt" /* Alt */ + "";
  let t3;
  let kbd1_class_value;
  let t4;
  let kbd2;
  let t5_value = "Shift" /* Shift */ + "";
  let t5;
  let kbd2_class_value;
  let t6;
  let input;
  let input_placeholder_value;
  let t7;
  let div2;
  let button0;
  let x;
  let t8;
  let button1;
  let rotateccw;
  let button1_disabled_value;
  let current;
  let mounted;
  let dispose;
  let if_block = isMacLike && create_if_block11(ctx);
  x = new x_default({ props: { class: "svg-icon", size: 8 } });
  rotateccw = new rotate_ccw_default({ props: { class: "svg-icon", size: 8 } });
  return {
    c() {
      div3 = element("div");
      div1 = element("div");
      div0 = element("div");
      if (if_block)
        if_block.c();
      t0 = space();
      kbd0 = element("kbd");
      t1 = text(modKey);
      t2 = space();
      kbd1 = element("kbd");
      t3 = text(t3_value);
      t4 = space();
      kbd2 = element("kbd");
      t5 = text(t5_value);
      t6 = space();
      input = element("input");
      t7 = space();
      div2 = element("div");
      button0 = element("button");
      create_component(x.$$.fragment);
      t8 = space();
      button1 = element("button");
      create_component(rotateccw.$$.fragment);
      attr(kbd0, "class", kbd0_class_value = null_to_empty(!/*MOD*/
      ctx[3] ? "disabled" : "") + " svelte-imuvuj");
      attr(kbd1, "class", kbd1_class_value = null_to_empty(!/*ALT*/
      ctx[5] ? "disabled" : "") + " svelte-imuvuj");
      attr(kbd2, "class", kbd2_class_value = null_to_empty(!/*SHIFT*/
      ctx[4] ? "disabled" : "") + " svelte-imuvuj");
      attr(div0, "class", "modifiers svelte-imuvuj");
      attr(input, "class", "search-input input hotkey-key svelte-imuvuj");
      attr(input, "placeholder", input_placeholder_value = "Key");
      attr(input, "spellcheck", "false");
      attr(input, "type", "text");
      attr(div1, "class", "hotkey-container svelte-imuvuj");
      attr(button0, "aria-label", "Go back");
      attr(button0, "class", "hotkey-button svelte-imuvuj");
      attr(button1, "aria-label", "Reset");
      attr(button1, "class", "hotkey-button svelte-imuvuj");
      button1.disabled = button1_disabled_value = !/*isCustom*/
      ctx[0];
      attr(div2, "class", "save-and-cancel-buttons svelte-imuvuj");
      attr(div3, "class", "container svelte-imuvuj");
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      append(div3, div1);
      append(div1, div0);
      if (if_block)
        if_block.m(div0, null);
      append(div0, t0);
      append(div0, kbd0);
      append(kbd0, t1);
      append(div0, t2);
      append(div0, kbd1);
      append(kbd1, t3);
      append(div0, t4);
      append(div0, kbd2);
      append(kbd2, t5);
      append(div1, t6);
      append(div1, input);
      set_input_value(
        input,
        /*key*/
        ctx[2]
      );
      append(div3, t7);
      append(div3, div2);
      append(div2, button0);
      mount_component(x, button0, null);
      append(div2, t8);
      append(div2, button1);
      mount_component(rotateccw, button1, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            kbd0,
            "click",
            /*toggleMod*/
            ctx[8]
          ),
          listen(
            kbd1,
            "click",
            /*toggleAlt*/
            ctx[10]
          ),
          listen(
            kbd2,
            "click",
            /*toggleShift*/
            ctx[9]
          ),
          listen(
            input,
            "input",
            /*input_input_handler*/
            ctx[16]
          ),
          listen(
            input,
            "keydown",
            /*onKeyDown*/
            ctx[7]
          ),
          listen(button0, "click", function() {
            if (is_function(
              /*onCancel*/
              ctx[1]
            ))
              ctx[1].apply(this, arguments);
          }),
          listen(
            button1,
            "click",
            /*reset*/
            ctx[12]
          )
        ];
        mounted = true;
      }
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      if (isMacLike)
        if_block.p(ctx, dirty);
      if (!current || dirty & /*MOD*/
      8 && kbd0_class_value !== (kbd0_class_value = null_to_empty(!/*MOD*/
      ctx[3] ? "disabled" : "") + " svelte-imuvuj")) {
        attr(kbd0, "class", kbd0_class_value);
      }
      if (!current || dirty & /*ALT*/
      32 && kbd1_class_value !== (kbd1_class_value = null_to_empty(!/*ALT*/
      ctx[5] ? "disabled" : "") + " svelte-imuvuj")) {
        attr(kbd1, "class", kbd1_class_value);
      }
      if (!current || dirty & /*SHIFT*/
      16 && kbd2_class_value !== (kbd2_class_value = null_to_empty(!/*SHIFT*/
      ctx[4] ? "disabled" : "") + " svelte-imuvuj")) {
        attr(kbd2, "class", kbd2_class_value);
      }
      if (dirty & /*key*/
      4 && input.value !== /*key*/
      ctx[2]) {
        set_input_value(
          input,
          /*key*/
          ctx[2]
        );
      }
      if (!current || dirty & /*isCustom*/
      1 && button1_disabled_value !== (button1_disabled_value = !/*isCustom*/
      ctx[0])) {
        button1.disabled = button1_disabled_value;
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(x.$$.fragment, local);
      transition_in(rotateccw.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(x.$$.fragment, local);
      transition_out(rotateccw.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div3);
      }
      if (if_block)
        if_block.d();
      destroy_component(x);
      destroy_component(rotateccw);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance64($$self, $$props, $$invalidate) {
  let { isCustom } = $$props;
  let { hotkey } = $$props;
  let { commandName } = $$props;
  let { isPrimary } = $$props;
  let { onCancel } = $$props;
  let key = hotkey.key;
  let MOD = hotkey.modifiers.includes("Mod");
  let SHIFT = hotkey.modifiers.includes("Shift");
  let ALT = hotkey.modifiers.includes("Alt");
  let CTRL = hotkey.modifiers.includes("Ctrl");
  const onKeyDown = (e) => {
    e.preventDefault();
    if (e.shiftKey || e.ctrlKey || e.altKey || e.metaKey)
      return;
    if (e.key === " " || e.key === "META")
      return;
    const value = e.key.toUpperCase();
    $$invalidate(2, key = value.length === 1 ? value.toUpperCase() : value);
    save();
  };
  const toggleMod = () => {
    $$invalidate(3, MOD = !MOD);
    save();
  };
  const toggleShift = () => {
    $$invalidate(4, SHIFT = !SHIFT);
    save();
  };
  const toggleAlt = () => {
    $$invalidate(5, ALT = !ALT);
    save();
  };
  const toggleCtrl = () => {
    $$invalidate(6, CTRL = !CTRL);
    save();
  };
  const save = () => {
    let modifiers = [];
    if (MOD)
      modifiers.push("Mod");
    if (SHIFT)
      modifiers.push("Shift");
    if (ALT)
      modifiers.push("Alt");
    if (CTRL && isMacLike)
      modifiers.push("Ctrl");
    hotkeyStore.dispatch({
      type: "HOTKEY/UPDATE",
      payload: {
        hotkey: { key, modifiers },
        primary: isPrimary,
        command: commandName
      }
    });
  };
  const view = getView();
  const reset = () => {
    hotkeyStore.dispatch({
      type: "HOTKEY/RESET",
      payload: { command: commandName, primary: isPrimary }
    });
    setTimeout(() => {
      $$invalidate(3, MOD = hotkey.modifiers.includes("Mod"));
      $$invalidate(5, ALT = hotkey.modifiers.includes("Alt"));
      $$invalidate(4, SHIFT = hotkey.modifiers.includes("Shift"));
      $$invalidate(6, CTRL = hotkey.modifiers.includes("Ctrl"));
      $$invalidate(2, key = hotkey.key);
    });
    focusContainer(view);
  };
  function input_input_handler() {
    key = this.value;
    $$invalidate(2, key);
  }
  $$self.$$set = ($$props2) => {
    if ("isCustom" in $$props2)
      $$invalidate(0, isCustom = $$props2.isCustom);
    if ("hotkey" in $$props2)
      $$invalidate(13, hotkey = $$props2.hotkey);
    if ("commandName" in $$props2)
      $$invalidate(14, commandName = $$props2.commandName);
    if ("isPrimary" in $$props2)
      $$invalidate(15, isPrimary = $$props2.isPrimary);
    if ("onCancel" in $$props2)
      $$invalidate(1, onCancel = $$props2.onCancel);
  };
  return [
    isCustom,
    onCancel,
    key,
    MOD,
    SHIFT,
    ALT,
    CTRL,
    onKeyDown,
    toggleMod,
    toggleShift,
    toggleAlt,
    toggleCtrl,
    reset,
    hotkey,
    commandName,
    isPrimary,
    input_input_handler
  ];
}
var Edit_hotkey = class extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance64,
      create_fragment66,
      safe_not_equal,
      {
        isCustom: 0,
        hotkey: 13,
        commandName: 14,
        isPrimary: 15,
        onCancel: 1
      },
      add_css25
    );
  }
};
var edit_hotkey_default = Edit_hotkey;

// src/view/components/container/controls-bar/modals/hotkeys/components/hotkey/hotkey.svelte
var import_classnames4 = __toESM(require_classnames());
function add_css26(target) {
  append_styles(target, "svelte-1ctyvzu", ".hotkey.svelte-1ctyvzu{padding:5px;background-color:var(--color-base-50);display:flex;gap:5px;border-radius:3px;width:fit-content;position:relative}.editing.svelte-1ctyvzu{background-color:var(--color-base-60)}.hotkey--is-custom.svelte-1ctyvzu{background-color:var(--custom-hotkey-bg)}.obsidian-conflict.svelte-1ctyvzu{background-color:var(--color-red)}.plugin-conflict.svelte-1ctyvzu{background-color:var(--color-orange)}");
}
function create_else_block4(ctx) {
  let renderhotkey;
  let current;
  renderhotkey = new render_hotkey_default({
    props: {
      hotkey: (
        /*hotkey*/
        ctx[0]
      ),
      enableEditing: (
        /*func_1*/
        ctx[6]
      )
    }
  });
  return {
    c() {
      create_component(renderhotkey.$$.fragment);
    },
    m(target, anchor) {
      mount_component(renderhotkey, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const renderhotkey_changes = {};
      if (dirty & /*hotkey*/
      1)
        renderhotkey_changes.hotkey = /*hotkey*/
        ctx2[0];
      renderhotkey.$set(renderhotkey_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(renderhotkey.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(renderhotkey.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(renderhotkey, detaching);
    }
  };
}
function create_if_block12(ctx) {
  let edithotkey;
  let current;
  edithotkey = new edit_hotkey_default({
    props: {
      hotkey: (
        /*hotkey*/
        ctx[0]
      ),
      onCancel: (
        /*func*/
        ctx[5]
      ),
      isPrimary: (
        /*isPrimary*/
        ctx[2]
      ),
      commandName: (
        /*commandName*/
        ctx[1]
      ),
      isCustom: (
        /*hotkey*/
        ctx[0].isCustom
      )
    }
  });
  return {
    c() {
      create_component(edithotkey.$$.fragment);
    },
    m(target, anchor) {
      mount_component(edithotkey, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const edithotkey_changes = {};
      if (dirty & /*hotkey*/
      1)
        edithotkey_changes.hotkey = /*hotkey*/
        ctx2[0];
      if (dirty & /*isPrimary*/
      4)
        edithotkey_changes.isPrimary = /*isPrimary*/
        ctx2[2];
      if (dirty & /*commandName*/
      2)
        edithotkey_changes.commandName = /*commandName*/
        ctx2[1];
      if (dirty & /*hotkey*/
      1)
        edithotkey_changes.isCustom = /*hotkey*/
        ctx2[0].isCustom;
      edithotkey.$set(edithotkey_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(edithotkey.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(edithotkey.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(edithotkey, detaching);
    }
  };
}
function create_fragment67(ctx) {
  let div;
  let current_block_type_index;
  let if_block;
  let div_aria_label_value;
  let div_class_value;
  let current;
  const if_block_creators = [create_if_block12, create_else_block4];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*$editing*/
      ctx2[3]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      div = element("div");
      if_block.c();
      attr(div, "aria-label", div_aria_label_value = /*hotkey*/
      ctx[0].obsidianConflict ? `Used by "${/*hotkey*/
      ctx[0].obsidianConflict}"` : (
        /*hotkey*/
        ctx[0].pluginConflict ? `Used by "${/*hotkey*/
        ctx[0].pluginConflict}"` : ""
      ));
      attr(div, "class", div_class_value = null_to_empty((0, import_classnames4.default)(
        "hotkey",
        /*hotkey*/
        ctx[0].obsidianConflict && "obsidian-conflict",
        /*hotkey*/
        ctx[0].pluginConflict && "plugin-conflict",
        /*hotkey*/
        ctx[0].isCustom && "hotkey--is-custom",
        /*$editing*/
        ctx[3] && "editing"
      )) + " svelte-1ctyvzu");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if_blocks[current_block_type_index].m(div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(div, null);
      }
      if (!current || dirty & /*hotkey*/
      1 && div_aria_label_value !== (div_aria_label_value = /*hotkey*/
      ctx2[0].obsidianConflict ? `Used by "${/*hotkey*/
      ctx2[0].obsidianConflict}"` : (
        /*hotkey*/
        ctx2[0].pluginConflict ? `Used by "${/*hotkey*/
        ctx2[0].pluginConflict}"` : ""
      ))) {
        attr(div, "aria-label", div_aria_label_value);
      }
      if (!current || dirty & /*hotkey, $editing*/
      9 && div_class_value !== (div_class_value = null_to_empty((0, import_classnames4.default)(
        "hotkey",
        /*hotkey*/
        ctx2[0].obsidianConflict && "obsidian-conflict",
        /*hotkey*/
        ctx2[0].pluginConflict && "plugin-conflict",
        /*hotkey*/
        ctx2[0].isCustom && "hotkey--is-custom",
        /*$editing*/
        ctx2[3] && "editing"
      )) + " svelte-1ctyvzu")) {
        attr(div, "class", div_class_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if_blocks[current_block_type_index].d();
    }
  };
}
function instance65($$self, $$props, $$invalidate) {
  let $editing;
  let { hotkey } = $$props;
  let { commandName } = $$props;
  let { isPrimary } = $$props;
  const view = getView();
  const editing = writable(false);
  component_subscribe($$self, editing, (value) => $$invalidate(3, $editing = value));
  onMount(() => {
    let initialRun = true;
    return editing.subscribe(() => {
      if (initialRun) {
        initialRun = false;
      } else {
        focusContainer(view);
      }
    });
  });
  const func2 = () => editing.set(false);
  const func_1 = () => editing.set(true);
  $$self.$$set = ($$props2) => {
    if ("hotkey" in $$props2)
      $$invalidate(0, hotkey = $$props2.hotkey);
    if ("commandName" in $$props2)
      $$invalidate(1, commandName = $$props2.commandName);
    if ("isPrimary" in $$props2)
      $$invalidate(2, isPrimary = $$props2.isPrimary);
  };
  return [hotkey, commandName, isPrimary, $editing, editing, func2, func_1];
}
var Hotkey = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance65, create_fragment67, safe_not_equal, { hotkey: 0, commandName: 1, isPrimary: 2 }, add_css26);
  }
};
var hotkey_default = Hotkey;

// src/view/components/container/controls-bar/modals/hotkeys/components/command.svelte
function add_css27(target) {
  append_styles(target, "svelte-16zu1cl", ".command.svelte-16zu1cl{padding:8px;display:flex;align-items:center;justify-content:space-between;border-radius:4px;gap:8px;background-color:var(--color-base-30)}@media(max-width: 720px){.command.svelte-16zu1cl{flex-direction:column;align-items:start;width:190px}.hotkeys.svelte-16zu1cl{align-self:center}}.hotkeys.svelte-16zu1cl{display:flex;flex-direction:column;align-items:end;gap:5px}.label.svelte-16zu1cl{font-size:14px;color:var(--text-normal);display:block}");
}
function get_each_context9(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[1] = list[i];
  child_ctx[3] = i;
  return child_ctx;
}
function create_each_block9(ctx) {
  let hotkey_1;
  let current;
  hotkey_1 = new hotkey_default({
    props: {
      hotkey: (
        /*hotkey*/
        ctx[1]
      ),
      commandName: (
        /*commandHotkeys*/
        ctx[0].name
      ),
      isPrimary: (
        /*i*/
        ctx[3] === 0
      )
    }
  });
  return {
    c() {
      create_component(hotkey_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(hotkey_1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const hotkey_1_changes = {};
      if (dirty & /*commandHotkeys*/
      1)
        hotkey_1_changes.hotkey = /*hotkey*/
        ctx2[1];
      if (dirty & /*commandHotkeys*/
      1)
        hotkey_1_changes.commandName = /*commandHotkeys*/
        ctx2[0].name;
      hotkey_1.$set(hotkey_1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(hotkey_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(hotkey_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(hotkey_1, detaching);
    }
  };
}
function create_fragment68(ctx) {
  let div1;
  let span;
  let t0_value = hotkeysLang[
    /*commandHotkeys*/
    ctx[0].name
  ] + "";
  let t0;
  let t1;
  let div0;
  let current;
  let each_value = ensure_array_like(
    /*commandHotkeys*/
    ctx[0].hotkeys
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block9(get_each_context9(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  return {
    c() {
      div1 = element("div");
      span = element("span");
      t0 = text(t0_value);
      t1 = space();
      div0 = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(span, "class", "label svelte-16zu1cl");
      attr(div0, "class", "hotkeys svelte-16zu1cl");
      attr(div1, "class", "command svelte-16zu1cl");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, span);
      append(span, t0);
      append(div1, t1);
      append(div1, div0);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div0, null);
        }
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if ((!current || dirty & /*commandHotkeys*/
      1) && t0_value !== (t0_value = hotkeysLang[
        /*commandHotkeys*/
        ctx2[0].name
      ] + ""))
        set_data(t0, t0_value);
      if (dirty & /*commandHotkeys*/
      1) {
        each_value = ensure_array_like(
          /*commandHotkeys*/
          ctx2[0].hotkeys
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context9(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block9(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(div0, null);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function instance66($$self, $$props, $$invalidate) {
  let { commandHotkeys } = $$props;
  $$self.$$set = ($$props2) => {
    if ("commandHotkeys" in $$props2)
      $$invalidate(0, commandHotkeys = $$props2.commandHotkeys);
  };
  return [commandHotkeys];
}
var Command = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance66, create_fragment68, safe_not_equal, { commandHotkeys: 0 }, add_css27);
  }
};
var command_default = Command;

// src/view/components/container/controls-bar/modals/hotkeys/group.svelte
function add_css28(target) {
  append_styles(target, "svelte-1odqylp", ".group.svelte-1odqylp{background-color:var(--background-secondary);padding:var(--size-4-2);border-radius:3px}.hotkeys-list.svelte-1odqylp{display:flex;flex-direction:column;gap:var(--size-4-2);overflow-y:auto}.group-name.svelte-1odqylp{padding-bottom:10px;padding-left:5px;font-size:16px;color:var(--color-base-70)}");
}
function get_each_context10(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[2] = list[i];
  return child_ctx;
}
function create_each_block10(key_1, ctx) {
  let first;
  let hotkey;
  let current;
  hotkey = new command_default({
    props: {
      commandHotkeys: (
        /*commandHotkeys*/
        ctx[2]
      )
    }
  });
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      create_component(hotkey.$$.fragment);
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      mount_component(hotkey, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const hotkey_changes = {};
      if (dirty & /*group*/
      1)
        hotkey_changes.commandHotkeys = /*commandHotkeys*/
        ctx[2];
      hotkey.$set(hotkey_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(hotkey.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(hotkey.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(first);
      }
      destroy_component(hotkey, detaching);
    }
  };
}
function create_fragment69(ctx) {
  let div2;
  let div0;
  let t0;
  let t1;
  let div1;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let current;
  let each_value = ensure_array_like(
    /*group*/
    ctx[0]
  );
  const get_key = (ctx2) => (
    /*commandHotkeys*/
    ctx2[2].name
  );
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context10(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block10(key, child_ctx));
  }
  return {
    c() {
      div2 = element("div");
      div0 = element("div");
      t0 = text(
        /*groupName*/
        ctx[1]
      );
      t1 = space();
      div1 = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(div0, "class", "group-name svelte-1odqylp");
      attr(div1, "class", "hotkeys-list svelte-1odqylp");
      attr(div2, "class", "group svelte-1odqylp");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div0);
      append(div0, t0);
      append(div2, t1);
      append(div2, div1);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div1, null);
        }
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (!current || dirty & /*groupName*/
      2)
        set_data(
          t0,
          /*groupName*/
          ctx2[1]
        );
      if (dirty & /*group*/
      1) {
        each_value = ensure_array_like(
          /*group*/
          ctx2[0]
        );
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, div1, outro_and_destroy_block, create_each_block10, null, get_each_context10);
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
    }
  };
}
function instance67($$self, $$props, $$invalidate) {
  let { group } = $$props;
  let { groupName } = $$props;
  $$self.$$set = ($$props2) => {
    if ("group" in $$props2)
      $$invalidate(0, group = $$props2.group);
    if ("groupName" in $$props2)
      $$invalidate(1, groupName = $$props2.groupName);
  };
  return [group, groupName];
}
var Group2 = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance67, create_fragment69, safe_not_equal, { group: 0, groupName: 1 }, add_css28);
  }
};
var group_default2 = Group2;

// src/view/components/container/controls-bar/modals/hotkeys/front.svelte
function add_css29(target) {
  append_styles(target, "svelte-105pskz", ".front.svelte-105pskz{display:flex;justify-content:space-between;align-items:center;width:100%}.search-input-container.svelte-105pskz{width:100%}");
}
function create_fragment70(ctx) {
  let div2;
  let div1;
  let input;
  let input_placeholder_value;
  let t;
  let div0;
  let div0_aria_label_value;
  let mounted;
  let dispose;
  return {
    c() {
      div2 = element("div");
      div1 = element("div");
      input = element("input");
      t = space();
      div0 = element("div");
      attr(input, "class", "search-input");
      attr(input, "enterkeyhint", "search");
      attr(input, "placeholder", input_placeholder_value = "Filter");
      attr(input, "spellcheck", "false");
      attr(input, "type", "search");
      attr(div0, "aria-label", div0_aria_label_value = "Clear");
      attr(div0, "class", "search-input-clear-button");
      attr(div1, "class", "search-input-container svelte-105pskz");
      attr(div2, "class", "front svelte-105pskz");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div1);
      append(div1, input);
      set_input_value(
        input,
        /*searchTerm*/
        ctx[0]
      );
      append(div1, t);
      append(div1, div0);
      if (!mounted) {
        dispose = [
          listen(
            input,
            "input",
            /*input_input_handler*/
            ctx[1]
          ),
          listen(
            div0,
            "click",
            /*click_handler*/
            ctx[2]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*searchTerm*/
      1 && input.value !== /*searchTerm*/
      ctx2[0]) {
        set_input_value(
          input,
          /*searchTerm*/
          ctx2[0]
        );
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance68($$self, $$props, $$invalidate) {
  let searchTerm = "";
  function input_input_handler() {
    searchTerm = this.value;
    $$invalidate(0, searchTerm);
  }
  const click_handler = () => {
    $$invalidate(0, searchTerm = "");
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*searchTerm*/
    1) {
      $: {
        hotkeyStore.dispatch({
          type: "UI/SET_SEARCH_TERM",
          payload: { searchTerm }
        });
      }
    }
  };
  return [searchTerm, input_input_handler, click_handler];
}
var Front = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance68, create_fragment70, safe_not_equal, {}, add_css29);
  }
};
var front_default = Front;

// src/stores/hotkeys/derived/number-of-conflicting-hotkeys.ts
var numberOfConflictingHotkeysStore = () => derived(hotkeyStore, (store) => store.numberOfConflictingHotkeys);

// src/view/components/container/controls-bar/modals/hotkeys/number-of-conflicts.svelte
function add_css30(target) {
  append_styles(target, "svelte-st1umc", ".conflicts-indicator.svelte-st1umc{font-size:12px;color:var(--color-red)}");
}
function create_if_block13(ctx) {
  let div;
  let t0;
  let t1;
  let t2_value = (
    /*$numberOfConflictingHotkeys*/
    ctx[0] === 1 ? "" : "s"
  );
  let t2;
  let t3;
  return {
    c() {
      div = element("div");
      t0 = text(
        /*$numberOfConflictingHotkeys*/
        ctx[0]
      );
      t1 = text(" command");
      t2 = text(t2_value);
      t3 = text(" with conflicts");
      attr(div, "class", "conflicts-indicator svelte-st1umc");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t0);
      append(div, t1);
      append(div, t2);
      append(div, t3);
    },
    p(ctx2, dirty) {
      if (dirty & /*$numberOfConflictingHotkeys*/
      1)
        set_data(
          t0,
          /*$numberOfConflictingHotkeys*/
          ctx2[0]
        );
      if (dirty & /*$numberOfConflictingHotkeys*/
      1 && t2_value !== (t2_value = /*$numberOfConflictingHotkeys*/
      ctx2[0] === 1 ? "" : "s"))
        set_data(t2, t2_value);
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
function create_fragment71(ctx) {
  let if_block_anchor;
  let if_block = (
    /*$numberOfConflictingHotkeys*/
    ctx[0] && create_if_block13(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, [dirty]) {
      if (
        /*$numberOfConflictingHotkeys*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block13(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function instance69($$self, $$props, $$invalidate) {
  let $numberOfConflictingHotkeys;
  const numberOfConflictingHotkeys = numberOfConflictingHotkeysStore();
  component_subscribe($$self, numberOfConflictingHotkeys, (value) => $$invalidate(0, $numberOfConflictingHotkeys = value));
  return [$numberOfConflictingHotkeys, numberOfConflictingHotkeys];
}
var Number_of_conflicts = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance69, create_fragment71, safe_not_equal, {}, add_css30);
  }
};
var number_of_conflicts_default = Number_of_conflicts;

// src/view/components/container/controls-bar/modals/hotkeys/hotkeys.svelte
function add_css31(target) {
  append_styles(target, "svelte-nx28bg", ".groups.svelte-nx28bg{min-width:430px;display:flex;flex-direction:column;gap:var(--size-4-2);max-height:70vh;overflow-y:auto}@media(max-width: 720px){.groups.svelte-nx28bg{min-width:unset}}");
}
function get_each_context11(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[1] = list[i][0];
  child_ctx[2] = list[i][1];
  return child_ctx;
}
function create_each_block11(key_1, ctx) {
  let first;
  let group_1;
  let current;
  group_1 = new group_default2({
    props: {
      groupName: (
        /*groupName*/
        ctx[1]
      ),
      group: (
        /*group*/
        ctx[2]
      )
    }
  });
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      create_component(group_1.$$.fragment);
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      mount_component(group_1, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const group_1_changes = {};
      if (dirty & /*$filteredHotkeys*/
      1)
        group_1_changes.groupName = /*groupName*/
        ctx[1];
      if (dirty & /*$filteredHotkeys*/
      1)
        group_1_changes.group = /*group*/
        ctx[2];
      group_1.$set(group_1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(group_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(group_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(first);
      }
      destroy_component(group_1, detaching);
    }
  };
}
function create_fragment72(ctx) {
  let div1;
  let front;
  let t0;
  let div0;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let t1;
  let numberofconflicts;
  let current;
  front = new front_default({});
  let each_value = ensure_array_like(Object.entries(
    /*$filteredHotkeys*/
    ctx[0]
  ));
  const get_key = (ctx2) => (
    /*groupName*/
    ctx2[1]
  );
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context11(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block11(key, child_ctx));
  }
  numberofconflicts = new number_of_conflicts_default({});
  return {
    c() {
      div1 = element("div");
      create_component(front.$$.fragment);
      t0 = space();
      div0 = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t1 = space();
      create_component(numberofconflicts.$$.fragment);
      attr(div0, "class", "groups svelte-nx28bg");
      attr(div1, "class", "lineage-modal");
      attr(div1, "tabindex", "0");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      mount_component(front, div1, null);
      append(div1, t0);
      append(div1, div0);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div0, null);
        }
      }
      append(div1, t1);
      mount_component(numberofconflicts, div1, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (dirty & /*Object, $filteredHotkeys*/
      1) {
        each_value = ensure_array_like(Object.entries(
          /*$filteredHotkeys*/
          ctx2[0]
        ));
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, div0, outro_and_destroy_block, create_each_block11, null, get_each_context11);
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(front.$$.fragment, local);
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      transition_in(numberofconflicts.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(front.$$.fragment, local);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      transition_out(numberofconflicts.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      destroy_component(front);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
      destroy_component(numberofconflicts);
    }
  };
}
function instance70($$self, $$props, $$invalidate) {
  let $filteredHotkeys;
  component_subscribe($$self, filteredHotkeys, ($$value) => $$invalidate(0, $filteredHotkeys = $$value));
  return [$filteredHotkeys];
}
var Hotkeys = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance70, create_fragment72, safe_not_equal, {}, add_css31);
  }
};
var hotkeys_default = Hotkeys;

// src/view/actions/scrolling-axis/scrolling-axis.ts
var import_obsidian22 = require("obsidian");
var scrollingAxis = (element2, { view, pressed }) => {
  const onKeyDown = (e) => {
    if (e.key === " ") {
      const enabled = !isEditing(view);
      if (enabled) {
        pressed.set(enabled);
        hookMouseEvents();
      }
    }
  };
  const onKeyUp = (e) => {
    if (e.key === " ") {
      if (get_store_value(pressed)) {
        pressed.set(false);
        unhookMouseEvents();
      }
    }
  };
  const hookKeyboardEvents = () => {
    const container = view.container;
    invariant(container);
    container.addEventListener("keydown", onKeyDown);
    container.addEventListener("keyup", onKeyUp);
  };
  const unhookKeyboardEvents = () => {
    const container = view.container;
    invariant(container);
    container.removeEventListener("keydown", onKeyDown);
    container.removeEventListener("keyup", onKeyUp);
  };
  let clientX = 0;
  let clientY = 0;
  const dispatch = (0, import_obsidian22.debounce)(() => {
    const container = view.container;
    invariant(container);
    const containerRect = container.getBoundingClientRect();
    view.plugin.settings.dispatch({
      type: "UPDATE_AXIS_OFFSET",
      payload: {
        relativeClientX: (clientX - containerRect.left) / containerRect.width,
        relativeClientY: (clientY - containerRect.top) / containerRect.height
      }
    });
  }, 16);
  const onMouseMove = (e) => {
    clientX = e.clientX;
    clientY = e.clientY;
    dispatch();
  };
  const hookMouseEvents = () => {
    const container = view.container;
    invariant(container);
    container.addEventListener("mousemove", onMouseMove);
    container.style.cursor = "move";
  };
  const unhookMouseEvents = () => {
    const container = view.container;
    invariant(container);
    container.removeEventListener("mousemove", onMouseMove);
    container.style.cursor = "initial";
  };
  setTimeout(hookKeyboardEvents);
  return {
    destroy: () => {
      unhookKeyboardEvents();
      unhookMouseEvents();
    }
  };
};

// src/view/components/container/scrolling-axis/scrolling-axis.svelte
function add_css32(target) {
  append_styles(target, "svelte-159cthp", ".center-indicator.svelte-159cthp{position:absolute;width:100px;height:100px;left:calc(50% - 50px);top:calc(50% - 50px);display:flex;align-items:center;justify-content:center;pointer-events:none}.center-indicator-x.svelte-159cthp{min-width:100%;min-height:2px;background-color:var(--color-base-40);position:absolute}.center-indicator-y.svelte-159cthp{min-height:100%;min-width:2px;background-color:var(--color-base-40);position:absolute}");
}
function create_if_block14(ctx) {
  let div2;
  return {
    c() {
      div2 = element("div");
      div2.innerHTML = `<div class="center-indicator-x svelte-159cthp"></div> <div class="center-indicator-y svelte-159cthp"></div>`;
      attr(div2, "class", "center-indicator svelte-159cthp");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
    }
  };
}
function create_fragment73(ctx) {
  let div0;
  let scrollingAxis_action;
  let t0;
  let div1;
  let div1_class_value;
  let div1_style_value;
  let t1;
  let if_block_anchor;
  let mounted;
  let dispose;
  let if_block = (
    /*$pressed*/
    ctx[0] && create_if_block14(ctx)
  );
  return {
    c() {
      div0 = element("div");
      t0 = space();
      div1 = element("div");
      t1 = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      set_style(div0, "position", "absolute");
      set_style(div0, "right", "0");
      set_style(div0, "bottom", "0");
      set_style(div0, "z-index", "1");
      set_style(div0, "width", "1px");
      set_style(div0, "height", "1px");
      attr(div1, "class", div1_class_value = null_to_empty("scrolling-axis-v " + /*$pressed*/
      (ctx[0] ? "show-axis" : "")) + " svelte-159cthp");
      attr(div1, "style", div1_style_value = `top: ${/*$verticalOffset*/
      ctx[1]}px`);
    },
    m(target, anchor) {
      insert(target, div0, anchor);
      insert(target, t0, anchor);
      insert(target, div1, anchor);
      insert(target, t1, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      if (!mounted) {
        dispose = action_destroyer(scrollingAxis_action = scrollingAxis.call(null, div0, {
          view: (
            /*view*/
            ctx[3]
          ),
          pressed: (
            /*pressed*/
            ctx[2]
          )
        }));
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*$pressed*/
      1 && div1_class_value !== (div1_class_value = null_to_empty("scrolling-axis-v " + /*$pressed*/
      (ctx2[0] ? "show-axis" : "")) + " svelte-159cthp")) {
        attr(div1, "class", div1_class_value);
      }
      if (dirty & /*$verticalOffset*/
      2 && div1_style_value !== (div1_style_value = `top: ${/*$verticalOffset*/
      ctx2[1]}px`)) {
        attr(div1, "style", div1_style_value);
      }
      if (
        /*$pressed*/
        ctx2[0]
      ) {
        if (if_block) {
        } else {
          if_block = create_if_block14(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(div0);
        detach(t0);
        detach(div1);
        detach(t1);
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
      mounted = false;
      dispose();
    }
  };
}
function instance71($$self, $$props, $$invalidate) {
  let $pressed;
  let $verticalOffset;
  const pressed = writable(false);
  component_subscribe($$self, pressed, (value) => $$invalidate(0, $pressed = value));
  const view = getView();
  const verticalOffset = verticalOffsetStore(view);
  component_subscribe($$self, verticalOffset, (value) => $$invalidate(1, $verticalOffset = value));
  return [$pressed, $verticalOffset, pressed, view, verticalOffset];
}
var Scrolling_axis = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance71, create_fragment73, safe_not_equal, {}, add_css32);
  }
};
var scrolling_axis_default = Scrolling_axis;

// src/view/actions/keyboard-shortcuts/helpers/keyboard-events/event-to-string.ts
var eventToString = (event) => {
  let string = event.key.toUpperCase();
  if (event.altKey)
    string += "Alt" /* Alt */;
  if (isMacLike) {
    if (event.ctrlKey)
      string += "Ctrl" /* Ctrl */;
    if (event.metaKey)
      string += "Mod" /* Mod */;
  } else {
    if (event.ctrlKey)
      string += "Mod" /* Mod */;
  }
  if (event.shiftKey)
    string += "Shift" /* Shift */;
  return string;
};

// src/view/actions/on-escape/helpers/handle-escape-key.ts
var handleEscapeKey = (view) => {
  const viewStore = view.viewStore;
  const value = viewStore.getValue();
  const search2 = value.search;
  const controls = value.ui.controls;
  const selection = value.document.selectedNodes;
  if (search2.query) {
    viewStore.dispatch({
      type: "SEARCH/SET_QUERY",
      payload: {
        query: ""
      }
    });
    return true;
  } else if (search2.showInput) {
    viewStore.dispatch({
      type: "SEARCH/TOGGLE_INPUT"
    });
    return true;
  } else if (controls.showHelpSidebar || controls.showHistorySidebar || controls.showSettingsSidebar) {
    viewStore.dispatch({
      type: "CLOSE_MODALS",
      payload: {
        closeAllModals: true
      }
    });
    return true;
  } else if (selection.size > 1) {
    viewStore.dispatch({
      type: "DOCUMENT/CLEAR_SELECTION"
    });
    return true;
  }
};

// src/view/actions/keyboard-shortcuts/keyboard-shortcuts.ts
var keyboardShortcuts = (target, {
  view
}) => {
  const event = "keydown";
  const unsubscribeFromHotkeyStore = hotkeyStore.subscribe(
    (state2, action, initialRun) => {
      if (action?.type === "HOTKEY/UPDATE" || action?.type === "HOTKEY/RESET" || initialRun)
        updateCommandsDictionary(state2.hotkeys);
    }
  );
  const keyboardEventHandler = (event2) => {
    if (!(event2 instanceof KeyboardEvent))
      return;
    if (event2.key === "Escape") {
      const contain = handleEscapeKey(view);
      if (contain)
        return;
    }
    if (event2.target.localName === "input")
      return;
    const command = commandsDictionary.current[eventToString(event2)];
    if (command) {
      if (command.check(view)) {
        try {
          command.callback(view, event2);
        } catch (error) {
          onPluginError(error, "command", command);
        }
      }
    }
  };
  target.addEventListener(event, keyboardEventHandler);
  return {
    destroy: () => {
      unsubscribeFromHotkeyStore();
      target.removeEventListener(event, keyboardEventHandler);
    }
  };
};

// src/view/actions/mouse-wheel-zoom.ts
var mouseWheelZoom = (element2, view) => {
  const listener = (e) => {
    const modKey2 = isMacLike ? e.metaKey : e.ctrlKey;
    if (!modKey2)
      return;
    const delta = e.deltaY;
    view.plugin.settings.dispatch({
      type: "UI/CHANGE_ZOOM_LEVEL",
      payload: {
        direction: delta < 0 ? "in" : "out"
      }
    });
  };
  element2.addEventListener("wheel", listener);
  return {
    destroy: () => {
      element2.removeEventListener("wheel", listener);
    }
  };
};

// src/view/components/container/main.svelte
function add_css33(target) {
  append_styles(target, "svelte-1hu31kw", ".lineage-main.svelte-1hu31kw{--z-index-breadcrumbs:10;background-color:var(--background-container);display:flex;height:100%;width:100%;position:relative}.lineage-main.svelte-1hu31kw:not(:focus-within){& .node-border--active {\n            border-left-color: var(--lineage-accent-faint);\n        };& .node-border--editing {\n            border-left-color: var(--color-base-40);\n        };& .node-border--discard {\n            border-left-color: #e8314660;\n        };& .node-border--selected {\n            border-left-color: var(--lineage-color-selection-faint);\n        }}");
}
function create_if_block_3(ctx) {
  let settings;
  let current;
  settings = new settings_default2({});
  return {
    c() {
      create_component(settings.$$.fragment);
    },
    m(target, anchor) {
      mount_component(settings, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(settings.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(settings.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(settings, detaching);
    }
  };
}
function create_if_block_22(ctx) {
  let hotkeys;
  let current;
  hotkeys = new hotkeys_default({});
  return {
    c() {
      create_component(hotkeys.$$.fragment);
    },
    m(target, anchor) {
      mount_component(hotkeys, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(hotkeys.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(hotkeys.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(hotkeys, detaching);
    }
  };
}
function create_if_block_15(ctx) {
  let filehistory;
  let current;
  filehistory = new file_histoy_default({});
  return {
    c() {
      create_component(filehistory.$$.fragment);
    },
    m(target, anchor) {
      mount_component(filehistory, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(filehistory.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(filehistory.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(filehistory, detaching);
    }
  };
}
function create_if_block15(ctx) {
  let scrollingaxis;
  let current;
  scrollingaxis = new scrolling_axis_default({});
  return {
    c() {
      create_component(scrollingaxis.$$.fragment);
    },
    m(target, anchor) {
      mount_component(scrollingaxis, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(scrollingaxis.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(scrollingaxis.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(scrollingaxis, detaching);
    }
  };
}
function create_fragment74(ctx) {
  let div;
  let container;
  let t0;
  let toolbar;
  let t1;
  let breadcrumbs;
  let t2;
  let controlsbar;
  let t3;
  let current_block_type_index;
  let if_block0;
  let t4;
  let div_class_value;
  let keyboardShortcuts_action;
  let mouseWheelZoom_action;
  let current;
  let mounted;
  let dispose;
  container = new container_default({});
  toolbar = new toolbar_default({});
  breadcrumbs = new breadcrumbs_default({});
  controlsbar = new controls_container_default({});
  const if_block_creators = [create_if_block_15, create_if_block_22, create_if_block_3];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*$controls*/
      ctx2[1].showHistorySidebar
    )
      return 0;
    if (
      /*$controls*/
      ctx2[1].showHelpSidebar
    )
      return 1;
    if (
      /*$controls*/
      ctx2[1].showSettingsSidebar
    )
      return 2;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx, -1))) {
    if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  let if_block1 = (
    /*$scrollingMode*/
    ctx[2] === "fixed-position" && create_if_block15(ctx)
  );
  return {
    c() {
      div = element("div");
      create_component(container.$$.fragment);
      t0 = space();
      create_component(toolbar.$$.fragment);
      t1 = space();
      create_component(breadcrumbs.$$.fragment);
      t2 = space();
      create_component(controlsbar.$$.fragment);
      t3 = space();
      if (if_block0)
        if_block0.c();
      t4 = space();
      if (if_block1)
        if_block1.c();
      attr(div, "class", div_class_value = null_to_empty(`lineage-main`) + " svelte-1hu31kw");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(container, div, null);
      append(div, t0);
      mount_component(toolbar, div, null);
      append(div, t1);
      mount_component(breadcrumbs, div, null);
      append(div, t2);
      mount_component(controlsbar, div, null);
      append(div, t3);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(div, null);
      }
      append(div, t4);
      if (if_block1)
        if_block1.m(div, null);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(keyboardShortcuts_action = keyboardShortcuts.call(null, div, { view: (
            /*view*/
            ctx[0]
          ) })),
          action_destroyer(mouseWheelZoom_action = mouseWheelZoom.call(
            null,
            div,
            /*view*/
            ctx[0]
          ))
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index !== previous_block_index) {
        if (if_block0) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block0 = if_blocks[current_block_type_index];
          if (!if_block0) {
            if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block0.c();
          } else {
          }
          transition_in(if_block0, 1);
          if_block0.m(div, t4);
        } else {
          if_block0 = null;
        }
      }
      if (
        /*$scrollingMode*/
        ctx2[2] === "fixed-position"
      ) {
        if (if_block1) {
          if (dirty & /*$scrollingMode*/
          4) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block15(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div, null);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (keyboardShortcuts_action && is_function(keyboardShortcuts_action.update) && dirty & /*view*/
      1)
        keyboardShortcuts_action.update.call(null, { view: (
          /*view*/
          ctx2[0]
        ) });
      if (mouseWheelZoom_action && is_function(mouseWheelZoom_action.update) && dirty & /*view*/
      1)
        mouseWheelZoom_action.update.call(
          null,
          /*view*/
          ctx2[0]
        );
    },
    i(local) {
      if (current)
        return;
      transition_in(container.$$.fragment, local);
      transition_in(toolbar.$$.fragment, local);
      transition_in(breadcrumbs.$$.fragment, local);
      transition_in(controlsbar.$$.fragment, local);
      transition_in(if_block0);
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(container.$$.fragment, local);
      transition_out(toolbar.$$.fragment, local);
      transition_out(breadcrumbs.$$.fragment, local);
      transition_out(controlsbar.$$.fragment, local);
      transition_out(if_block0);
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(container);
      destroy_component(toolbar);
      destroy_component(breadcrumbs);
      destroy_component(controlsbar);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d();
      }
      if (if_block1)
        if_block1.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance72($$self, $$props, $$invalidate) {
  let $controls;
  let $scrollingMode;
  let { plugin } = $$props;
  let { view } = $$props;
  setContext("plugin", plugin);
  setContext("view", view);
  const controls = uiControlsStore(view);
  component_subscribe($$self, controls, (value) => $$invalidate(1, $controls = value));
  const scrollingMode = scrollingModeStore(view);
  component_subscribe($$self, scrollingMode, (value) => $$invalidate(2, $scrollingMode = value));
  $$self.$$set = ($$props2) => {
    if ("plugin" in $$props2)
      $$invalidate(5, plugin = $$props2.plugin);
    if ("view" in $$props2)
      $$invalidate(0, view = $$props2.view);
  };
  return [view, $controls, $scrollingMode, controls, scrollingMode, plugin];
}
var Main = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance72, create_fragment74, safe_not_equal, { plugin: 5, view: 0 }, add_css33);
  }
};
var main_default = Main;

// src/lib/tree-utils/sort/sort-groups.ts
var sortGroups = (parents, children2) => {
  const parentsIndices = Object.fromEntries(
    parents.map((x) => x.nodes).flat().map((x, i) => [x, i])
  );
  return children2.sort((a, b) => {
    return parentsIndices[a.parentId] - parentsIndices[b.parentId];
  });
};

// src/lib/tree-utils/insert/insert-child.ts
var insertChild = (document2, nodeIdOfParent, newNodeId) => {
  const parentColumnIndex = findNodeColumn(document2.columns, nodeIdOfParent);
  let createdNode = null;
  if (parentColumnIndex === -1) {
    throw new Error("could not find parent column");
  }
  const childColumnIndex = parentColumnIndex + 1;
  createdNode = newNodeId;
  if (document2.columns[childColumnIndex]) {
    const childColumn = document2.columns[childColumnIndex];
    const childGroup = childColumn.groups.find(
      (g) => g.parentId === nodeIdOfParent
    );
    if (childGroup) {
      childGroup.nodes.push(createdNode);
      childGroup.nodes = [...childGroup.nodes];
    } else {
      childColumn.groups.push({
        nodes: [createdNode],
        parentId: nodeIdOfParent
      });
      childColumn.groups = [...childColumn.groups];
    }
    childColumn.groups = sortGroups(
      document2.columns[parentColumnIndex].groups,
      childColumn.groups
    );
  } else {
    document2.columns.push({
      id: id.column(),
      groups: [
        {
          nodes: [createdNode],
          parentId: nodeIdOfParent
        }
      ]
    });
    document2.columns = [...document2.columns];
  }
};

// src/lib/tree-utils/find/find-group-by-node-id.ts
var findGroupByNodeId = (columns, nodeId) => {
  for (const column of columns) {
    for (const group of column.groups) {
      for (const _nodeId of group.nodes) {
        if (_nodeId === nodeId)
          return group;
      }
    }
  }
};
var findGroupByParentId = (columns, parentId) => {
  for (const column of columns) {
    for (const group of column.groups) {
      if (group.parentId === parentId) {
        return { group, column };
      }
    }
  }
};

// src/stores/document/reducers/insert-node/insert-node.ts
var insertNode = (document2, action, newNodeId = id.node()) => {
  const payload = action.payload;
  invariant(payload.activeNodeId);
  if (payload.position === "right") {
    insertChild(document2, payload.activeNodeId, newNodeId);
  } else {
    const columnIndex = findNodeColumn(
      document2.columns,
      payload.activeNodeId
    );
    const column = document2.columns[columnIndex];
    invariant(column);
    const group = findGroupByNodeId([column], payload.activeNodeId);
    invariant(group, "could not find group of " + payload.activeNodeId);
    const groupIndex = group.nodes.findIndex(
      (c) => c === payload.activeNodeId
    );
    const insertionIndex = action.payload.position === "up" ? groupIndex : groupIndex + 1;
    group.nodes.splice(insertionIndex, 0, newNodeId);
    group.nodes = [...group.nodes];
  }
  document2.content[newNodeId] = {
    content: action.payload.content || ""
  };
  return newNodeId;
};

// src/lib/tree-utils/find/find-child-group.ts
var findChildGroup = (columns, node) => {
  for (const column of columns) {
    for (const group of column.groups) {
      if (group.parentId === node) {
        return group;
      }
    }
  }
};

// src/lib/tree-utils/move/move-node-as-child.ts
var moveNodeAsChild = (document2, node, targetNode) => {
  const targetGroup = findChildGroup(document2.columns, targetNode);
  if (targetGroup) {
    targetGroup.nodes.push(node);
    targetGroup.nodes = [...targetGroup.nodes];
  } else {
    const currentColumnIndex = findNodeColumn(document2.columns, targetNode);
    let targetColumn;
    targetColumn = document2.columns[currentColumnIndex + 1];
    if (!targetColumn) {
      const newColumn = createColumn();
      document2.columns.push(newColumn);
      document2.columns = [...document2.columns];
      targetColumn = newColumn;
    }
    const newGroup = createGroup(targetNode);
    newGroup.nodes.push(node);
    targetColumn.groups.push(newGroup);
    targetColumn.groups = [...targetColumn.groups];
  }
};

// src/lib/tree-utils/move/move-node-as-sibling.ts
var moveNodeAsSibling = (columns, direction, node, targetNode, adjacentGroup) => {
  const targetGroup = findGroupByNodeId(columns, targetNode);
  if (targetGroup) {
    let insertionIndex;
    if (adjacentGroup && adjacentGroup.parentId !== targetGroup.parentId) {
      if (direction === "down") {
        targetGroup.nodes.splice(0, 0, node);
        targetGroup.nodes = [...targetGroup.nodes];
      } else if (direction === "up") {
        targetGroup.nodes.push(node);
        targetGroup.nodes = [...targetGroup.nodes];
      }
    } else {
      direction = direction === "left" ? "down" : direction;
      const index = targetGroup.nodes.findIndex((n) => n === targetNode);
      insertionIndex = direction === "up" ? index : index + 1;
      targetGroup.nodes.splice(insertionIndex, 0, node);
      targetGroup.nodes = [...targetGroup.nodes];
    }
  }
};

// src/lib/tree-utils/move/move-child-groups-next-to-their-parent.ts
var moveChildGroupsNextToTheirParent = (document2, parentNode) => {
  const sortedChildGroups = getSortedChildGroups(
    document2.columns,
    parentNode,
    true
  );
  const parentColumnIndex = findNodeColumn(document2.columns, parentNode);
  for (let i = 0; i < sortedChildGroups.length; i++) {
    const groups = sortedChildGroups[i];
    for (const group of groups) {
      const targetColumnIndex = parentColumnIndex + 1 + i;
      if (!document2.columns[targetColumnIndex]) {
        document2.columns.push({
          id: id.column(),
          groups: []
        });
        document2.columns = [...document2.columns];
      }
      document2.columns[targetColumnIndex].groups.push(group);
      document2.columns[targetColumnIndex].groups = [
        ...document2.columns[targetColumnIndex].groups
      ];
    }
  }
};

// src/lib/tree-utils/move/change-node-position.ts
var changeNodePosition = (document2, node, targetNode, direction, type) => {
  const group = findGroupByNodeId(document2.columns, node);
  invariant(group);
  deleteNodeById(document2.columns, null, node);
  if (direction === "right") {
    moveNodeAsChild(document2, node, targetNode);
  } else {
    moveNodeAsSibling(
      document2.columns,
      direction,
      node,
      targetNode,
      type === "move" && direction !== "left" ? group : void 0
    );
  }
  moveChildGroupsNextToTheirParent(document2, node);
};

// src/lib/tree-utils/sort/clean-and-sort-columns.ts
var cleanAndSortColumns = (document2) => {
  const emptyColumns = /* @__PURE__ */ new Set();
  for (let i = 1; i < document2.columns.length; i++) {
    const column = document2.columns[i];
    column.groups = column.groups.filter((g) => g.nodes.length > 0);
    if (column.groups.length === 0) {
      emptyColumns.add(column.id);
    }
  }
  for (const emptyColumn of emptyColumns) {
    const i = document2.columns.findIndex((c) => c.id === emptyColumn);
    if (i > 0) {
      document2.columns.splice(i, 1);
      document2.columns = [...document2.columns];
    }
  }
  for (let i = 1; i < document2.columns.length; i++) {
    const column = document2.columns[i];
    if (column.groups.length) {
      const previousColumn = document2.columns[i - 1];
      if (column.groups.length > 0) {
        column.groups = sortGroups(
          previousColumn.groups,
          column.groups
        );
      }
    }
  }
};

// src/stores/document/reducers/drop-node/drop-node.ts
var dropNode = (document2, action) => {
  const droppedNode = action.payload.droppedNodeId;
  const targetNode = action.payload.targetNodeId;
  invariant(droppedNode);
  invariant(targetNode);
  changeNodePosition(
    document2,
    droppedNode,
    targetNode,
    action.payload.position,
    "drop"
  );
  cleanAndSortColumns(document2);
};

// src/lib/data-conversion/json-to-columns.ts
var groupsCache = {};
var findGroup2 = (column, parentId) => {
  if (!groupsCache[parentId]) {
    groupsCache[parentId] = column.groups.find(
      (g) => g.parentId === parentId
    );
  }
  return groupsCache[parentId];
};
var jsonToColumns = (tree, parentId = id.rootNode(), columns = [], content = {}, level2 = 0) => {
  for (const treeNode of tree) {
    const node = id.node();
    content[node] = {
      content: treeNode.content
    };
    if (!columns[level2]) {
      columns.push(createColumn());
    }
    const column = columns[level2];
    let group;
    group = findGroup2(column, parentId);
    if (!group) {
      group = createGroup(parentId);
      column.groups.push(group);
    }
    group.nodes.push(node);
    if (treeNode.children.length > 0) {
      jsonToColumns(treeNode.children, node, columns, content, level2 + 1);
    }
  }
  return { content, columns };
};

// src/lib/tree-utils/insert/insert-first-node.ts
var insertFirstNode = (columns, content) => {
  if (columns.length === 0) {
    const rootId = id.rootNode();
    const createdNode = id.node();
    content[createdNode] = { content: "" };
    columns.push({
      id: id.column(),
      groups: [
        {
          parentId: rootId,
          nodes: [createdNode]
        }
      ]
    });
  }
};

// src/stores/document/reducers/load-document-from-file/load-document-from-file.ts
var loadDocumentFromFile = (state2, action) => {
  const tree = action.payload.format === "outline" ? outlineToJson(action.payload.document.data) : sectionsToJson(action.payload.document.data);
  const document2 = jsonToColumns(tree);
  state2.document.columns = document2.columns;
  state2.document.content = document2.content;
  const emptyTree = tree.length === 0;
  if (emptyTree) {
    insertFirstNode(state2.document.columns, state2.document.content);
  }
  if (action.type === "DOCUMENT/LOAD_FILE")
    state2.file.frontmatter = action.payload.document.frontmatter;
  const activeNode = state2.document.columns[0].groups[0].nodes[0];
  invariant(activeNode);
  return activeNode;
};

// src/stores/document/reducers/content/set-node-content.ts
var setNodeContent = (content, action) => {
  const nodeContent = content[action.payload.nodeId];
  const contentString = nodeContent?.content || "";
  if (contentString === action.payload.content)
    throw new SilentError("identical content");
  const nodeId = action.payload.nodeId;
  if (!nodeContent)
    content[nodeId] = { content: action.payload.content };
  else
    nodeContent.content = action.payload.content;
};

// src/lib/tree-utils/delete/delete-groups-by-parent-id.ts
var deleteGroupsByParentId = (columns, content, parentIds) => {
  for (const column of columns) {
    const groups = [];
    for (const group of column.groups) {
      if (parentIds.has(group.parentId)) {
        for (const node of group.nodes) {
          delete content[node];
        }
      } else {
        groups.push(group);
      }
    }
    column.groups = groups;
  }
};

// src/lib/tree-utils/delete/delete-child-nodes.ts
var deleteChildNodes = (document2, node) => {
  const childGroups = [];
  traverseDown(childGroups, document2.columns, node);
  if (childGroups.length > 0)
    deleteGroupsByParentId(
      document2.columns,
      document2.content,
      new Set(childGroups)
    );
};

// src/lib/tree-utils/assert/is-last-root-node.ts
var isLastRootNode = (columns, node) => {
  const column = columns[0];
  if (node && column.groups.length === 1) {
    const group = column.groups[0];
    if (group.nodes.length === 1 && group.nodes[0] === node)
      return true;
  }
  return false;
};

// src/lib/tree-utils/find/find-next-node-after-deletion.ts
var findNextNodeAfterDeletion = (columns, node) => {
  let nextNode = null;
  const group = findGroupByNodeId(columns, node);
  const columnIndex = findNodeColumn(columns, node);
  const column = columns[columnIndex];
  if (group) {
    const nodeIndex = group.nodes.findIndex((n) => n === node);
    if (nodeIndex === 0)
      nextNode = group.nodes[1];
    else if (nodeIndex > 0)
      nextNode = group.nodes[nodeIndex - 1];
    else
      nextNode = group.nodes[group.nodes.length - 1];
  }
  if (!nextNode) {
    if (group && columnIndex > 0)
      nextNode = group?.parentId;
    else
      nextNode = column.groups[0].nodes[0];
  }
  return nextNode;
};

// src/lib/tree-utils/find/find-node-to-jump-to.ts
var findNodeToJumpTo = (columns, node, target) => {
  const columnIndex = findNodeColumn(columns, node);
  const column = columns[columnIndex];
  if (target === "start-of-column") {
    return column.groups[0].nodes[0];
  } else if (target === "end-of-column") {
    const nodeGroup = column.groups[column.groups.length - 1];
    return nodeGroup.nodes[nodeGroup.nodes.length - 1];
  } else {
    const group = column.groups.find((g) => g.nodes.includes(node));
    if (group) {
      if (target === "start-of-group")
        return group.nodes[0];
      else if (target === "end-of-group") {
        return group.nodes[group.nodes.length - 1];
      }
    }
  }
};

// src/lib/tree-utils/find/find-next-active-node.ts
var findNextActiveNode = (columns, node, action) => {
  if (action.type === "DOCUMENT/DELETE_NODE") {
    return findNextNodeAfterDeletion(columns, node);
  } else if (action.type === "DOCUMENT/JUMP_TO_NODE") {
    return findNodeToJumpTo(columns, node, action.payload.target);
  }
};

// src/stores/document/reducers/delete-node/delete-node.ts
var deleteNode = (document2, nodeId, selectedNodes) => {
  invariant(nodeId);
  const isSelection = selectedNodes && selectedNodes.size > 1;
  const nodes = isSelection ? [...selectedNodes] : [nodeId];
  let nextNode = void 0;
  for (const nodeId2 of nodes) {
    const lastNode = isLastRootNode(document2.columns, nodeId2);
    if (lastNode) {
      if (isSelection)
        break;
      else
        throw new Error(lang.error_delete_last_node);
    }
    nextNode = findNextActiveNode(document2.columns, nodeId2, {
      type: "DOCUMENT/DELETE_NODE",
      payload: {
        activeNodeId: nodeId2
      }
    });
    invariant(nextNode);
    deleteChildNodes(document2, nodeId2);
    deleteNodeById(document2.columns, document2.content, nodeId2);
    cleanAndSortColumns(document2);
  }
  invariant(nextNode);
  return nextNode;
};

// src/lib/tree-utils/find/find-adjacent-sibling-node.ts
var findAdjacentSiblingNode = (columns, node, direction) => {
  const columnIndex = findNodeColumn(columns, node);
  const column = columns[columnIndex];
  const flatColumn = column.groups.map((g) => g.nodes).flat();
  const nodeIndex = flatColumn.findIndex((n) => n === node);
  return flatColumn[nodeIndex + (direction === "up" ? -1 : 1)];
};

// src/lib/tree-utils/find/find-adjacent-node.ts
var findAdjacentNode = (columns, activeNodeId, direction) => {
  let targetNode = null;
  const nodeToMove = activeNodeId;
  if (direction === "left") {
    const group = findGroupByNodeId(columns, nodeToMove);
    if (group && !group.parentId.startsWith("r"))
      targetNode = group.parentId;
  } else {
    targetNode = findAdjacentSiblingNode(
      columns,
      nodeToMove,
      direction === "right" ? "up" : direction
    );
  }
  if (!targetNode && direction === "right") {
    const columnIndex = findNodeColumn(columns, nodeToMove);
    const isFirstNodeOfColumn = columns[columnIndex].groups[0]?.nodes[0] === nodeToMove;
    if (isFirstNodeOfColumn) {
      targetNode = findAdjacentSiblingNode(columns, nodeToMove, "down");
    }
  }
  return targetNode;
};

// src/lib/tree-utils/find/find-adjacent-node-of-selection.ts
var findAdjacentNodeOfSelection = (document2, activeNodeId, selectedNodes, direction) => {
  const searchColumns = clone(document2.columns);
  if (selectedNodes && selectedNodes.size > 1) {
    const column = searchColumns[findNodeColumn(searchColumns, activeNodeId)];
    invariant(column);
    for (const group of column.groups) {
      group.nodes = group.nodes.filter(
        (n) => n === activeNodeId || !selectedNodes?.has(n)
      );
    }
  }
  return findAdjacentNode(searchColumns, activeNodeId, direction);
};

// src/stores/document/reducers/move-node/move-node.ts
var moveNode2 = (document2, action) => {
  const selectedNodes = action.payload.selectedNodes;
  const isSelection = selectedNodes && selectedNodes.size > 1;
  const nodes = isSelection ? [...selectedNodes] : [action.payload.activeNodeId];
  const shouldReverseOrder = isSelection && (action.payload.direction === "down" || action.payload.direction === "left");
  if (shouldReverseOrder)
    nodes.reverse();
  invariant(action.payload.activeNodeId);
  const targetNode = isSelection ? findAdjacentNodeOfSelection(
    document2,
    action.payload.activeNodeId,
    selectedNodes,
    action.payload.direction
  ) : findAdjacentNode(
    document2.columns,
    action.payload.activeNodeId,
    action.payload.direction
  );
  if (!targetNode)
    throw new SilentError("could not find adjacent node");
  for (const nodeToMove of nodes) {
    changeNodePosition(
      document2,
      nodeToMove,
      targetNode,
      action.payload.direction,
      "move"
    );
    cleanAndSortColumns(document2);
  }
};

// src/lib/tree-utils/move/move-orphan-groups-to-a-new-parent.ts
var moveOrphanGroupsToANewParent = (document2, currentParentNode, newParentNode, direction) => {
  const groupOfMergedNode = findGroupByParentId(
    document2.columns,
    currentParentNode
  );
  if (!groupOfMergedNode)
    return;
  groupOfMergedNode.column.groups = groupOfMergedNode.column.groups.filter(
    (g) => g.parentId !== groupOfMergedNode.group.parentId
  );
  const parentColumnIndex = findNodeColumn(document2.columns, newParentNode);
  const targetColumnIndex = parentColumnIndex + 1;
  const existingGroupOfNewParent = findGroupByParentId(
    document2.columns,
    newParentNode
  );
  if (existingGroupOfNewParent) {
    if (direction === "up")
      existingGroupOfNewParent.group.nodes = [
        ...existingGroupOfNewParent.group.nodes,
        ...groupOfMergedNode.group.nodes
      ];
    else {
      existingGroupOfNewParent.group.nodes = [
        ...groupOfMergedNode.group.nodes,
        ...existingGroupOfNewParent.group.nodes
      ];
    }
  } else {
    if (!document2.columns[targetColumnIndex]) {
      document2.columns.push({
        id: id.column(),
        groups: []
      });
      document2.columns = [...document2.columns];
    }
    groupOfMergedNode.group.parentId = newParentNode;
    document2.columns[targetColumnIndex].groups.push(
      groupOfMergedNode.group
    );
    document2.columns[targetColumnIndex].groups = [
      ...document2.columns[targetColumnIndex].groups
    ];
  }
};

// src/stores/document/reducers/merge-node/merge-node.ts
var mergeNode2 = (document2, action) => {
  const mergedNode = action.payload.activeNodeId;
  const adjacentNode = findAdjacentSiblingNode(
    document2.columns,
    mergedNode,
    action.payload.direction
  );
  invariant(mergedNode, "merged node is undefined");
  if (!adjacentNode)
    throw new SilentError("could not find adjacent node");
  const mergedNodeContent = document2.content[mergedNode] || { content: "" };
  const adjacentNodeContent = document2.content[adjacentNode] || {
    content: ""
  };
  let newContent = "";
  if (action.payload.direction === "up") {
    newContent = (adjacentNodeContent.content + "\n" + mergedNodeContent.content).trim();
  } else if (action.payload.direction === "down") {
    newContent = (mergedNodeContent.content + "\n" + adjacentNodeContent.content).trim();
  }
  if (newContent) {
    const adjacentNodeContentObject = document2.content[adjacentNode];
    if (adjacentNodeContentObject) {
      adjacentNodeContentObject.content = newContent;
    } else {
      document2.content[adjacentNode] = { content: newContent };
    }
  }
  moveOrphanGroupsToANewParent(
    document2,
    mergedNode,
    adjacentNode,
    action.payload.direction
  );
  deleteNodeById(document2.columns, document2.content, mergedNode);
  cleanAndSortColumns(document2);
  return adjacentNode;
};

// src/stores/document/reducers/history/helpers/update-navigation-state.ts
var updateNavigationState = (document2) => {
  const activeIndex = document2.state.activeIndex;
  document2.state.canGoBack = activeIndex > 0;
  document2.state.canGoForward = activeIndex < document2.items.length - 1;
};

// src/stores/document/reducers/history/helpers/create-snapshot.ts
var createSnapshot = (document2, context) => {
  return {
    data: {
      columns: JSON.stringify(document2.columns),
      content: JSON.stringify(document2.content)
    },
    context,
    created: Date.now(),
    id: id.snapshot()
  };
};

// src/stores/document/reducers/history/helpers/remove-old-history-items.ts
var removeOldHistoryItems = (history, MAX_ITEMS) => {
  if (history.items.length >= MAX_ITEMS) {
    const numSnapshotsToRemove = history.items.length - MAX_ITEMS + 1;
    history.items.splice(0, numSnapshotsToRemove);
    const activeItem = history.items[history.state.activeIndex];
    history.state.activeIndex = history.items.findIndex(
      (item) => item === activeItem
    );
  }
};

// src/stores/document/reducers/history/helpers/remove-obsolete-history-items.ts
var removeObsoleteHistoryItems = (history) => {
  if (history.items.length > 0 && history.state.activeIndex !== history.items.length - 1) {
    history.items.splice(history.state.activeIndex + 1);
  }
};

// src/stores/document/reducers/history/add-snapshot.ts
var addSnapshot = (document2, history, context) => {
  const items = history.items;
  const activeIndex = history.state.activeIndex;
  const activeSnapshot = items[activeIndex];
  removeObsoleteHistoryItems(history);
  removeOldHistoryItems(history, 50);
  if (activeSnapshot && context.action.type === "DOCUMENT/LOAD_FILE") {
    const snapshotContent = JSON.stringify(
      Object.values(JSON.parse(activeSnapshot.data.content))
    );
    const documentContent = JSON.stringify(Object.values(document2.content));
    if (snapshotContent === documentContent) {
      history.items.splice(history.state.activeIndex, 1);
    }
  }
  const snapshot = createSnapshot(document2, context);
  items.push(snapshot);
  history.state.activeIndex = items.length - 1;
  history.context.activeSection = context.newActiveSection;
  updateNavigationState(history);
};

// src/stores/document/reducers/history/helpers/find-snapshot-index.ts
var findSnapshotIndex = (snapshots, id2) => {
  if (!id2)
    return -1;
  return snapshots.findIndex((snapshot) => snapshot.id === id2);
};

// src/stores/document/reducers/history/helpers/load-document-from-snapshot.ts
var loadDocumentFromSnapshot = (document2, snapshot, history) => {
  history.context.activeSection = snapshot.context.newActiveSection;
  document2.content = JSON.parse(snapshot.data.content);
  document2.columns = JSON.parse(snapshot.data.columns);
};

// src/stores/document/reducers/history/select-snapshot.ts
var selectSnapshot = (document2, history, action) => {
  const index = findSnapshotIndex(history.items, action.payload.snapshotId);
  if (index !== -1) {
    history.state.activeIndex = index;
    updateNavigationState(history);
    const snapshot = history.items[index];
    loadDocumentFromSnapshot(document2, snapshot, history);
  }
};

// src/stores/document/reducers/history/undo-action.ts
var undoAction = (document2, history) => {
  const currentIndex = history.state.activeIndex;
  const newIndex = currentIndex - 1;
  const snapshot = history.items[newIndex];
  if (!snapshot)
    return;
  history.state.activeIndex = newIndex;
  updateNavigationState(history);
  loadDocumentFromSnapshot(document2, snapshot, history);
};

// src/stores/view/helpers/get-document-event-type.ts
var contentEvents = /* @__PURE__ */ new Set([
  "DOCUMENT/SET_NODE_CONTENT",
  "DOCUMENT/FORMAT_HEADINGS"
]);
var createAndDelete = /* @__PURE__ */ new Set([
  "DOCUMENT/INSERT_NODE",
  "DOCUMENT/DELETE_NODE",
  "DOCUMENT/MERGE_NODE",
  "DOCUMENT/LOAD_FILE",
  "DOCUMENT/EXTRACT_BRANCH",
  "DOCUMENT/SPLIT_NODE"
]);
var dropAndMoveEvents = /* @__PURE__ */ new Set([
  "DOCUMENT/DROP_NODE",
  "DOCUMENT/MOVE_NODE"
]);
var historyEvents = /* @__PURE__ */ new Set([
  "HISTORY/APPLY_NEXT_SNAPSHOT",
  "HISTORY/APPLY_PREVIOUS_SNAPSHOT",
  "HISTORY/SELECT_SNAPSHOT"
]);
var clipboardEvents = /* @__PURE__ */ new Set([
  "DOCUMENT/PASTE_NODE",
  "DOCUMENT/CUT_NODE"
]);
var cachedResults = {};
var getDocumentEventType = (type) => {
  if (cachedResults[type]) {
    return cachedResults[type];
  }
  let result = null;
  if (contentEvents.has(type))
    result = { content: true };
  else if (createAndDelete.has(type))
    result = { createOrDelete: true };
  else if (dropAndMoveEvents.has(type))
    result = { dropOrMove: true };
  else if (historyEvents.has(type))
    result = { changeHistory: true };
  else if (clipboardEvents.has(type))
    result = { clipboard: true };
  if (!result)
    result = {};
  cachedResults[type] = result;
  return result;
};

// src/stores/document/reducers/history/redo-action.ts
var redoAction = (document2, history) => {
  const currentIndex = history.state.activeIndex;
  const nexIndex = currentIndex + 1;
  const snapshot = history.items[nexIndex];
  if (!snapshot)
    return;
  history.state.activeIndex = nexIndex;
  updateNavigationState(history);
  loadDocumentFromSnapshot(document2, snapshot, history);
};

// src/stores/document/default-document-state.ts
var defaultDocumentState = () => ({
  document: {
    columns: [],
    content: {}
  },
  sections: {
    id_section: {},
    section_id: {}
  },
  file: {
    path: null,
    frontmatter: ""
  },
  history: {
    items: [],
    state: {
      activeIndex: -1,
      canGoBack: false,
      canGoForward: false
    },
    context: {
      activeSection: ""
    }
  }
});

// src/stores/document/reducers/content/format-content/helpers/format-headings.ts
var formatHeadings = (content, treeIndexDict) => {
  for (const nodeId in content) {
    const currentContent = content[nodeId]?.content;
    if (!currentContent)
      continue;
    const sectionNumber = treeIndexDict[nodeId];
    if (!sectionNumber)
      continue;
    const depth = sectionNumber.split(".").length;
    const symbol = `${"#".repeat(Math.min(depth, 6))} `;
    const lines = currentContent.split("\n");
    const updatedLines = lines.map((line) => {
      const match = /^#+ /.exec(line);
      if (match) {
        return line.replace(match[0], symbol);
      }
      return line;
    });
    content[nodeId] = {
      content: updatedLines.join("\n")
    };
  }
};

// src/stores/document/reducers/content/format-content/format-headings.ts
var formatHeadings2 = (content, sections) => {
  formatHeadings(content, sections.id_section);
};

// src/stores/document/reducers/clipboard/paste-node/helpers/past-child-groups.ts
var pastChildGroups = (document2, branch) => {
  const parentColumnIndex = findNodeColumn(document2.columns, branch.nodeId);
  if (parentColumnIndex === -1)
    throw new Error("could not find cut node");
  for (let i = 0; i < branch.sortedChildGroups.length; i++) {
    const groups = branch.sortedChildGroups[i];
    for (const group of groups) {
      const targetColumnIndex = parentColumnIndex + 1 + i;
      if (!document2.columns[targetColumnIndex]) {
        document2.columns.push({
          id: id.column(),
          groups: []
        });
        document2.columns = [...document2.columns];
      }
      for (const node of group.nodes) {
        if (node in branch.content) {
          document2.content[node] = branch.content[node];
        }
      }
      document2.columns[targetColumnIndex].groups.push(group);
      document2.columns[targetColumnIndex].groups = [
        ...document2.columns[targetColumnIndex].groups
      ];
    }
  }
};

// src/lib/format-detection/has-n-sections.ts
var hasNSections = (input, n = 2) => {
  const lines = input.split("\n");
  let count = 0;
  for (const line of lines) {
    if (parseDelimiter(line)) {
      count++;
      if (count >= n)
        return true;
    }
  }
  return false;
};

// src/lib/format-detection/has-n-bullet-list-items.ts
var hasNBulletListItems = (input, n = 2) => {
  const lines = input.split("\n");
  let count = 0;
  for (const line of lines) {
    if (/^(\t*)- (.+)/.test(line)) {
      count++;
      if (count >= n)
        return true;
    }
  }
  return false;
};

// src/lib/format-detection/detect-document-format.ts
var detectDocumentFormat = (text2, strict = true) => {
  const { data } = extractFrontmatter(text2);
  if (hasNSections(data, 1))
    return "sections";
  if (isOutline(data))
    return "outline";
  if (!strict) {
    if (hasNBulletListItems(text2, 1))
      return "outline";
  }
};

// src/stores/document/reducers/clipboard/paste-node/helpers/text-to-branches.ts
var textToBranches = (text2) => {
  const detectedFormat = detectDocumentFormat(text2, false);
  const tree = detectedFormat === "outline" ? outlineToJson(text2) : sectionsToJson(text2);
  const document2 = jsonToColumns(tree);
  const branches = [];
  for (const nodeId of document2.columns[0].groups[0].nodes) {
    const branch = getBranch(
      document2.columns,
      document2.content,
      nodeId,
      "copy"
    );
    branches.push(branch);
  }
  return branches;
};

// src/stores/document/reducers/clipboard/paste-node/paste-node.ts
var pasteNode2 = (document2, action) => {
  const branches = textToBranches(action.payload.text);
  const nextNode = branches[branches.length - 1].nodeId;
  const targetNode = action.payload.targetNodeId;
  const position = action.payload.position || "down";
  for (const branch of branches.reverse()) {
    insertNode(
      document2,
      {
        payload: {
          activeNodeId: targetNode,
          position,
          content: branch.content[branch.nodeId]?.content
        }
      },
      branch.nodeId
    );
    pastChildGroups(document2, branch);
  }
  cleanAndSortColumns(document2);
  invariant(nextNode);
  return nextNode;
};

// src/stores/view/subscriptions/helpers/calculate-tree-index.ts
var calculateColumnTreeIndexes = (columns) => {
  const sections = { id_section: {}, section_id: {} };
  if (columns.length === 0)
    return sections;
  for (let nI = 0; nI < columns[0].groups[0].nodes.length; nI++) {
    const node = columns[0].groups[0].nodes[nI];
    const section = String(nI + 1);
    sections.id_section[node] = section;
    sections.section_id[section] = node;
  }
  for (let cI = 1; cI < columns.length; cI++) {
    const column = columns[cI];
    for (let gI = 0; gI < column.groups.length; gI++) {
      const group = column.groups[gI];
      for (let nI = 0; nI < group.nodes.length; nI++) {
        const node = group.nodes[nI];
        const section = sections.id_section[group.parentId] + "." + (nI + 1);
        sections.id_section[node] = section;
        sections.section_id[section] = node;
      }
    }
  }
  return sections;
};

// src/stores/document/reducers/state/update-sections-dictionary.ts
var updateSectionsDictionary = (state2) => {
  state2.sections = calculateColumnTreeIndexes(state2.document.columns);
};

// src/stores/view/subscriptions/helpers/get-id-of-section.ts
var getIdOfSection = (sections, section) => {
  const id2 = sections.section_id[section];
  invariant(id2);
  return id2;
};

// src/stores/document/reducers/extract-node/extract-node.ts
var extractNode = (document2, action) => {
  invariant(action.payload.nodeId);
  invariant(action.payload.documentName);
  deleteChildNodes(document2, action.payload.nodeId);
  cleanAndSortColumns(document2);
  setNodeContent(document2.content, {
    payload: {
      nodeId: action.payload.nodeId,
      content: `[[${action.payload.documentName}]]`
    }
  });
};

// src/stores/view/subscriptions/helpers/get-section-of-id.ts
var getSectionOfId = (sections, nodeId) => {
  const section = sections.id_section[nodeId];
  invariant(section);
  return section;
};

// src/stores/document/reducers/split-node/split-node.ts
var splitNode = (document2, action) => {
  const targetNode = action.payload.target;
  const content = document2.content[targetNode];
  if (!content?.content)
    throw new SilentError("empty node");
  const sections = splitText(content?.content, action.payload.mode);
  if (sections === content.content)
    throw new Error(lang.cant_split_card_identical);
  const childGroup = findChildGroup(document2.columns, targetNode);
  if (childGroup)
    throw new Error(lang.cant_split_card_that_has_children);
  const newActiveNode = pasteNode2(document2, {
    payload: {
      position: "down",
      targetNodeId: targetNode,
      text: sections
    }
  });
  deleteNode(document2, targetNode);
  return newActiveNode;
};

// src/stores/document/document-reducer.ts
var updateDocumentState = (state2, action) => {
  let newActiveNodeId = null;
  let affectedNodeId = null;
  let affectedNodeContent = null;
  if (action.type === "DOCUMENT/SET_NODE_CONTENT") {
    setNodeContent(state2.document.content, action);
    newActiveNodeId = action.payload.nodeId;
  } else if (action.type === "DOCUMENT/INSERT_NODE") {
    newActiveNodeId = insertNode(state2.document, action);
  } else if (action.type === "DOCUMENT/DELETE_NODE") {
    affectedNodeContent = state2.document.content[action.payload.activeNodeId];
    newActiveNodeId = deleteNode(
      state2.document,
      action.payload.activeNodeId,
      action.payload.selectedNodes
    );
    affectedNodeId = action.payload.activeNodeId;
  } else if (action.type === "DOCUMENT/EXTRACT_BRANCH") {
    affectedNodeContent = state2.document.content[action.payload.nodeId];
    extractNode(state2.document, action);
    newActiveNodeId = action.payload.nodeId;
  } else if (action.type === "DOCUMENT/SPLIT_NODE") {
    affectedNodeId = action.payload.target;
    affectedNodeContent = state2.document.content[affectedNodeId];
    newActiveNodeId = splitNode(state2.document, action);
  } else if (action.type === "DOCUMENT/DROP_NODE") {
    dropNode(state2.document, action);
    newActiveNodeId = action.payload.droppedNodeId;
  } else if (action.type === "DOCUMENT/MOVE_NODE") {
    moveNode2(state2.document, action);
    newActiveNodeId = action.payload.activeNodeId;
    affectedNodeId = newActiveNodeId;
  } else if (action.type === "DOCUMENT/MERGE_NODE") {
    affectedNodeContent = state2.document.content[action.payload.activeNodeId];
    newActiveNodeId = mergeNode2(state2.document, action);
    affectedNodeId = action.payload.activeNodeId;
  } else if (action.type === "DOCUMENT/LOAD_FILE") {
    newActiveNodeId = loadDocumentFromFile(state2, action);
  } else if (action.type === "RESET_STORE") {
    const newState = defaultDocumentState();
    state2.document = newState.document;
    state2.history = newState.history;
    state2.file = newState.file;
  } else if (action.type === "HISTORY/SELECT_SNAPSHOT") {
    selectSnapshot(state2.document, state2.history, action);
    state2.history = { ...state2.history };
  } else if (action.type === "HISTORY/APPLY_PREVIOUS_SNAPSHOT") {
    undoAction(state2.document, state2.history);
    state2.history = { ...state2.history };
  } else if (action.type === "HISTORY/APPLY_NEXT_SNAPSHOT") {
    redoAction(state2.document, state2.history);
    state2.history = { ...state2.history };
  } else if (action.type === "FS/SET_FILE_PATH") {
    state2.file.path = action.payload.path;
  } else if (action.type === "DOCUMENT/FORMAT_HEADINGS") {
    formatHeadings2(state2.document.content, state2.sections);
    newActiveNodeId = getIdOfSection(
      state2.sections,
      state2.history.context.activeSection
    );
  } else if (action.type === "DOCUMENT/PASTE_NODE") {
    newActiveNodeId = pasteNode2(state2.document, action);
  } else if (action.type === "DOCUMENT/CUT_NODE") {
    affectedNodeContent = state2.document.content[action.payload.nodeId];
    newActiveNodeId = deleteNode(
      state2.document,
      action.payload.nodeId,
      action.payload.selectedNodes
    );
    affectedNodeId = action.payload.nodeId;
  } else if (action.type === "FILE/UPDATE_FRONTMATTER") {
    state2.file.frontmatter = action.payload.frontmatter;
    return;
  }
  const e = getDocumentEventType(action.type);
  let affectedSection = null;
  if (affectedNodeId) {
    affectedSection = getSectionOfId(state2.sections, affectedNodeId);
  }
  if (e.dropOrMove || e.createOrDelete || e.changeHistory || e.clipboard) {
    updateSectionsDictionary(state2);
  }
  if (action.type === "DOCUMENT/LOAD_FILE") {
    const activeSection = action.payload.activeSection;
    if (activeSection) {
      const id2 = state2.sections.section_id[activeSection];
      if (id2) {
        newActiveNodeId = id2;
      }
    }
  }
  const contentShapeCreation = e.content || e.dropOrMove || e.createOrDelete;
  if (newActiveNodeId && (contentShapeCreation || e.clipboard)) {
    const newActiveSection = getSectionOfId(
      state2.sections,
      newActiveNodeId
    );
    affectedNodeId = affectedNodeId || newActiveNodeId;
    affectedNodeContent = affectedNodeContent || state2.document.content[affectedNodeId];
    const context = {
      numberOfSections: Object.keys(state2.document.content).length,
      affectedSection: affectedSection || newActiveSection,
      newActiveSection,
      action,
      contentOfAffectedSection: affectedNodeContent?.content?.substring(0, 300) || "",
      numberOfCharacters: Object.values(state2.document.content).map((x) => x.content.length).reduce((acc, v) => acc + v)
    };
    addSnapshot(state2.document, state2.history, context);
    state2.history = { ...state2.history };
  }
};
var documentReducer = (store, action) => {
  updateDocumentState(store, action);
  return store;
};

// src/stores/view/default-view-state.ts
var defaultViewState = () => ({
  search: {
    query: "",
    results: /* @__PURE__ */ new Set(),
    searching: false,
    showInput: false,
    fuzzySearch: false
  },
  ui: {
    controls: {
      showHistorySidebar: false,
      showHelpSidebar: false,
      showSettingsSidebar: false
    }
  },
  document: {
    editing: {
      activeNodeId: "",
      disableEditConfirmation: false
    },
    activeBranch: {
      group: "",
      childGroups: /* @__PURE__ */ new Set(),
      sortedParentNodes: [],
      column: ""
    },
    dnd: {
      node: "",
      childGroups: /* @__PURE__ */ new Set()
    },
    activeNode: "",
    activeNodesOfColumn: {},
    selectedNodes: /* @__PURE__ */ new Set()
  },
  navigationHistory: {
    items: [],
    state: {
      activeIndex: -1,
      canGoBack: false,
      canGoForward: false
    },
    context: void 0
  }
});

// src/stores/view/reducers/search/set-search-query.ts
var setSearchQuery = (state2, query) => {
  state2.search.query = query;
  state2.search.results = /* @__PURE__ */ new Set();
  state2.search.searching = query.length > 0;
  state2.search = { ...state2.search };
};

// src/stores/view/reducers/search/set-search-results.ts
var setSearchResults = (state2, results) => {
  state2.search.results = new Set(results);
  state2.search.searching = false;
  state2.search = { ...state2.search };
};

// src/stores/view/reducers/search/toggle-search-input.ts
var toggleSearchInput = (state2) => {
  state2.search.showInput = !state2.search.showInput;
  if (!state2.search.showInput) {
    setSearchQuery(state2, "");
  }
  state2.search = { ...state2.search };
};

// src/stores/view/reducers/document/enable-edit-mode.ts
var enableEditMode = (state2, action) => {
  state2.editing = {
    activeNodeId: action.payload.nodeId,
    disableEditConfirmation: false
  };
};

// src/stores/view/reducers/document/disable-edit-mode.ts
var disableEditMode = (state2) => {
  state2.editing = {
    activeNodeId: "",
    disableEditConfirmation: false
  };
};

// src/stores/view/reducers/document/on-drag-start.ts
var onDragStart = (state2, action) => {
  const node = action.payload.nodeId;
  if (node) {
    state2.dnd = {
      node: action.payload.nodeId,
      childGroups: new Set(action.payload.childGroups)
    };
  }
};

// src/stores/view/reducers/document/on-drag-end.ts
var onDragEnd = (state2) => {
  state2.dnd = {
    node: "",
    childGroups: /* @__PURE__ */ new Set()
  };
};

// src/lib/tree-utils/get/traverse-up.ts
var traverseUp = (columns, node) => {
  const parents = [];
  const nodeColumnIndex = findNodeColumn(columns, node);
  if (nodeColumnIndex > 0) {
    const group = findGroupByNodeId(columns, node);
    if (group) {
      let currentParentId = group.parentId;
      for (let i = nodeColumnIndex - 1; i >= 0; i--) {
        const column = columns[i];
        for (const group2 of column.groups) {
          if (!currentParentId)
            currentParentId = group2.parentId;
          const parentIndex = group2.nodes.findIndex(
            (n) => n === currentParentId
          );
          if (parentIndex !== -1) {
            const parent = group2.nodes[parentIndex];
            parents.push(parent);
            currentParentId = group2.parentId;
            break;
          }
        }
      }
    }
  }
  return parents;
};

// src/stores/view/reducers/document/helpers/update-active-branch.ts
var updateActiveBranch = (state2, columns, activeNodeOfGroup) => {
  if (!state2.activeNode)
    return;
  const sortedParents = traverseUp(columns, state2.activeNode).reverse();
  const childGroups = [];
  traverseDown(childGroups, columns, state2.activeNode);
  const group = findGroupByNodeId(columns, state2.activeNode);
  if (!group)
    throw new Error("could not find group for node " + state2.activeNode);
  const columnId = columns[findNodeColumn(columns, state2.activeNode)].id;
  if (childGroups.join() !== Array.from(state2.activeBranch.childGroups).join() || sortedParents.join() !== state2.activeBranch.sortedParentNodes.join() || group.parentId !== state2.activeBranch.group || columnId !== state2.activeBranch.column) {
    state2.activeBranch = {
      childGroups: new Set(childGroups),
      sortedParentNodes: sortedParents,
      group: group.parentId,
      column: columnId
    };
  }
  if (!activeNodeOfGroup[columnId])
    activeNodeOfGroup[columnId] = {};
  activeNodeOfGroup[columnId][group.parentId] = state2.activeNode;
  for (const column of Object.values(activeNodeOfGroup)) {
    for (const group2 in column) {
      if (column[group2] === state2.activeNode && group2 !== state2.activeBranch.group) {
        delete column[group2];
      }
    }
  }
};

// src/stores/view/reducers/ui/helpers/add-navigation-history-item.ts
var addNavigationHistoryItem = (state2, nodeId) => {
  if (!nodeId)
    return;
  removeObsoleteHistoryItems(state2.navigationHistory);
  removeOldHistoryItems(state2.navigationHistory, 100);
  const activeItem = state2.navigationHistory.items[state2.navigationHistory.items.length - 1];
  if (activeItem !== nodeId) {
    state2.navigationHistory.items.push(nodeId);
  }
  state2.navigationHistory.state.activeIndex = state2.navigationHistory.items.length - 1;
  updateNavigationState(state2.navigationHistory);
  state2.navigationHistory = {
    ...state2.navigationHistory
  };
};

// src/stores/view/reducers/document/helpers/update-active-node.ts
var updateActiveNode = (documentState, nodeId, state2) => {
  documentState.activeNode = nodeId;
  if (state2)
    addNavigationHistoryItem(state2, documentState.activeNode);
  if (documentState.editing.activeNodeId && documentState.editing.activeNodeId !== nodeId)
    disableEditMode(documentState);
};

// src/lib/tree-utils/find/find-next-active-node-on-keyboard-navigation.ts
var findNextActiveNodeOnKeyboardNavigation = (columns, node, direction, activeNodeOfGroup) => {
  if (!node)
    return;
  let nextNode = null;
  if (direction === "left") {
    const group = findGroupByNodeId(columns, node);
    if (group && !group.parentId.startsWith("r"))
      nextNode = group.parentId;
  } else if (direction === "right") {
    const group = findChildGroup(columns, node);
    if (group) {
      const columnIndex = findNodeColumn(columns, node);
      const nextColumn = columns[columnIndex + 1];
      if (!nextColumn)
        return;
      const activeNode = activeNodeOfGroup[nextColumn.id]?.[group.parentId];
      if (activeNode)
        nextNode = activeNode;
      else
        nextNode = group.nodes[0];
    }
  } else {
    const columnIndex = findNodeColumn(columns, node);
    const column = columns[columnIndex];
    if (!column)
      return;
    const allNodes = column.groups.map((g) => g.nodes).flat();
    const nodeIndex = allNodes.findIndex((n) => n === node);
    if (direction === "up") {
      if (nodeIndex > 0) {
        nextNode = allNodes[nodeIndex - 1];
      }
    } else if (direction === "down") {
      if (nodeIndex < allNodes.length - 1) {
        nextNode = allNodes[nodeIndex + 1];
      }
    }
  }
  return nextNode;
};

// src/stores/view/reducers/document/helpers/update-selected-nodes.ts
var updateSelectedNodes = (column, selectedNodes, previousActiveNode, newActiveNode) => {
  const allNodeIds = column.groups.flatMap((group) => group.nodes);
  const previousActiveNodeIndex = allNodeIds.indexOf(previousActiveNode);
  if (previousActiveNodeIndex === -1)
    return;
  const currentSelectionIsEmpty = selectedNodes.size === 0;
  const lowestSelectedNodeIndex = currentSelectionIsEmpty ? previousActiveNodeIndex : allNodeIds.findIndex((nodeId) => selectedNodes.has(nodeId));
  const highestSelectedNodeIndex = currentSelectionIsEmpty ? previousActiveNodeIndex : allNodeIds.findLastIndex((nodeId) => selectedNodes.has(nodeId));
  const newActiveNodeIndex = allNodeIds.indexOf(newActiveNode);
  if (newActiveNodeIndex === -1)
    return;
  let mode = null;
  if (newActiveNodeIndex - previousActiveNodeIndex > 1) {
    mode = "jump_down" /* jump_down */;
  } else if (previousActiveNodeIndex - newActiveNodeIndex > 1) {
    mode = "jump_up" /* jump_up */;
  } else if (previousActiveNodeIndex === lowestSelectedNodeIndex)
    mode = "step_from_top" /* step_from_top */;
  else if (previousActiveNodeIndex === highestSelectedNodeIndex)
    mode = "step_from_bottom" /* step_from_bottom */;
  const goingUp = previousActiveNodeIndex > newActiveNodeIndex;
  selectedNodes.clear();
  if (!mode)
    return;
  let startIndex = 0, endIndex = 0;
  if (currentSelectionIsEmpty) {
    if (goingUp) {
      startIndex = newActiveNodeIndex;
      endIndex = previousActiveNodeIndex;
    } else {
      startIndex = previousActiveNodeIndex;
      endIndex = newActiveNodeIndex;
    }
  } else if (mode === "jump_down" /* jump_down */) {
    startIndex = previousActiveNodeIndex;
    endIndex = newActiveNodeIndex;
  } else if (mode === "jump_up" /* jump_up */) {
    startIndex = newActiveNodeIndex;
    endIndex = previousActiveNodeIndex;
  } else if (mode === "step_from_top" /* step_from_top */) {
    startIndex = newActiveNodeIndex;
    endIndex = highestSelectedNodeIndex;
  } else if (mode === "step_from_bottom" /* step_from_bottom */) {
    startIndex = lowestSelectedNodeIndex;
    endIndex = newActiveNodeIndex;
  }
  if (startIndex === endIndex)
    return;
  for (let i = startIndex; i <= endIndex; i++) {
    selectedNodes.add(allNodeIds[i]);
  }
};

// src/stores/view/reducers/document/helpers/reset-selection-state.ts
var resetSelectionState = (documentState) => {
  documentState.selectedNodes = /* @__PURE__ */ new Set();
};

// src/stores/view/reducers/document/helpers/update-selection-state.ts
var updateSelectionState = (documentState, nextNode, action) => {
  const isJump = action.type === "DOCUMENT/JUMP_TO_NODE";
  const isVerticalStep = action.type === "DOCUMENT/NAVIGATE_USING_KEYBOARD" && (action.payload.direction === "up" || action.payload.direction === "down");
  if (action.context?.shiftKey && (isJump || isVerticalStep)) {
    const columnIndex = findNodeColumn(action.payload.columns, nextNode);
    const column = action.payload.columns[columnIndex];
    invariant(column);
    updateSelectedNodes(
      column,
      documentState.selectedNodes,
      documentState.activeNode,
      nextNode
    );
    documentState.selectedNodes = new Set(documentState.selectedNodes);
  } else {
    resetSelectionState(documentState);
  }
};

// src/stores/view/reducers/document/navigate-using-keyboard.ts
var navigateUsingKeyboard = (documentState, state2, action) => {
  const nextNode = findNextActiveNodeOnKeyboardNavigation(
    action.payload.columns,
    documentState.activeNode,
    action.payload.direction,
    documentState.activeNodesOfColumn
  );
  if (nextNode) {
    updateSelectionState(documentState, nextNode, action);
    updateActiveNode(documentState, nextNode, state2);
  }
};

// src/stores/view/reducers/ui/navigate-active-node-history.ts
var navigateActiveNodeHistory = (documentState, state2, forward = false) => {
  const activeIndex = state2.navigationHistory.state.activeIndex;
  const newIndex = forward ? activeIndex + 1 : activeIndex - 1;
  const newItem = state2.navigationHistory.items[newIndex];
  if (newItem) {
    state2.navigationHistory.state.activeIndex = newIndex;
    updateNavigationState(state2.navigationHistory);
    state2.navigationHistory = { ...state2.navigationHistory };
    updateActiveNode(documentState, newItem, null);
  }
};

// src/stores/view/reducers/document/jump-to-node.ts
var jumpToNode = (documentViewState, state2, action) => {
  const nextNode = findNextActiveNode(
    action.payload.columns,
    documentViewState.activeNode,
    action
  );
  if (nextNode) {
    updateSelectionState(documentViewState, nextNode, action);
    updateActiveNode(documentViewState, nextNode, state2);
  }
};

// src/stores/view/reducers/ui/helpers/remove-deleted-navigation-items.ts
var removeDeletedNavigationItems = (state2, content) => {
  const items = [];
  let previous = null;
  for (const item of state2.navigationHistory.items) {
    if (content.hasOwnProperty(item) && item !== previous) {
      items.push(item);
      previous = item;
    }
  }
  state2.navigationHistory.items = items;
  state2.navigationHistory.state.activeIndex = state2.navigationHistory.items.length - 1;
  updateNavigationState(state2.navigationHistory);
  state2.navigationHistory = {
    ...state2.navigationHistory
  };
};

// src/stores/view/reducers/search/toggle-fuzzy-search.ts
var toggleFuzzySearch = (state2) => {
  state2.search.fuzzySearch = !state2.search.fuzzySearch;
  state2.search = { ...state2.search };
};

// src/helpers/sort-keys.ts
var sortKeys = (obj) => {
  return Object.keys(obj).sort((a, b) => {
    const aParts = a.split(".");
    const bParts = b.split(".");
    for (let i = 0; i < Math.max(aParts.length, bParts.length); i++) {
      if (aParts[i] === void 0)
        return -1;
      if (bParts[i] === void 0)
        return 1;
      const diff2 = Number(aParts[i]) - Number(bParts[i]);
      if (diff2 !== 0)
        return diff2;
    }
    return 0;
  });
};

// src/lib/tree-utils/find/find-next-node.ts
var findNextNode = (sections, node, direction) => {
  const sortedSections = sortKeys(sections.section_id);
  const currentSection = sections.id_section[node];
  const currentSectionIndex = sortedSections.findIndex(
    (section) => currentSection === section
  );
  if (currentSectionIndex === -1)
    return node;
  const nextSectionIndex = currentSectionIndex + (direction === "back" ? -1 : 1);
  const nextSection = sortedSections[nextSectionIndex];
  return sections.section_id[nextSection] || node;
};

// src/stores/view/reducers/ui/navigate-active-node.ts
var navigateActiveNode = (documentState, state2, action) => {
  const nextNode = findNextNode(
    action.payload.sections,
    documentState.activeNode,
    action.payload.direction
  );
  if (nextNode && nextNode !== documentState.activeNode)
    updateActiveNode(documentState, nextNode, state2);
};

// src/stores/view/view-reducer.ts
var updateDocumentState2 = (state2, action) => {
  if (action.type === "DOCUMENT/SET_ACTIVE_NODE") {
    updateActiveNode(state2.document, action.payload.id, state2);
  } else if (action.type === "DOCUMENT/NAVIGATE_USING_KEYBOARD") {
    navigateUsingKeyboard(state2.document, state2, action);
  } else if (action.type === "SEARCH/SET_QUERY") {
    setSearchQuery(state2, action.payload.query);
  } else if (action.type === "SEARCH/SET_RESULTS") {
    setSearchResults(state2, action.payload.results);
  } else if (action.type === "SEARCH/TOGGLE_INPUT") {
    toggleSearchInput(state2);
  } else if (action.type === "UI/TOGGLE_HISTORY_SIDEBAR") {
    const showHistorySidebar = state2.ui.controls.showHistorySidebar;
    state2.ui.controls = {
      showHistorySidebar: !showHistorySidebar,
      showHelpSidebar: false,
      showSettingsSidebar: false
    };
  } else if (action.type === "UI/TOGGLE_HELP_SIDEBAR") {
    const showHelpSidebar = state2.ui.controls.showHelpSidebar;
    state2.ui.controls = {
      showHistorySidebar: false,
      showHelpSidebar: !showHelpSidebar,
      showSettingsSidebar: false
    };
  } else if (action.type === "UI/TOGGLE_SETTINGS_SIDEBAR") {
    const showSettingsSidebar = state2.ui.controls.showSettingsSidebar;
    state2.ui.controls = {
      showHistorySidebar: false,
      showHelpSidebar: false,
      showSettingsSidebar: !showSettingsSidebar
    };
  } else if (action.type === "CLOSE_MODALS") {
    state2.ui.controls = {
      showHistorySidebar: false,
      showHelpSidebar: action.payload?.closeAllModals ? false : state2.ui.controls.showHelpSidebar,
      showSettingsSidebar: false
    };
  } else if (action.type === "DOCUMENT/ENABLE_EDIT_MODE") {
    enableEditMode(state2.document, action);
  } else if (action.type === "DOCUMENT/CONFIRM_DISABLE_EDIT") {
    state2.document.editing = {
      ...state2.document.editing,
      disableEditConfirmation: true
    };
  } else if (action.type === "DOCUMENT/RESET_DISABLE_EDIT_CONFIRMATION") {
    state2.document.editing = {
      ...state2.document.editing,
      disableEditConfirmation: false
    };
  } else if (action.type === "DOCUMENT/DISABLE_EDIT_MODE") {
    disableEditMode(state2.document);
  } else if (action.type === "SET_DRAG_STARTED") {
    onDragStart(state2.document, action);
  } else if (action.type === "DOCUMENT/SET_DRAG_ENDED") {
    onDragEnd(state2.document);
  } else if (action.type === "UPDATE_ACTIVE_BRANCH") {
    updateActiveBranch(
      state2.document,
      action.payload.columns,
      state2.document.activeNodesOfColumn
    );
  } else if (action.type === "NAVIGATION/NAVIGATE_FORWARD") {
    navigateActiveNodeHistory(state2.document, state2, true);
  } else if (action.type === "NAVIGATION/NAVIGATE_BACK") {
    navigateActiveNodeHistory(state2.document, state2);
  } else if (action.type === "DOCUMENT/JUMP_TO_NODE") {
    jumpToNode(state2.document, state2, action);
  } else if (action.type === "NAVIGATION/REMOVE_OBSOLETE") {
    removeDeletedNavigationItems(state2, action.payload.content);
  } else if (action.type === "SEARCH/TOGGLE_FUZZY_MODE") {
    toggleFuzzySearch(state2);
  } else if (action.type === "DOCUMENT/CLEAR_SELECTION") {
    resetSelectionState(state2.document);
  } else if (action.type === "NAVIGATION/SELECT_NEXT_NODE") {
    navigateActiveNode(state2.document, state2, action);
  }
};
var viewReducer = (store, action) => {
  updateDocumentState2(store, action);
  return store;
};

// src/stores/view/subscriptions/actions/update-active-branch.ts
var updateActiveBranch2 = (viewStore, documentState) => {
  viewStore.dispatch({
    type: "UPDATE_ACTIVE_BRANCH",
    payload: {
      columns: documentState.document.columns
    }
  });
};

// src/stores/view/subscriptions/helpers/is-empty-document.ts
var isEmptyDocument = (content) => {
  const values = Object.values(content);
  return values.length === 1 && values[0].content === "";
};

// src/stores/view/subscriptions/actions/enable-edit-mode.ts
var enableEditMode2 = (viewStore, documentState) => {
  viewStore.dispatch({
    type: "DOCUMENT/ENABLE_EDIT_MODE",
    payload: {
      nodeId: getIdOfSection(
        documentState.sections,
        documentState.history.context.activeSection
      )
    }
  });
};

// src/stores/view/subscriptions/effects/update-status-bar.ts
var updateStatusBar = (view) => {
  view.plugin.statusBar.update({
    type: "NUMBER_OF_CARDS",
    payload: {
      cards: Object.keys(view.documentStore.getValue().document.content).length
    }
  });
};

// src/stores/view/subscriptions/effects/css-variables/apply-font-size.ts
var applyFontSize = (view, fontSize) => {
  if (fontSize)
    view.containerEl.style.setProperty("--font-text-size", `${fontSize}px`);
  else
    view.containerEl.style.removeProperty("--font-text-size");
};

// src/stores/view/subscriptions/effects/css-variables/helpers/css-variables.ts
var cssVariables = {
  activeBranchBg: "--background-active-parent",
  containerBg: "--background-container",
  inactiveNodeBg: "--background-inactive-node",
  cardWidth: "--node-width",
  minCardHeight: "--min-node-height"
};

// src/stores/view/subscriptions/effects/css-variables/apply-container-bg.ts
var applyContainerBg = (view, color) => {
  if (color) {
    view.containerEl.style.setProperty(cssVariables.containerBg, color);
    view.containerEl.style.setProperty(cssVariables.inactiveNodeBg, color);
  } else {
    view.containerEl.style.removeProperty(cssVariables.containerBg);
    view.containerEl.style.removeProperty(cssVariables.inactiveNodeBg);
  }
};

// src/stores/view/subscriptions/effects/css-variables/apply-active-branch-bg.ts
var applyActiveBranchBg = (view, color) => {
  if (color) {
    view.containerEl.style.setProperty(cssVariables.activeBranchBg, color);
  } else {
    view.containerEl.style.removeProperty(cssVariables.activeBranchBg);
  }
};

// src/stores/view/subscriptions/effects/css-variables/apply-card-width.ts
var applyCardWidth = (view, width) => {
  invariant(width);
  view.containerEl.style.setProperty(cssVariables.cardWidth, `${width}px`);
};

// src/stores/view/subscriptions/helpers/maybe-get-id-of-section.ts
var maybeGetIdOfSection = (sections, section) => {
  return sections.section_id[section] || null;
};

// src/stores/view/subscriptions/actions/set-initial-active-node.ts
var setInitialActiveNode = (viewStore, documentState, settings, path) => {
  let id2 = null;
  const persistedSection = settings.documents[path]?.activeSection;
  const sections = documentState.sections;
  if (persistedSection) {
    id2 = maybeGetIdOfSection(sections, persistedSection);
  }
  const mostRecentActiveSection = documentState.history.context.activeSection;
  if (!id2 && mostRecentActiveSection) {
    id2 = maybeGetIdOfSection(sections, mostRecentActiveSection);
  }
  if (!id2)
    return;
  viewStore.dispatch({
    type: "DOCUMENT/SET_ACTIVE_NODE",
    payload: {
      id: id2
    }
  });
};

// src/stores/view/subscriptions/effects/mark-unresolved-links.ts
var import_obsidian23 = require("obsidian");
var getNonExistentLinks = (plugin, file) => {
  const cache = plugin.app.metadataCache.getFileCache(file);
  if (!cache?.links) {
    return /* @__PURE__ */ new Set();
  }
  const links = cache.links.map((link) => link.link.split("#")[0]);
  const nonExistentLinks = links.filter(
    (link) => !plugin.app.metadataCache.getFirstLinkpathDest(link, file.path)
  );
  return new Set(nonExistentLinks);
};
var getFileLinkElements = (view) => {
  return Array.from(
    view.contentEl.querySelectorAll(".internal-link")
  );
};
var markUnresolvedLinks = (view) => {
  const file = view.file;
  if (!file)
    return;
  const nonExistentLinks = getNonExistentLinks(view.plugin, file);
  const links = getFileLinkElements(view);
  for (const link of links) {
    const isUnresolved = link.dataset.href && nonExistentLinks.has(link.dataset.href.split("#")[0]);
    const hasUnresolvedClass = link.hasClass("is-unresolved" /* unresolved */);
    if (isUnresolved) {
      if (!hasUnresolvedClass) {
        link.addClass("is-unresolved" /* unresolved */);
      }
    } else if (hasUnresolvedClass) {
      link.removeClass("is-unresolved" /* unresolved */);
    }
  }
};
var debounced = (0, import_obsidian23.debounce)(markUnresolvedLinks, 100);

// src/stores/view/subscriptions/on-view-mount.ts
var applySettingsToView = (view) => {
  const state2 = view.plugin.settings.getValue();
  applyFontSize(view, state2.view.fontSize);
  applyContainerBg(view, state2.view.theme.containerBg);
  applyActiveBranchBg(view, state2.view.theme.activeBranchBg);
  applyCardWidth(view, state2.view.cardWidth);
  if (!view.container)
    return;
  applyZoom(
    view.viewStore.getValue(),
    view.container,
    state2.view.zoomLevel,
    true
  );
};
var onViewMount = (view) => {
  const documentStore = view.documentStore;
  const documentState = documentStore.getValue();
  const viewStore = view.viewStore;
  const container = view.container;
  if (!view.file)
    return;
  setInitialActiveNode(
    viewStore,
    documentState,
    view.plugin.settings.getValue(),
    view.file.path
  );
  updateActiveBranch2(viewStore, documentState);
  if (view.isActive && isEmptyDocument(documentState.document.content)) {
    enableEditMode2(viewStore, documentState);
  }
  updateStatusBar(view);
  if (view.isActive && container) {
    focusContainer(view);
    alignBranch(view, void 0, true);
  }
  debounced(view);
  applySettingsToView(view);
};

// src/stores/view/helpers/get-view-event-type.ts
var navigationEvents = /* @__PURE__ */ new Set([
  "NAVIGATION/NAVIGATE_BACK",
  "NAVIGATION/NAVIGATE_FORWARD",
  "NAVIGATION/SELECT_NEXT_NODE"
]);
var searchEvents = /* @__PURE__ */ new Set([
  "SEARCH/SET_QUERY",
  "SEARCH/SET_RESULTS"
]);
var stateEvents = /* @__PURE__ */ new Set([
  "DOCUMENT/SET_ACTIVE_NODE",
  "DOCUMENT/NAVIGATE_USING_KEYBOARD",
  "DOCUMENT/JUMP_TO_NODE"
]);
var editEvents = /* @__PURE__ */ new Set([
  "DOCUMENT/ENABLE_EDIT_MODE",
  "DOCUMENT/CONFIRM_DISABLE_EDIT"
]);
var cachedResults2 = {};
var getViewEventType = (type) => {
  if (cachedResults2[type]) {
    return cachedResults2[type];
  }
  let result = null;
  if (navigationEvents.has(type))
    result = { activeNodeHistory: true };
  else if (stateEvents.has(type))
    result = { activeNode: true };
  else if (searchEvents.has(type))
    result = { search: true };
  else if (editEvents.has(type))
    result = { edit: true };
  if (!result)
    result = {};
  cachedResults2[type] = result;
  return result;
};

// src/stores/view/subscriptions/actions/clear-selected-nodes.ts
var clearSelectedNodes = (view) => {
  view.viewStore.dispatch({ type: "DOCUMENT/CLEAR_SELECTION" });
};

// src/stores/view/subscriptions/actions/maybe-clear-selection.ts
var maybeClearSelection = (view, action) => {
  const selectedNodes = view.viewStore.getValue().document.selectedNodes;
  if (selectedNodes.size > 1) {
    const selectedNodeIsWithinSelection = action.type === "DOCUMENT/SET_ACTIVE_NODE" && selectedNodes.has(action.payload.id);
    if (!selectedNodeIsWithinSelection) {
      clearSelectedNodes(view);
    }
  }
};

// node_modules/fuse.js/dist/fuse.mjs
function isArray(value) {
  return !Array.isArray ? getTag(value) === "[object Array]" : Array.isArray(value);
}
var INFINITY = 1 / 0;
function baseToString(value) {
  if (typeof value == "string") {
    return value;
  }
  let result = value + "";
  return result == "0" && 1 / value == -INFINITY ? "-0" : result;
}
function toString(value) {
  return value == null ? "" : baseToString(value);
}
function isString(value) {
  return typeof value === "string";
}
function isNumber(value) {
  return typeof value === "number";
}
function isBoolean(value) {
  return value === true || value === false || isObjectLike(value) && getTag(value) == "[object Boolean]";
}
function isObject(value) {
  return typeof value === "object";
}
function isObjectLike(value) {
  return isObject(value) && value !== null;
}
function isDefined(value) {
  return value !== void 0 && value !== null;
}
function isBlank(value) {
  return !value.trim().length;
}
function getTag(value) {
  return value == null ? value === void 0 ? "[object Undefined]" : "[object Null]" : Object.prototype.toString.call(value);
}
var INCORRECT_INDEX_TYPE = "Incorrect 'index' type";
var LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY = (key) => `Invalid value for key ${key}`;
var PATTERN_LENGTH_TOO_LARGE = (max) => `Pattern length exceeds max of ${max}.`;
var MISSING_KEY_PROPERTY = (name) => `Missing ${name} property in key`;
var INVALID_KEY_WEIGHT_VALUE = (key) => `Property 'weight' in key '${key}' must be a positive integer`;
var hasOwn = Object.prototype.hasOwnProperty;
var KeyStore = class {
  constructor(keys) {
    this._keys = [];
    this._keyMap = {};
    let totalWeight = 0;
    keys.forEach((key) => {
      let obj = createKey(key);
      this._keys.push(obj);
      this._keyMap[obj.id] = obj;
      totalWeight += obj.weight;
    });
    this._keys.forEach((key) => {
      key.weight /= totalWeight;
    });
  }
  get(keyId) {
    return this._keyMap[keyId];
  }
  keys() {
    return this._keys;
  }
  toJSON() {
    return JSON.stringify(this._keys);
  }
};
function createKey(key) {
  let path = null;
  let id2 = null;
  let src = null;
  let weight = 1;
  let getFn = null;
  if (isString(key) || isArray(key)) {
    src = key;
    path = createKeyPath(key);
    id2 = createKeyId(key);
  } else {
    if (!hasOwn.call(key, "name")) {
      throw new Error(MISSING_KEY_PROPERTY("name"));
    }
    const name = key.name;
    src = name;
    if (hasOwn.call(key, "weight")) {
      weight = key.weight;
      if (weight <= 0) {
        throw new Error(INVALID_KEY_WEIGHT_VALUE(name));
      }
    }
    path = createKeyPath(name);
    id2 = createKeyId(name);
    getFn = key.getFn;
  }
  return { path, id: id2, weight, src, getFn };
}
function createKeyPath(key) {
  return isArray(key) ? key : key.split(".");
}
function createKeyId(key) {
  return isArray(key) ? key.join(".") : key;
}
function get(obj, path) {
  let list = [];
  let arr = false;
  const deepGet = (obj2, path2, index) => {
    if (!isDefined(obj2)) {
      return;
    }
    if (!path2[index]) {
      list.push(obj2);
    } else {
      let key = path2[index];
      const value = obj2[key];
      if (!isDefined(value)) {
        return;
      }
      if (index === path2.length - 1 && (isString(value) || isNumber(value) || isBoolean(value))) {
        list.push(toString(value));
      } else if (isArray(value)) {
        arr = true;
        for (let i = 0, len = value.length; i < len; i += 1) {
          deepGet(value[i], path2, index + 1);
        }
      } else if (path2.length) {
        deepGet(value, path2, index + 1);
      }
    }
  };
  deepGet(obj, isString(path) ? path.split(".") : path, 0);
  return arr ? list : list[0];
}
var MatchOptions = {
  // Whether the matches should be included in the result set. When `true`, each record in the result
  // set will include the indices of the matched characters.
  // These can consequently be used for highlighting purposes.
  includeMatches: false,
  // When `true`, the matching function will continue to the end of a search pattern even if
  // a perfect match has already been located in the string.
  findAllMatches: false,
  // Minimum number of characters that must be matched before a result is considered a match
  minMatchCharLength: 1
};
var BasicOptions = {
  // When `true`, the algorithm continues searching to the end of the input even if a perfect
  // match is found before the end of the same input.
  isCaseSensitive: false,
  // When true, the matching function will continue to the end of a search pattern even if
  includeScore: false,
  // List of properties that will be searched. This also supports nested properties.
  keys: [],
  // Whether to sort the result list, by score
  shouldSort: true,
  // Default sort function: sort by ascending score, ascending index
  sortFn: (a, b) => a.score === b.score ? a.idx < b.idx ? -1 : 1 : a.score < b.score ? -1 : 1
};
var FuzzyOptions = {
  // Approximately where in the text is the pattern expected to be found?
  location: 0,
  // At what point does the match algorithm give up. A threshold of '0.0' requires a perfect match
  // (of both letters and location), a threshold of '1.0' would match anything.
  threshold: 0.6,
  // Determines how close the match must be to the fuzzy location (specified above).
  // An exact letter match which is 'distance' characters away from the fuzzy location
  // would score as a complete mismatch. A distance of '0' requires the match be at
  // the exact location specified, a threshold of '1000' would require a perfect match
  // to be within 800 characters of the fuzzy location to be found using a 0.8 threshold.
  distance: 100
};
var AdvancedOptions = {
  // When `true`, it enables the use of unix-like search commands
  useExtendedSearch: false,
  // The get function to use when fetching an object's properties.
  // The default will search nested paths *ie foo.bar.baz*
  getFn: get,
  // When `true`, search will ignore `location` and `distance`, so it won't matter
  // where in the string the pattern appears.
  // More info: https://fusejs.io/concepts/scoring-theory.html#fuzziness-score
  ignoreLocation: false,
  // When `true`, the calculation for the relevance score (used for sorting) will
  // ignore the field-length norm.
  // More info: https://fusejs.io/concepts/scoring-theory.html#field-length-norm
  ignoreFieldNorm: false,
  // The weight to determine how much field length norm effects scoring.
  fieldNormWeight: 1
};
var Config = {
  ...BasicOptions,
  ...MatchOptions,
  ...FuzzyOptions,
  ...AdvancedOptions
};
var SPACE = /[^ ]+/g;
function norm(weight = 1, mantissa = 3) {
  const cache = /* @__PURE__ */ new Map();
  const m = Math.pow(10, mantissa);
  return {
    get(value) {
      const numTokens = value.match(SPACE).length;
      if (cache.has(numTokens)) {
        return cache.get(numTokens);
      }
      const norm2 = 1 / Math.pow(numTokens, 0.5 * weight);
      const n = parseFloat(Math.round(norm2 * m) / m);
      cache.set(numTokens, n);
      return n;
    },
    clear() {
      cache.clear();
    }
  };
}
var FuseIndex = class {
  constructor({
    getFn = Config.getFn,
    fieldNormWeight = Config.fieldNormWeight
  } = {}) {
    this.norm = norm(fieldNormWeight, 3);
    this.getFn = getFn;
    this.isCreated = false;
    this.setIndexRecords();
  }
  setSources(docs = []) {
    this.docs = docs;
  }
  setIndexRecords(records = []) {
    this.records = records;
  }
  setKeys(keys = []) {
    this.keys = keys;
    this._keysMap = {};
    keys.forEach((key, idx) => {
      this._keysMap[key.id] = idx;
    });
  }
  create() {
    if (this.isCreated || !this.docs.length) {
      return;
    }
    this.isCreated = true;
    if (isString(this.docs[0])) {
      this.docs.forEach((doc, docIndex) => {
        this._addString(doc, docIndex);
      });
    } else {
      this.docs.forEach((doc, docIndex) => {
        this._addObject(doc, docIndex);
      });
    }
    this.norm.clear();
  }
  // Adds a doc to the end of the index
  add(doc) {
    const idx = this.size();
    if (isString(doc)) {
      this._addString(doc, idx);
    } else {
      this._addObject(doc, idx);
    }
  }
  // Removes the doc at the specified index of the index
  removeAt(idx) {
    this.records.splice(idx, 1);
    for (let i = idx, len = this.size(); i < len; i += 1) {
      this.records[i].i -= 1;
    }
  }
  getValueForItemAtKeyId(item, keyId) {
    return item[this._keysMap[keyId]];
  }
  size() {
    return this.records.length;
  }
  _addString(doc, docIndex) {
    if (!isDefined(doc) || isBlank(doc)) {
      return;
    }
    let record = {
      v: doc,
      i: docIndex,
      n: this.norm.get(doc)
    };
    this.records.push(record);
  }
  _addObject(doc, docIndex) {
    let record = { i: docIndex, $: {} };
    this.keys.forEach((key, keyIndex) => {
      let value = key.getFn ? key.getFn(doc) : this.getFn(doc, key.path);
      if (!isDefined(value)) {
        return;
      }
      if (isArray(value)) {
        let subRecords = [];
        const stack = [{ nestedArrIndex: -1, value }];
        while (stack.length) {
          const { nestedArrIndex, value: value2 } = stack.pop();
          if (!isDefined(value2)) {
            continue;
          }
          if (isString(value2) && !isBlank(value2)) {
            let subRecord = {
              v: value2,
              i: nestedArrIndex,
              n: this.norm.get(value2)
            };
            subRecords.push(subRecord);
          } else if (isArray(value2)) {
            value2.forEach((item, k) => {
              stack.push({
                nestedArrIndex: k,
                value: item
              });
            });
          } else
            ;
        }
        record.$[keyIndex] = subRecords;
      } else if (isString(value) && !isBlank(value)) {
        let subRecord = {
          v: value,
          n: this.norm.get(value)
        };
        record.$[keyIndex] = subRecord;
      }
    });
    this.records.push(record);
  }
  toJSON() {
    return {
      keys: this.keys,
      records: this.records
    };
  }
};
function createIndex(keys, docs, { getFn = Config.getFn, fieldNormWeight = Config.fieldNormWeight } = {}) {
  const myIndex = new FuseIndex({ getFn, fieldNormWeight });
  myIndex.setKeys(keys.map(createKey));
  myIndex.setSources(docs);
  myIndex.create();
  return myIndex;
}
function parseIndex(data, { getFn = Config.getFn, fieldNormWeight = Config.fieldNormWeight } = {}) {
  const { keys, records } = data;
  const myIndex = new FuseIndex({ getFn, fieldNormWeight });
  myIndex.setKeys(keys);
  myIndex.setIndexRecords(records);
  return myIndex;
}
function computeScore$1(pattern, {
  errors = 0,
  currentLocation = 0,
  expectedLocation = 0,
  distance = Config.distance,
  ignoreLocation = Config.ignoreLocation
} = {}) {
  const accuracy = errors / pattern.length;
  if (ignoreLocation) {
    return accuracy;
  }
  const proximity = Math.abs(expectedLocation - currentLocation);
  if (!distance) {
    return proximity ? 1 : accuracy;
  }
  return accuracy + proximity / distance;
}
function convertMaskToIndices(matchmask = [], minMatchCharLength = Config.minMatchCharLength) {
  let indices = [];
  let start = -1;
  let end = -1;
  let i = 0;
  for (let len = matchmask.length; i < len; i += 1) {
    let match = matchmask[i];
    if (match && start === -1) {
      start = i;
    } else if (!match && start !== -1) {
      end = i - 1;
      if (end - start + 1 >= minMatchCharLength) {
        indices.push([start, end]);
      }
      start = -1;
    }
  }
  if (matchmask[i - 1] && i - start >= minMatchCharLength) {
    indices.push([start, i - 1]);
  }
  return indices;
}
var MAX_BITS = 32;
function search(text2, pattern, patternAlphabet, {
  location = Config.location,
  distance = Config.distance,
  threshold = Config.threshold,
  findAllMatches = Config.findAllMatches,
  minMatchCharLength = Config.minMatchCharLength,
  includeMatches = Config.includeMatches,
  ignoreLocation = Config.ignoreLocation
} = {}) {
  if (pattern.length > MAX_BITS) {
    throw new Error(PATTERN_LENGTH_TOO_LARGE(MAX_BITS));
  }
  const patternLen = pattern.length;
  const textLen = text2.length;
  const expectedLocation = Math.max(0, Math.min(location, textLen));
  let currentThreshold = threshold;
  let bestLocation = expectedLocation;
  const computeMatches = minMatchCharLength > 1 || includeMatches;
  const matchMask = computeMatches ? Array(textLen) : [];
  let index;
  while ((index = text2.indexOf(pattern, bestLocation)) > -1) {
    let score = computeScore$1(pattern, {
      currentLocation: index,
      expectedLocation,
      distance,
      ignoreLocation
    });
    currentThreshold = Math.min(score, currentThreshold);
    bestLocation = index + patternLen;
    if (computeMatches) {
      let i = 0;
      while (i < patternLen) {
        matchMask[index + i] = 1;
        i += 1;
      }
    }
  }
  bestLocation = -1;
  let lastBitArr = [];
  let finalScore = 1;
  let binMax = patternLen + textLen;
  const mask = 1 << patternLen - 1;
  for (let i = 0; i < patternLen; i += 1) {
    let binMin = 0;
    let binMid = binMax;
    while (binMin < binMid) {
      const score2 = computeScore$1(pattern, {
        errors: i,
        currentLocation: expectedLocation + binMid,
        expectedLocation,
        distance,
        ignoreLocation
      });
      if (score2 <= currentThreshold) {
        binMin = binMid;
      } else {
        binMax = binMid;
      }
      binMid = Math.floor((binMax - binMin) / 2 + binMin);
    }
    binMax = binMid;
    let start = Math.max(1, expectedLocation - binMid + 1);
    let finish = findAllMatches ? textLen : Math.min(expectedLocation + binMid, textLen) + patternLen;
    let bitArr = Array(finish + 2);
    bitArr[finish + 1] = (1 << i) - 1;
    for (let j = finish; j >= start; j -= 1) {
      let currentLocation = j - 1;
      let charMatch = patternAlphabet[text2.charAt(currentLocation)];
      if (computeMatches) {
        matchMask[currentLocation] = +!!charMatch;
      }
      bitArr[j] = (bitArr[j + 1] << 1 | 1) & charMatch;
      if (i) {
        bitArr[j] |= (lastBitArr[j + 1] | lastBitArr[j]) << 1 | 1 | lastBitArr[j + 1];
      }
      if (bitArr[j] & mask) {
        finalScore = computeScore$1(pattern, {
          errors: i,
          currentLocation,
          expectedLocation,
          distance,
          ignoreLocation
        });
        if (finalScore <= currentThreshold) {
          currentThreshold = finalScore;
          bestLocation = currentLocation;
          if (bestLocation <= expectedLocation) {
            break;
          }
          start = Math.max(1, 2 * expectedLocation - bestLocation);
        }
      }
    }
    const score = computeScore$1(pattern, {
      errors: i + 1,
      currentLocation: expectedLocation,
      expectedLocation,
      distance,
      ignoreLocation
    });
    if (score > currentThreshold) {
      break;
    }
    lastBitArr = bitArr;
  }
  const result = {
    isMatch: bestLocation >= 0,
    // Count exact matches (those with a score of 0) to be "almost" exact
    score: Math.max(1e-3, finalScore)
  };
  if (computeMatches) {
    const indices = convertMaskToIndices(matchMask, minMatchCharLength);
    if (!indices.length) {
      result.isMatch = false;
    } else if (includeMatches) {
      result.indices = indices;
    }
  }
  return result;
}
function createPatternAlphabet(pattern) {
  let mask = {};
  for (let i = 0, len = pattern.length; i < len; i += 1) {
    const char = pattern.charAt(i);
    mask[char] = (mask[char] || 0) | 1 << len - i - 1;
  }
  return mask;
}
var BitapSearch = class {
  constructor(pattern, {
    location = Config.location,
    threshold = Config.threshold,
    distance = Config.distance,
    includeMatches = Config.includeMatches,
    findAllMatches = Config.findAllMatches,
    minMatchCharLength = Config.minMatchCharLength,
    isCaseSensitive = Config.isCaseSensitive,
    ignoreLocation = Config.ignoreLocation
  } = {}) {
    this.options = {
      location,
      threshold,
      distance,
      includeMatches,
      findAllMatches,
      minMatchCharLength,
      isCaseSensitive,
      ignoreLocation
    };
    this.pattern = isCaseSensitive ? pattern : pattern.toLowerCase();
    this.chunks = [];
    if (!this.pattern.length) {
      return;
    }
    const addChunk = (pattern2, startIndex) => {
      this.chunks.push({
        pattern: pattern2,
        alphabet: createPatternAlphabet(pattern2),
        startIndex
      });
    };
    const len = this.pattern.length;
    if (len > MAX_BITS) {
      let i = 0;
      const remainder = len % MAX_BITS;
      const end = len - remainder;
      while (i < end) {
        addChunk(this.pattern.substr(i, MAX_BITS), i);
        i += MAX_BITS;
      }
      if (remainder) {
        const startIndex = len - MAX_BITS;
        addChunk(this.pattern.substr(startIndex), startIndex);
      }
    } else {
      addChunk(this.pattern, 0);
    }
  }
  searchIn(text2) {
    const { isCaseSensitive, includeMatches } = this.options;
    if (!isCaseSensitive) {
      text2 = text2.toLowerCase();
    }
    if (this.pattern === text2) {
      let result2 = {
        isMatch: true,
        score: 0
      };
      if (includeMatches) {
        result2.indices = [[0, text2.length - 1]];
      }
      return result2;
    }
    const {
      location,
      distance,
      threshold,
      findAllMatches,
      minMatchCharLength,
      ignoreLocation
    } = this.options;
    let allIndices = [];
    let totalScore = 0;
    let hasMatches = false;
    this.chunks.forEach(({ pattern, alphabet, startIndex }) => {
      const { isMatch, score, indices } = search(text2, pattern, alphabet, {
        location: location + startIndex,
        distance,
        threshold,
        findAllMatches,
        minMatchCharLength,
        includeMatches,
        ignoreLocation
      });
      if (isMatch) {
        hasMatches = true;
      }
      totalScore += score;
      if (isMatch && indices) {
        allIndices = [...allIndices, ...indices];
      }
    });
    let result = {
      isMatch: hasMatches,
      score: hasMatches ? totalScore / this.chunks.length : 1
    };
    if (hasMatches && includeMatches) {
      result.indices = allIndices;
    }
    return result;
  }
};
var BaseMatch = class {
  constructor(pattern) {
    this.pattern = pattern;
  }
  static isMultiMatch(pattern) {
    return getMatch(pattern, this.multiRegex);
  }
  static isSingleMatch(pattern) {
    return getMatch(pattern, this.singleRegex);
  }
  search() {
  }
};
function getMatch(pattern, exp) {
  const matches = pattern.match(exp);
  return matches ? matches[1] : null;
}
var ExactMatch = class extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "exact";
  }
  static get multiRegex() {
    return /^="(.*)"$/;
  }
  static get singleRegex() {
    return /^=(.*)$/;
  }
  search(text2) {
    const isMatch = text2 === this.pattern;
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, this.pattern.length - 1]
    };
  }
};
var InverseExactMatch = class extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "inverse-exact";
  }
  static get multiRegex() {
    return /^!"(.*)"$/;
  }
  static get singleRegex() {
    return /^!(.*)$/;
  }
  search(text2) {
    const index = text2.indexOf(this.pattern);
    const isMatch = index === -1;
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, text2.length - 1]
    };
  }
};
var PrefixExactMatch = class extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "prefix-exact";
  }
  static get multiRegex() {
    return /^\^"(.*)"$/;
  }
  static get singleRegex() {
    return /^\^(.*)$/;
  }
  search(text2) {
    const isMatch = text2.startsWith(this.pattern);
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, this.pattern.length - 1]
    };
  }
};
var InversePrefixExactMatch = class extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "inverse-prefix-exact";
  }
  static get multiRegex() {
    return /^!\^"(.*)"$/;
  }
  static get singleRegex() {
    return /^!\^(.*)$/;
  }
  search(text2) {
    const isMatch = !text2.startsWith(this.pattern);
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, text2.length - 1]
    };
  }
};
var SuffixExactMatch = class extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "suffix-exact";
  }
  static get multiRegex() {
    return /^"(.*)"\$$/;
  }
  static get singleRegex() {
    return /^(.*)\$$/;
  }
  search(text2) {
    const isMatch = text2.endsWith(this.pattern);
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [text2.length - this.pattern.length, text2.length - 1]
    };
  }
};
var InverseSuffixExactMatch = class extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "inverse-suffix-exact";
  }
  static get multiRegex() {
    return /^!"(.*)"\$$/;
  }
  static get singleRegex() {
    return /^!(.*)\$$/;
  }
  search(text2) {
    const isMatch = !text2.endsWith(this.pattern);
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, text2.length - 1]
    };
  }
};
var FuzzyMatch = class extends BaseMatch {
  constructor(pattern, {
    location = Config.location,
    threshold = Config.threshold,
    distance = Config.distance,
    includeMatches = Config.includeMatches,
    findAllMatches = Config.findAllMatches,
    minMatchCharLength = Config.minMatchCharLength,
    isCaseSensitive = Config.isCaseSensitive,
    ignoreLocation = Config.ignoreLocation
  } = {}) {
    super(pattern);
    this._bitapSearch = new BitapSearch(pattern, {
      location,
      threshold,
      distance,
      includeMatches,
      findAllMatches,
      minMatchCharLength,
      isCaseSensitive,
      ignoreLocation
    });
  }
  static get type() {
    return "fuzzy";
  }
  static get multiRegex() {
    return /^"(.*)"$/;
  }
  static get singleRegex() {
    return /^(.*)$/;
  }
  search(text2) {
    return this._bitapSearch.searchIn(text2);
  }
};
var IncludeMatch = class extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "include";
  }
  static get multiRegex() {
    return /^'"(.*)"$/;
  }
  static get singleRegex() {
    return /^'(.*)$/;
  }
  search(text2) {
    let location = 0;
    let index;
    const indices = [];
    const patternLen = this.pattern.length;
    while ((index = text2.indexOf(this.pattern, location)) > -1) {
      location = index + patternLen;
      indices.push([index, location - 1]);
    }
    const isMatch = !!indices.length;
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices
    };
  }
};
var searchers = [
  ExactMatch,
  IncludeMatch,
  PrefixExactMatch,
  InversePrefixExactMatch,
  InverseSuffixExactMatch,
  SuffixExactMatch,
  InverseExactMatch,
  FuzzyMatch
];
var searchersLen = searchers.length;
var SPACE_RE = / +(?=(?:[^\"]*\"[^\"]*\")*[^\"]*$)/;
var OR_TOKEN = "|";
function parseQuery(pattern, options = {}) {
  return pattern.split(OR_TOKEN).map((item) => {
    let query = item.trim().split(SPACE_RE).filter((item2) => item2 && !!item2.trim());
    let results = [];
    for (let i = 0, len = query.length; i < len; i += 1) {
      const queryItem = query[i];
      let found = false;
      let idx = -1;
      while (!found && ++idx < searchersLen) {
        const searcher = searchers[idx];
        let token = searcher.isMultiMatch(queryItem);
        if (token) {
          results.push(new searcher(token, options));
          found = true;
        }
      }
      if (found) {
        continue;
      }
      idx = -1;
      while (++idx < searchersLen) {
        const searcher = searchers[idx];
        let token = searcher.isSingleMatch(queryItem);
        if (token) {
          results.push(new searcher(token, options));
          break;
        }
      }
    }
    return results;
  });
}
var MultiMatchSet = /* @__PURE__ */ new Set([FuzzyMatch.type, IncludeMatch.type]);
var ExtendedSearch = class {
  constructor(pattern, {
    isCaseSensitive = Config.isCaseSensitive,
    includeMatches = Config.includeMatches,
    minMatchCharLength = Config.minMatchCharLength,
    ignoreLocation = Config.ignoreLocation,
    findAllMatches = Config.findAllMatches,
    location = Config.location,
    threshold = Config.threshold,
    distance = Config.distance
  } = {}) {
    this.query = null;
    this.options = {
      isCaseSensitive,
      includeMatches,
      minMatchCharLength,
      findAllMatches,
      ignoreLocation,
      location,
      threshold,
      distance
    };
    this.pattern = isCaseSensitive ? pattern : pattern.toLowerCase();
    this.query = parseQuery(this.pattern, this.options);
  }
  static condition(_, options) {
    return options.useExtendedSearch;
  }
  searchIn(text2) {
    const query = this.query;
    if (!query) {
      return {
        isMatch: false,
        score: 1
      };
    }
    const { includeMatches, isCaseSensitive } = this.options;
    text2 = isCaseSensitive ? text2 : text2.toLowerCase();
    let numMatches = 0;
    let allIndices = [];
    let totalScore = 0;
    for (let i = 0, qLen = query.length; i < qLen; i += 1) {
      const searchers2 = query[i];
      allIndices.length = 0;
      numMatches = 0;
      for (let j = 0, pLen = searchers2.length; j < pLen; j += 1) {
        const searcher = searchers2[j];
        const { isMatch, indices, score } = searcher.search(text2);
        if (isMatch) {
          numMatches += 1;
          totalScore += score;
          if (includeMatches) {
            const type = searcher.constructor.type;
            if (MultiMatchSet.has(type)) {
              allIndices = [...allIndices, ...indices];
            } else {
              allIndices.push(indices);
            }
          }
        } else {
          totalScore = 0;
          numMatches = 0;
          allIndices.length = 0;
          break;
        }
      }
      if (numMatches) {
        let result = {
          isMatch: true,
          score: totalScore / numMatches
        };
        if (includeMatches) {
          result.indices = allIndices;
        }
        return result;
      }
    }
    return {
      isMatch: false,
      score: 1
    };
  }
};
var registeredSearchers = [];
function register(...args) {
  registeredSearchers.push(...args);
}
function createSearcher(pattern, options) {
  for (let i = 0, len = registeredSearchers.length; i < len; i += 1) {
    let searcherClass = registeredSearchers[i];
    if (searcherClass.condition(pattern, options)) {
      return new searcherClass(pattern, options);
    }
  }
  return new BitapSearch(pattern, options);
}
var LogicalOperator = {
  AND: "$and",
  OR: "$or"
};
var KeyType = {
  PATH: "$path",
  PATTERN: "$val"
};
var isExpression = (query) => !!(query[LogicalOperator.AND] || query[LogicalOperator.OR]);
var isPath = (query) => !!query[KeyType.PATH];
var isLeaf = (query) => !isArray(query) && isObject(query) && !isExpression(query);
var convertToExplicit = (query) => ({
  [LogicalOperator.AND]: Object.keys(query).map((key) => ({
    [key]: query[key]
  }))
});
function parse(query, options, { auto = true } = {}) {
  const next = (query2) => {
    let keys = Object.keys(query2);
    const isQueryPath = isPath(query2);
    if (!isQueryPath && keys.length > 1 && !isExpression(query2)) {
      return next(convertToExplicit(query2));
    }
    if (isLeaf(query2)) {
      const key = isQueryPath ? query2[KeyType.PATH] : keys[0];
      const pattern = isQueryPath ? query2[KeyType.PATTERN] : query2[key];
      if (!isString(pattern)) {
        throw new Error(LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY(key));
      }
      const obj = {
        keyId: createKeyId(key),
        pattern
      };
      if (auto) {
        obj.searcher = createSearcher(pattern, options);
      }
      return obj;
    }
    let node = {
      children: [],
      operator: keys[0]
    };
    keys.forEach((key) => {
      const value = query2[key];
      if (isArray(value)) {
        value.forEach((item) => {
          node.children.push(next(item));
        });
      }
    });
    return node;
  };
  if (!isExpression(query)) {
    query = convertToExplicit(query);
  }
  return next(query);
}
function computeScore(results, { ignoreFieldNorm = Config.ignoreFieldNorm }) {
  results.forEach((result) => {
    let totalScore = 1;
    result.matches.forEach(({ key, norm: norm2, score }) => {
      const weight = key ? key.weight : null;
      totalScore *= Math.pow(
        score === 0 && weight ? Number.EPSILON : score,
        (weight || 1) * (ignoreFieldNorm ? 1 : norm2)
      );
    });
    result.score = totalScore;
  });
}
function transformMatches(result, data) {
  const matches = result.matches;
  data.matches = [];
  if (!isDefined(matches)) {
    return;
  }
  matches.forEach((match) => {
    if (!isDefined(match.indices) || !match.indices.length) {
      return;
    }
    const { indices, value } = match;
    let obj = {
      indices,
      value
    };
    if (match.key) {
      obj.key = match.key.src;
    }
    if (match.idx > -1) {
      obj.refIndex = match.idx;
    }
    data.matches.push(obj);
  });
}
function transformScore(result, data) {
  data.score = result.score;
}
function format(results, docs, {
  includeMatches = Config.includeMatches,
  includeScore = Config.includeScore
} = {}) {
  const transformers = [];
  if (includeMatches)
    transformers.push(transformMatches);
  if (includeScore)
    transformers.push(transformScore);
  return results.map((result) => {
    const { idx } = result;
    const data = {
      item: docs[idx],
      refIndex: idx
    };
    if (transformers.length) {
      transformers.forEach((transformer) => {
        transformer(result, data);
      });
    }
    return data;
  });
}
var Fuse = class {
  constructor(docs, options = {}, index) {
    this.options = { ...Config, ...options };
    if (this.options.useExtendedSearch && false) {
      throw new Error(EXTENDED_SEARCH_UNAVAILABLE);
    }
    this._keyStore = new KeyStore(this.options.keys);
    this.setCollection(docs, index);
  }
  setCollection(docs, index) {
    this._docs = docs;
    if (index && !(index instanceof FuseIndex)) {
      throw new Error(INCORRECT_INDEX_TYPE);
    }
    this._myIndex = index || createIndex(this.options.keys, this._docs, {
      getFn: this.options.getFn,
      fieldNormWeight: this.options.fieldNormWeight
    });
  }
  add(doc) {
    if (!isDefined(doc)) {
      return;
    }
    this._docs.push(doc);
    this._myIndex.add(doc);
  }
  remove(predicate = () => false) {
    const results = [];
    for (let i = 0, len = this._docs.length; i < len; i += 1) {
      const doc = this._docs[i];
      if (predicate(doc, i)) {
        this.removeAt(i);
        i -= 1;
        len -= 1;
        results.push(doc);
      }
    }
    return results;
  }
  removeAt(idx) {
    this._docs.splice(idx, 1);
    this._myIndex.removeAt(idx);
  }
  getIndex() {
    return this._myIndex;
  }
  search(query, { limit = -1 } = {}) {
    const {
      includeMatches,
      includeScore,
      shouldSort,
      sortFn,
      ignoreFieldNorm
    } = this.options;
    let results = isString(query) ? isString(this._docs[0]) ? this._searchStringList(query) : this._searchObjectList(query) : this._searchLogical(query);
    computeScore(results, { ignoreFieldNorm });
    if (shouldSort) {
      results.sort(sortFn);
    }
    if (isNumber(limit) && limit > -1) {
      results = results.slice(0, limit);
    }
    return format(results, this._docs, {
      includeMatches,
      includeScore
    });
  }
  _searchStringList(query) {
    const searcher = createSearcher(query, this.options);
    const { records } = this._myIndex;
    const results = [];
    records.forEach(({ v: text2, i: idx, n: norm2 }) => {
      if (!isDefined(text2)) {
        return;
      }
      const { isMatch, score, indices } = searcher.searchIn(text2);
      if (isMatch) {
        results.push({
          item: text2,
          idx,
          matches: [{ score, value: text2, norm: norm2, indices }]
        });
      }
    });
    return results;
  }
  _searchLogical(query) {
    const expression = parse(query, this.options);
    const evaluate = (node, item, idx) => {
      if (!node.children) {
        const { keyId, searcher } = node;
        const matches = this._findMatches({
          key: this._keyStore.get(keyId),
          value: this._myIndex.getValueForItemAtKeyId(item, keyId),
          searcher
        });
        if (matches && matches.length) {
          return [
            {
              idx,
              item,
              matches
            }
          ];
        }
        return [];
      }
      const res = [];
      for (let i = 0, len = node.children.length; i < len; i += 1) {
        const child = node.children[i];
        const result = evaluate(child, item, idx);
        if (result.length) {
          res.push(...result);
        } else if (node.operator === LogicalOperator.AND) {
          return [];
        }
      }
      return res;
    };
    const records = this._myIndex.records;
    const resultMap = {};
    const results = [];
    records.forEach(({ $: item, i: idx }) => {
      if (isDefined(item)) {
        let expResults = evaluate(expression, item, idx);
        if (expResults.length) {
          if (!resultMap[idx]) {
            resultMap[idx] = { idx, item, matches: [] };
            results.push(resultMap[idx]);
          }
          expResults.forEach(({ matches }) => {
            resultMap[idx].matches.push(...matches);
          });
        }
      }
    });
    return results;
  }
  _searchObjectList(query) {
    const searcher = createSearcher(query, this.options);
    const { keys, records } = this._myIndex;
    const results = [];
    records.forEach(({ $: item, i: idx }) => {
      if (!isDefined(item)) {
        return;
      }
      let matches = [];
      keys.forEach((key, keyIndex) => {
        matches.push(
          ...this._findMatches({
            key,
            value: item[keyIndex],
            searcher
          })
        );
      });
      if (matches.length) {
        results.push({
          idx,
          item,
          matches
        });
      }
    });
    return results;
  }
  _findMatches({ key, value, searcher }) {
    if (!isDefined(value)) {
      return [];
    }
    let matches = [];
    if (isArray(value)) {
      value.forEach(({ v: text2, i: idx, n: norm2 }) => {
        if (!isDefined(text2)) {
          return;
        }
        const { isMatch, score, indices } = searcher.searchIn(text2);
        if (isMatch) {
          matches.push({
            score,
            key,
            value: text2,
            idx,
            norm: norm2,
            indices
          });
        }
      });
    } else {
      const { v: text2, n: norm2 } = value;
      const { isMatch, score, indices } = searcher.searchIn(text2);
      if (isMatch) {
        matches.push({ score, key, value: text2, norm: norm2, indices });
      }
    }
    return matches;
  }
};
Fuse.version = "7.0.0";
Fuse.createIndex = createIndex;
Fuse.parseIndex = parseIndex;
Fuse.config = Config;
{
  Fuse.parseQuery = parse;
}
{
  register(ExtendedSearch);
}

// src/stores/view/subscriptions/actions/update-search-results/helpers/perform-search.ts
var searchState = {
  fuse: /* @__PURE__ */ new Map()
};
var performSearch = (documentStore, query, fuzzyMode) => {
  let fuse = searchState.fuse.get(documentStore);
  if (!fuse) {
    const documentState = documentStore.getValue();
    const items = [];
    for (const id2 of Object.keys(documentState.document.content)) {
      const content = documentState.document.content[id2]?.content;
      if (content) {
        items.push({
          id: id2,
          content
        });
      }
    }
    fuse = new Fuse(items, {
      keys: ["content"],
      threshold: fuzzyMode ? 0.4 : 0.1,
      shouldSort: true,
      isCaseSensitive: false,
      ignoreLocation: true
    });
    searchState.fuse.set(documentStore, fuse);
  }
  return fuse.search(query);
};

// src/stores/view/subscriptions/actions/update-search-results/update-search-results.ts
var updateSearchResults = (documentStore, viewStore) => {
  {
    const viewState = viewStore.getValue();
    const query = viewState.search.query;
    if (query) {
      const results = performSearch(
        documentStore,
        query,
        viewState.search.fuzzySearch
      );
      viewStore.dispatch({
        type: "SEARCH/SET_RESULTS",
        payload: {
          results: results.map((r) => r.item.id)
        }
      });
      const shouldUpdateActiveNode = results.length > 0 && !results.find(
        (r) => r.item.id === viewStore.getValue().document.activeNode
      );
      if (shouldUpdateActiveNode) {
        viewStore.dispatch({
          type: "DOCUMENT/SET_ACTIVE_NODE",
          payload: {
            id: results[0].item.id
          }
        });
      }
    }
  }
};

// src/obsidian/helpers/get-used-hotkeys.ts
var getUsedHotkeys = (plugin) => {
  const app = plugin.app;
  const conflicting = /* @__PURE__ */ new Map();
  const allCommands = {
    ...app.commands.commands,
    ...app.commands.editorCommands
  };
  const customHotkeys = Object.fromEntries(
    Object.entries(app.hotkeyManager.customKeys).map(
      ([name, hotkeys]) => [
        name,
        { hotkeys, name: allCommands[name]?.name || name }
      ]
    )
  );
  const commands = {
    ...allCommands,
    ...customHotkeys
  };
  for (const command of Object.values(commands)) {
    if (command.hotkeys?.length) {
      for (const hotkey of command.hotkeys) {
        const hotkey_string = hotkeyToString(hotkey);
        conflicting.set(hotkey_string, command.name);
      }
    }
  }
  return conflicting;
};

// src/stores/view/subscriptions/actions/update-conflicting-hotkeys.ts
var updateConflictingHotkeys2 = (view) => {
  setTimeout(() => {
    hotkeyStore.dispatch({
      type: "SET_CONFLICTING_HOTKEYS",
      payload: {
        conflictingHotkeys: getUsedHotkeys(view.plugin)
      }
    });
  }, 50);
};

// src/stores/view/subscriptions/actions/update-search-results/helpers/reset-search-fuse.ts
var resetSearchFuse = (documentStore) => {
  searchState.fuse.delete(documentStore);
};

// src/stores/view/subscriptions/actions/persist-active-node-in-plugin-settings.ts
var state = {};
var persistActiveNodeInPluginSettings = (view) => {
  if (!view.file)
    return;
  const documentState = view.documentStore.getValue();
  const viewState = view.viewStore.getValue();
  const sectionNumber = getSectionOfId(
    documentState.sections,
    viewState.document.activeNode
  );
  const path = view.file?.path;
  if (state[path] === sectionNumber)
    return;
  state[path] = sectionNumber;
  view.plugin.settings.dispatch({
    type: "DOCUMENT/SET_ACTIVE_NODE",
    payload: {
      sectionNumber,
      path
    }
  });
};

// src/stores/view/subscriptions/on-view-state-update.ts
var onViewStateUpdate = (view, action) => {
  const documentStore = view.documentStore;
  const documentState = documentStore.getValue();
  const viewStore = view.viewStore;
  const viewState = viewStore.getValue();
  const container = view.container;
  const type = action.type;
  const e = getViewEventType(
    type
  );
  const activeNodeChange = e.activeNode || e.activeNodeHistory;
  if (activeNodeChange) {
    updateActiveBranch2(viewStore, documentState);
    persistActiveNodeInPluginSettings(view);
  }
  if (activeNodeChange && type !== "DOCUMENT/NAVIGATE_USING_KEYBOARD" && type !== "DOCUMENT/JUMP_TO_NODE") {
    maybeClearSelection(view, action);
  }
  if (action.type === "SEARCH/SET_QUERY") {
    updateSearchResults(documentStore, viewStore);
  }
  if (action.type === "UI/TOGGLE_HELP_SIDEBAR") {
    if (viewState.ui.controls.showHelpSidebar)
      updateConflictingHotkeys2(view);
  }
  if (!container || !view.isViewOfFile)
    return;
  const postInlineEditor = type === "DOCUMENT/CONFIRM_DISABLE_EDIT";
  if (postInlineEditor) {
    const maybeViewIsClosing = !view.isActive;
    view.saveDocument(maybeViewIsClosing, postInlineEditor);
  }
  if (type === "SEARCH/TOGGLE_FUZZY_MODE") {
    resetSearchFuse(documentStore);
  }
  if (action.type === "DOCUMENT/DISABLE_EDIT_MODE" || action.type === "SEARCH/TOGGLE_INPUT" || action.type === "NAVIGATION/NAVIGATE_FORWARD" || action.type === "NAVIGATION/NAVIGATE_BACK") {
    focusContainer(view);
  }
  if (activeNodeChange || e.search || e.edit) {
    const skipAligning = action.type === "DOCUMENT/SET_ACTIVE_NODE" && action.context?.modKey;
    if (!skipAligning) {
      alignBranch(view);
    }
  }
};

// src/stores/view/subscriptions/actions/set-active-node.ts
var setActiveNode = (viewStore, documentState) => {
  viewStore.dispatch({
    type: "DOCUMENT/SET_ACTIVE_NODE",
    payload: {
      id: getIdOfSection(
        documentState.sections,
        documentState.history.context.activeSection
      )
    }
  });
};

// src/stores/view/subscriptions/actions/remove-obsolete-navigation-items.ts
var removeObsoleteNavigationItems = (viewStore, documentState) => {
  viewStore.dispatch({
    type: "NAVIGATION/REMOVE_OBSOLETE",
    payload: {
      content: documentState.document.content
    }
  });
};

// src/stores/view/subscriptions/on-document-state-update.ts
var onDocumentStateUpdate = (view, action) => {
  const documentStore = view.documentStore;
  const documentState = documentStore.getValue();
  const viewStore = view.viewStore;
  const container = view.container;
  const type = action.type;
  const e = getDocumentEventType(
    type
  );
  if (type === "DOCUMENT/LOAD_FILE") {
    discardChanges(view);
  }
  const structuralChange = e.createOrDelete || e.dropOrMove || e.changeHistory || e.clipboard;
  if (structuralChange) {
    setActiveNode(viewStore, documentState);
    updateActiveBranch2(viewStore, documentState);
  }
  if (structuralChange && type !== "DOCUMENT/MOVE_NODE") {
    clearSelectedNodes(view);
  }
  if (type === "DOCUMENT/INSERT_NODE" && view.isActive) {
    enableEditMode2(viewStore, documentState);
  }
  if (type === "DOCUMENT/DELETE_NODE" || type === "DOCUMENT/CUT_NODE" || e.changeHistory || type === "DOCUMENT/EXTRACT_BRANCH" || type === "DOCUMENT/LOAD_FILE" || type === "DOCUMENT/SPLIT_NODE") {
    removeObsoleteNavigationItems(viewStore, documentState);
  }
  if (!container || !view.isViewOfFile)
    return;
  if (e.content || structuralChange) {
    const maybeViewIsClosing = !view.isActive;
    view.saveDocument(maybeViewIsClosing);
  }
  if (e.content || structuralChange) {
    resetSearchFuse(documentStore);
  }
  if (structuralChange) {
    updateStatusBar(view);
  }
  if (e.content || structuralChange) {
    focusContainer(view);
  }
  if (structuralChange || e.content) {
    let scrollingBehavior;
    let delay;
    if (action.type === "DOCUMENT/MOVE_NODE") {
      const verticalMove = action.payload.direction === "down" || action.payload.direction === "up";
      if (verticalMove)
        scrollingBehavior = "instant";
    } else if (action.type === "DOCUMENT/LOAD_FILE") {
      scrollingBehavior = "instant";
    } else if (action.type === "DOCUMENT/DROP_NODE") {
      delay = 500;
    }
    alignBranch(
      view,
      scrollingBehavior,
      type === "DOCUMENT/SPLIT_NODE" ? true : void 0,
      delay
    );
  }
};

// src/stores/view/subscriptions/on-plugin-settings-update.ts
var import_obsidian24 = require("obsidian");
var onPluginSettingsUpdate = (view, state2, action) => {
  if (!view.container)
    return;
  const type = action.type;
  if (type === "SET_FONT_SIZE") {
    applyFontSize(view, state2.view.fontSize);
  } else if (type === "SET_CONTAINER_BG") {
    applyContainerBg(view, state2.view.theme.containerBg);
  } else if (type === "SET_ACTIVE_BRANCH_BG") {
    applyActiveBranchBg(view, state2.view.theme.activeBranchBg);
  } else if (type === "SET_CARD_WIDTH") {
    applyCardWidth(view, state2.view.cardWidth);
  } else if (action.type === "UI/CHANGE_ZOOM_LEVEL") {
    applyZoom(
      view.viewStore.getValue(),
      view.container,
      state2.view.zoomLevel,
      true
    );
  } else if (action.type === "SET_DOCUMENT_TYPE") {
    view.saveDocument();
  }
  const shouldAlign = type === "SET_HORIZONTAL_SCROLLING_MODE" || type === "UPDATE_AXIS_OFFSET" || type === "UI/CHANGE_ZOOM_LEVEL" || type === "SET_CARD_WIDTH" || type === "SET_LIMIT_PREVIEW_HEIGHT";
  if (view.isActive && shouldAlign) {
    alignBranch(view, "instant");
  }
  if (type === "SET_HORIZONTAL_SCROLLING_MODE" && state2.view.scrolling.horizontalScrollingMode === "fixed-position") {
    if (view.isActive)
      new import_obsidian24.Notice("Hold space to change card position");
  }
};

// src/stores/view/subscriptions/on-documents-state-update.ts
var onDocumentsStateUpdate = (view, action) => {
  if (!view.container)
    return;
  if (action.type === "WORKSPACE/ACTIVE_LEAF_CHANGE") {
    if (view.viewStore.getValue().document.editing.activeNodeId) {
      saveNodeContent(view);
    }
  }
  if (view.isActive && (action.type === "WORKSPACE/SET_ACTIVE_LINEAGE_VIEW" || action.type === "WORKSPACE/RESIZE")) {
    focusContainer(view);
    alignBranch(view);
  }
};

// src/stores/view/subscriptions/on-metadata-cache.ts
var onMetadataCache = (view) => {
  const eventRef = view.plugin.app.metadataCache.on("changed", (file) => {
    if (file === view.file)
      debounced(view);
  });
  return () => {
    view.plugin.app.metadataCache.offref(eventRef);
  };
};

// src/stores/view/subscriptions/view-subscriptions.ts
var viewSubscriptions = (view) => {
  const unsubFromDocument = view.documentStore.subscribe(
    (documentState, action) => {
      if (!action)
        return;
      onDocumentStateUpdate(view, action);
    }
  );
  const unsubFromView = view.viewStore.subscribe(
    (viewState, action, initialRun) => {
      if (initialRun) {
        onViewMount(view);
      } else if (action) {
        onViewStateUpdate(view, action);
      }
    }
  );
  const unsubFromDocuments = view.plugin.documents.subscribe((_, action) => {
    if (!action)
      return;
    onDocumentsStateUpdate(view, action);
  });
  const unsubFromSettings = view.plugin.settings.subscribe(
    (state2, action) => {
      if (!action)
        return;
      onPluginSettingsUpdate(view, state2, action);
    }
  );
  const unsubFromCache = onMetadataCache(view);
  return () => {
    unsubFromDocument();
    unsubFromCache();
    unsubFromView();
    unsubFromSettings();
    unsubFromDocuments();
  };
};

// src/obsidian/helpers/inline-editor.ts
var import_obsidian25 = require("obsidian");

// src/helpers/logger.ts
var createLogger = (env) => {
  const isDev = env === "development";
  const debug = (...message) => {
    if (isDev) {
      console.log(`[DEBUG]: `, ...message);
    }
  };
  const info = (...message) => {
    if (isDev) {
      console.log(`[INFO]: `, ...message);
    }
  };
  const warn = (...message) => {
    if (isDev) {
      console.warn(`[WARN]: `, ...message);
    }
  };
  const error = (...message) => {
    console.error(`[ERROR]: `, ...message);
  };
  return { debug, info, warn, error };
};
var logger = createLogger("development");

// src/obsidian/helpers/vim-enter-insert-mode.ts
var vimEnterInsertMode = (plugin, view) => {
  const config = plugin.app.vault.config;
  if (config?.vimMode) {
    try {
      window.CodeMirrorAdapter?.Vim.enterInsertMode(
        // @ts-ignore
        view.editMode?.editor?.cm?.cm
      );
    } catch {
      logger.warn("could not enter insert mode");
    }
  }
};

// src/obsidian/helpers/inline-editor.ts
var noop2 = async () => {
};
var _mounting;
var InlineEditor = class {
  constructor(view) {
    this.view = view;
    this.nodeId = null;
    this.target = null;
    this.appliedExternalCursor = null;
    this.onChangeSubscriptions = /* @__PURE__ */ new Set();
    __privateAdd(this, _mounting, Promise.resolve());
    this.focus = () => {
      this.inlineView.editor.focus();
    };
    this.setActiveEditor = () => {
      this.view.plugin.app.workspace.activeEditor = this.inlineView;
    };
    this.invokeAndDeleteOnChangeSubscriptions = () => {
      if (this.onChangeSubscriptions.size)
        for (const subscription of this.onChangeSubscriptions) {
          subscription();
          this.onChangeSubscriptions.delete(subscription);
        }
    };
  }
  get activeNode() {
    return this.nodeId;
  }
  get mounting() {
    return __privateGet(this, _mounting);
  }
  getContent() {
    return this.inlineView.editor.getValue();
  }
  getCursor() {
    return this.inlineView.editor.getCursor();
  }
  overrideCursor(cursor) {
    if (this.activeNode)
      this.setCursor(cursor.line, cursor.ch);
    else
      this.appliedExternalCursor = cursor;
  }
  setContent(content) {
    this.inlineView.__setViewData__(content, true);
  }
  loadNode(target, nodeId) {
    if (!this.view.file)
      return;
    let resolve = () => {
    };
    __privateSet(this, _mounting, new Promise((_resolve) => {
      resolve = _resolve;
    }));
    this.view.plugin.settings.dispatch({
      type: "BACKUP/ADD_FILE",
      payload: {
        path: this.view.file.path,
        content: this.view.data
      }
    });
    const content = this.view.documentStore.getValue().document.content[nodeId]?.content || "";
    this.setContent(content);
    if (this.appliedExternalCursor) {
      this.setCursor(
        this.appliedExternalCursor.line,
        this.appliedExternalCursor.ch
      );
      this.appliedExternalCursor = null;
    } else {
      this.setCursor(
        this.inlineView.editor.lastLine(),
        this.inlineView.editor.getLine(
          this.inlineView.editor.lastLine()
        ).length
      );
    }
    target.append(this.containerEl);
    this.focus();
    AdjustHeight(target)();
    this.nodeId = nodeId;
    this.target = target;
    if (!content) {
      vimEnterInsertMode(this.view.plugin, this.inlineView);
    }
    this.target.addEventListener("focusin", this.setActiveEditor);
    this.setActiveEditor();
    setTimeout(() => resolve(), Math.max(16, content.length / 60));
  }
  unloadNode() {
    this.nodeId = null;
    if (this.target) {
      this.view.plugin.app.workspace.activeEditor = null;
      this.target.removeEventListener("focusin", this.setActiveEditor);
      this.target.empty();
      this.target = null;
    }
  }
  async onload() {
    const workspace = this.view.plugin.app.workspace;
    this.containerEl = document.createElement("div");
    this.containerEl.addClasses(["lineage-inline-editor"]);
    this.inlineView = new import_obsidian25.MarkdownView({
      containerEl: this.containerEl,
      app: this.view.plugin.app,
      workspace
    });
    this.inlineView.save = noop2;
    this.inlineView.requestSave = this.invokeAndDeleteOnChangeSubscriptions;
    this.inlineView.__setViewData__ = this.inlineView.setViewData;
    this.inlineView.setViewData = noop2;
    if (this.inlineView.getMode() === "preview") {
      await this.inlineView.setState(
        { mode: "source" },
        { history: false }
      );
    }
  }
  onNextChange(subscription) {
    this.onChangeSubscriptions.add(subscription);
    return () => {
      this.onChangeSubscriptions.delete(subscription);
    };
  }
  async loadFile(file) {
    this.inlineView.file = file;
    await this.inlineView.onLoadFile(file);
  }
  async unloadFile() {
    const file = this.inlineView.file;
    if (file) {
      this.inlineView.file = null;
      await this.inlineView.onUnloadFile(file);
    }
    this.unloadNode();
  }
  setCursor(line, ch) {
    this.inlineView.editor.setCursor(line, ch);
  }
};
_mounting = new WeakMap();

// src/view/helpers/stringify-document.ts
var stringifyDocument = (document2, format2) => {
  const json = columnsToJson(document2.columns, document2.content);
  if (format2 === "outline") {
    return jsonToOutline(json);
  } else
    return jsonToSections(json);
};

// src/obsidian/events/workspace/helpers/maybe-get-document-format.ts
var maybeGetDocumentFormat = (view) => {
  invariant(view.file);
  return view.plugin.settings.getValue().documents[view.file.path]?.documentFormat;
};

// src/obsidian/events/workspace/helpers/get-or-detect-document-format.ts
var getOrDetectDocumentFormat = (view, data) => {
  const format2 = maybeGetDocumentFormat(view);
  if (format2) {
    return format2;
  } else {
    const detected = detectDocumentFormat(view.data);
    if (detected)
      return detected;
    else {
      const defaultFormat = view.plugin.settings.getValue().general.defaultDocumentFormat;
      if (defaultFormat === "outline") {
        if (!data.trim())
          return "outline";
        try {
          const tree = outlineToJson(data);
          if (tree.length <= 1 && tree[0]?.children?.length === 0)
            return "outline";
        } catch {
        }
      }
      return "sections";
    }
  }
};

// src/view/view.ts
var FILE_VIEW_TYPE = "lineage";
var LineageView = class _LineageView extends import_obsidian26.TextFileView {
  constructor(leaf, plugin) {
    super(leaf);
    this.plugin = plugin;
    this.onDestroyCallbacks = /* @__PURE__ */ new Set();
    this.onViewStoreError = (error, location, action) => {
      if (action && action.type === "DOCUMENT/LOAD_FILE") {
        if (this.file) {
          this.plugin.documents.dispatch({
            type: "DOCUMENTS/DELETE_DOCUMENT",
            payload: { path: this.file.path }
          });
          setViewType(this.plugin, this.file.path, "markdown");
          toggleObsidianViewType(
            this.plugin,
            this.plugin.app.workspace.getLeaf(),
            "markdown"
          );
        }
      }
      onPluginError(error, location, action);
    };
    this.saveDocument = async (immediate = false, force = false) => {
      invariant(this.file);
      const state2 = clone(this.documentStore.getValue());
      const data = state2.file.frontmatter + stringifyDocument(state2.document, getDocumentFormat(this));
      if (data !== this.data || force) {
        this.data = data;
        if (immediate)
          await this.save();
        else
          this.requestSave();
        this.deleteBackup();
      }
    };
    this.deleteBackup = () => {
      if (this.file && this.plugin.documents.getValue().processedBackups) {
        this.plugin.settings.dispatch({
          type: "BACKUP/DELETE_FILE",
          payload: {
            path: this.file.path
          }
        });
      }
    };
    this.loadInitialData = async () => {
      invariant(this.file);
      const fileHasAStore = this.plugin.documents.getValue().documents[this.file.path];
      if (fileHasAStore) {
        this.useExistingStore();
      } else {
        this.createStore();
      }
      this.loadDocumentToStore();
      if (!this.inlineEditor) {
        this.inlineEditor = new InlineEditor(this);
        await this.inlineEditor.onload();
      }
      await this.inlineEditor.loadFile(this.file);
      this.component = new main_default({
        target: this.contentEl,
        props: {
          plugin: this.plugin,
          view: this
        }
      });
      this.container = this.contentEl.querySelector("#columns-container");
      invariant(this.container);
      this.onDestroyCallbacks.add(viewSubscriptions(this));
    };
    this.createStore = () => {
      invariant(this.file);
      this.plugin.documents.dispatch({
        type: "DOCUMENTS/ADD_DOCUMENT",
        payload: {
          path: this.file.path,
          documentStore: this.documentStore,
          viewId: this.id
        }
      });
      this.documentStore.dispatch({
        type: "FS/SET_FILE_PATH",
        payload: {
          path: this.file.path
        }
      });
    };
    this.useExistingStore = () => {
      if (!this.file)
        return;
      this.documentStore = this.plugin.documents.getValue().documents[this.file.path].documentStore;
    };
    this.loadDocumentToStore = () => {
      const { data, frontmatter } = extractFrontmatter(this.data);
      const state2 = this.documentStore.getValue();
      const format2 = getOrDetectDocumentFormat(this, data);
      const existingData = stringifyDocument(state2.document, format2);
      const bodyHasChanged = existingData !== data;
      const frontmatterHasChanged = !bodyHasChanged && frontmatter !== state2.file.frontmatter;
      if (!existingData || bodyHasChanged || frontmatterHasChanged) {
        const isEditing2 = this.viewStore.getValue().document.editing.activeNodeId;
        if (frontmatterHasChanged) {
          this.documentStore.dispatch({
            type: "FILE/UPDATE_FRONTMATTER",
            payload: {
              frontmatter
            }
          });
        } else if (!isEditing2) {
          const activeNode = this.viewStore.getValue().document.activeNode;
          const activeSection = activeNode ? this.documentStore.getValue().sections.id_section[activeNode] : null;
          this.documentStore.dispatch({
            payload: {
              document: { data, frontmatter, position: null },
              format: format2,
              activeSection
            },
            type: "DOCUMENT/LOAD_FILE"
          });
          if (!maybeGetDocumentFormat(this)) {
            invariant(this.file);
            setDocumentFormat(this.plugin, this.file.path, format2);
          }
        }
      }
    };
    this.documentStore = new Store(
      defaultDocumentState(),
      documentReducer,
      this.onViewStoreError
    );
    this.viewStore = new Store(
      defaultViewState(),
      viewReducer,
      this.onViewStoreError
    );
    this.id = id.view();
  }
  get isActive() {
    return this === this.plugin.app.workspace.getActiveViewOfType(_LineageView);
  }
  get isViewOfFile() {
    const path = this.file?.path;
    return path ? this.id === this.plugin.documents.getValue().documents[path]?.viewId : false;
  }
  getViewData() {
    return this.data;
  }
  setViewData(data) {
    if (!this.activeFilePath && this.file) {
      this.activeFilePath = this.file?.path;
      this.loadInitialData();
    } else {
      this.data = data;
      this.loadDocumentToStore();
    }
  }
  async onUnloadFile() {
    if (this.component) {
      this.component.$destroy();
    }
    this.activeFilePath = null;
    this.contentEl.empty();
    this.documentStore = new Store(
      defaultDocumentState(),
      documentReducer,
      this.onViewStoreError
    );
    if (this.inlineEditor)
      await this.inlineEditor.unloadFile();
    for (const s of this.onDestroyCallbacks) {
      s();
    }
    this.deleteBackup();
  }
  clear() {
    this.data = "";
  }
  getViewType() {
    return FILE_VIEW_TYPE;
  }
  getIcon() {
    return customIcons.cards.name;
  }
  getDisplayText() {
    return this.file ? this.file.basename : "";
  }
  async onOpen() {
  }
  /*private destroyStore = () => {
   const leavesOfType = this.plugin.app.workspace
    .getLeavesOfType(FILE_VIEW_TYPE)
    .filter(
     (l) =>
  	   l.view instanceof LineageView &&
  	   l.view.file?.path === this.activeFilePath &&
  	   l.view !== this,
    );
   if (leavesOfType.length === 0) {
    this.store.dispatch({ type: 'RESET_STORE' });
    if (this.file) delete stores[this.file.path];
   }
  };*/
  async onClose() {
    return this.onUnloadFile();
  }
};

// src/stores/settings/subscriptions/effects/update-file-view-type-cache.ts
var fileViewTypeCache = {};
var updateFileViewTypeCache = (state2) => {
  fileViewTypeCache = state2;
};

// src/obsidian/patches/set-view-state.ts
function setViewState(next) {
  return function(state2, ...rest) {
    const isMarkdownView = state2.type === "markdown";
    const path = state2?.state?.file;
    if (isMarkdownView && fileViewTypeCache[path]?.viewType === FILE_VIEW_TYPE && !state2.state.inlineEditor) {
      const newState = {
        ...state2,
        type: FILE_VIEW_TYPE
      };
      return next.apply(this, [newState, ...rest]);
    } else {
      return next.apply(this, [state2, ...rest]);
    }
  };
}

// node_modules/monkey-around/dist/index.mjs
function around(obj, factories) {
  const removers = Object.keys(factories).map((key) => around1(obj, key, factories[key]));
  return removers.length === 1 ? removers[0] : function() {
    removers.forEach((r) => r());
  };
}
function around1(obj, method, createWrapper) {
  const inherited = obj[method], hadOwn = obj.hasOwnProperty(method), original = hadOwn ? inherited : function() {
    return Object.getPrototypeOf(obj)[method].apply(this, arguments);
  };
  let current = createWrapper(original);
  if (inherited)
    Object.setPrototypeOf(current, inherited);
  Object.setPrototypeOf(wrapper, current);
  obj[method] = wrapper;
  return remove;
  function wrapper(...args) {
    if (current === original && obj[method] === wrapper)
      remove();
    return current.apply(this, args);
  }
  function remove() {
    if (obj[method] === wrapper) {
      if (hadOwn)
        obj[method] = original;
      else
        delete obj[method];
    }
    if (current === original)
      return;
    current = original;
    Object.setPrototypeOf(wrapper, inherited || Function);
  }
}

// src/stores/settings/settings-reducer.ts
var updateState2 = (store, action) => {
  if (action.type === "DELETE_DOCUMENT_PREFERENCES") {
    delete store.documents[action.payload.path];
  } else if (action.type === "SET_DOCUMENT_TYPE") {
    if (!store.documents[action.payload.path]) {
      store.documents[action.payload.path] = {
        documentFormat: action.payload.format,
        viewType: "lineage",
        activeSection: null
      };
    } else {
      store.documents[action.payload.path].documentFormat = action.payload.format;
    }
  } else if (action.type === "SET_VIEW_TYPE") {
    if (store.documents[action.payload.path]) {
      store.documents[action.payload.path].viewType = action.payload.type;
    }
  } else if (action.type === "DOCUMENT/SET_ACTIVE_NODE") {
    if (store.documents[action.payload.path]) {
      store.documents[action.payload.path].activeSection = action.payload.sectionNumber;
    }
  } else if (action.type === "HISTORY/UPDATE_DOCUMENT_PATH") {
    const preferences = store.documents[action.payload.oldPath];
    delete store.documents[action.payload.oldPath];
    store.documents[action.payload.newPath] = preferences;
  } else if (action.type === "SET_CUSTOM_HOTKEYS") {
    store.hotkeys.customHotkeys = action.payload.customHotkeys;
  } else if (action.type === "SET_FONT_SIZE") {
    store.view.fontSize = action.payload.fontSize;
  } else if (action.type === "SET_CONTAINER_BG") {
    store.view.theme.containerBg = action.payload.backgroundColor;
  } else if (action.type === "SET_ACTIVE_BRANCH_BG") {
    store.view.theme.activeBranchBg = action.payload.backgroundColor;
  } else if (action.type === "SET_CARD_WIDTH") {
    store.view.cardWidth = action.payload.width;
  } else if (action.type === "SET_MIN_CARD_HEIGHT") {
    store.view.minimumCardHeight = action.payload.height;
  } else if (action.type === "SET_HORIZONTAL_SCROLLING_MODE") {
    store.view.scrolling.horizontalScrollingMode = action.payload.mode;
  } else if (action.type === "UPDATE_AXIS_OFFSET") {
    store.view.scrolling.horizontalOffset = action.payload.relativeClientX;
    store.view.scrolling.verticalOffset = action.payload.relativeClientY;
  } else if (action.type === "SET_LIMIT_PREVIEW_HEIGHT") {
    store.view.limitPreviewHeight = action.payload.limit;
  } else if (action.type === "BACKUP/ADD_FILE") {
    store.backup[action.payload.path] = {
      content: action.payload.content,
      created: Date.now()
    };
  } else if (action.type === "BACKUP/DELETE_FILE") {
    if (store.backup[action.payload.path])
      delete store.backup[action.payload.path];
  } else if (action.type === "UPDATE_DOCUMENTS_DICTIONARY") {
    store.documents = action.payload.documents;
  } else if (action.type === "UI/CHANGE_ZOOM_LEVEL") {
    changeZoomLevel(store, action.payload);
  } else if (action.type === "GENERAL/SET_DEFAULT_DOCUMENT_FORMAT") {
    store.general.defaultDocumentFormat = action.payload.format;
  }
};
var settingsReducer = (store, action) => {
  updateState2(store, action);
  return store;
};

// src/helpers/deep-merge.ts
var isObject2 = (item) => item && typeof item === "object" && !Array.isArray(item);
var deepMerge = (target, ...sources) => {
  if (!sources.length)
    return target;
  const source = sources.shift();
  if (isObject2(target) && isObject2(source)) {
    for (const key in source) {
      if (isObject2(source[key])) {
        if (!target[key])
          Object.assign(target, { [key]: {} });
        deepMerge(target[key], source[key]);
      } else {
        if (typeof target[key] === "undefined")
          Object.assign(target, { [key]: source[key] });
      }
    }
  }
  return deepMerge(target, ...sources);
};

// src/obsidian/events/workspace/register-file-menu-event.ts
var import_obsidian29 = require("obsidian");

// src/obsidian/events/workspace/helpers/get-leaf-of-file.ts
var getLeafOfFile = (plugin, file, viewType) => {
  const leaves = plugin.app.workspace.getLeavesOfType(viewType);
  return leaves.find(
    (l) => l.view?.file?.path === file.path
  );
};

// src/obsidian/events/workspace/effects/toggle-file-view-type.ts
var toggleFileViewType = async (plugin, file, leaf) => {
  const documents = plugin.settings.getValue().documents;
  const preferences = documents[file.path] ? documents[file.path] : null;
  const currentViewType = preferences ? preferences.viewType : "markdown";
  let fileLeaf = leaf || getLeafOfFile(plugin, file, currentViewType);
  if (!fileLeaf)
    fileLeaf = await openFile(plugin, file, "tab");
  const newViewType = currentViewType === "markdown" ? "lineage" : "markdown";
  toggleObsidianViewType(plugin, fileLeaf, newViewType);
  setViewType(plugin, file.path, newViewType);
};

// src/obsidian/events/workspace/context-menu-itetms/add-toggle-view-menu-item.ts
var addToggleViewMenuItem = (menu, plugin, file, leaf) => {
  menu.addItem((item) => {
    const view = leaf?.view;
    if (!view)
      return;
    const isTree = leaf.view.getViewType() === FILE_VIEW_TYPE;
    item.setTitle(isTree ? lang.open_in_editor : lang.open_in_lineage);
    item.setIcon(isTree ? "file-text" : customIcons.cards.name);
    item.onClick(async () => {
      toggleFileViewType(plugin, file, leaf);
    });
  });
};

// src/obsidian/events/workspace/effects/create-lineage-file-in-folder.ts
var createLineageFileInFolder = async (plugin, folder) => {
  const newFile = await createNewFile(plugin, folder);
  if (newFile) {
    const format2 = plugin.settings.getValue().general.defaultDocumentFormat;
    await openFileInLineage(plugin, newFile, format2, "tab");
  }
};

// src/obsidian/events/workspace/context-menu-itetms/add-folder-context-menu-items.ts
var addFolderContextMenuItems = (menu, plugin, folder) => {
  menu.addItem((item) => {
    item.setTitle(lang.new_document);
    item.setIcon(customIcons.cards.name);
    item.onClick(() => createLineageFileInFolder(plugin, folder));
  });
};

// src/obsidian/events/workspace/effects/import-from-gingko/import-from-gingko.ts
var import_obsidian28 = require("obsidian");

// src/obsidian/events/workspace/effects/import-from-gingko/helpers/verify-json-file.ts
var verifyJsonFile = (tree) => {
  for (const treeNode of tree) {
    if (!treeNode)
      return false;
    if (typeof treeNode !== "object")
      return false;
    if (!("content" in treeNode))
      return false;
    if (!("children" in treeNode))
      return false;
    if (typeof treeNode.content !== "string")
      return false;
    if (!Array.isArray(treeNode.children))
      return false;
    if (!verifyJsonFile(treeNode.children))
      return false;
  }
  return true;
};

// src/obsidian/events/workspace/effects/import-from-gingko/helpers/map-files-to-gingko-files.ts
var mapFilesToGingkoFiles = async (plugin, files) => {
  const gingkoFiles = [];
  for (const file of files) {
    const content = await plugin.app.vault.read(file);
    const tree = JSON.parse(content);
    const isValid = verifyJsonFile(tree);
    if (!isValid)
      throw new Error(
        `File "${file.basename}" does not seem to be valid a Gingko file`
      );
    gingkoFiles.push({
      basename: file.basename,
      tree
    });
  }
  return gingkoFiles;
};

// src/obsidian/events/workspace/effects/create-new-folder.ts
var import_obsidian27 = require("obsidian");
var createNewFolder = async (plugin, folder, basename) => {
  invariant(folder);
  const children2 = folder.children.map((c) => c instanceof import_obsidian27.TFolder ? c.name : null).filter((f) => f);
  const path = getUniqueFileName(folder.path, children2, basename);
  const createdFolder = await plugin.app.vault.createFolder(path);
  invariant(createdFolder);
  return createdFolder;
};

// src/obsidian/events/workspace/effects/import-from-gingko/helpers/create-lineage-documents-from-gingko-files.ts
var createLineageDocumentsFromGingkoFiles = async (plugin, files, folderPath) => {
  const parentFolder = plugin.app.vault.getFolderByPath(folderPath);
  invariant(parentFolder);
  let destinationFolder;
  if (files.length === 1) {
    destinationFolder = parentFolder;
  } else {
    destinationFolder = await createNewFolder(
      plugin,
      parentFolder,
      "imported from gingko"
    );
  }
  if (!destinationFolder)
    throw new Error("Could not get destination folder");
  for (const file of files) {
    const sections = jsonToSections(file.tree);
    const createdFile = await createNewFile(
      plugin,
      destinationFolder,
      sections,
      file.basename
    );
    setDocumentFormat(plugin, createdFile.path, "sections");
    setViewType(plugin, createdFile.path, "lineage");
  }
};

// src/obsidian/events/workspace/effects/import-from-gingko/import-from-gingko.ts
var importFromGingko = async (plugin, files) => {
  try {
    const parentFolder = files[0].parent?.path;
    if (!parentFolder)
      return;
    const gingkoFiles = await mapFilesToGingkoFiles(plugin, files);
    await createLineageDocumentsFromGingkoFiles(
      plugin,
      gingkoFiles,
      parentFolder
    );
    new import_obsidian28.Notice(
      `Imported ${gingkoFiles.length} Gingko file${gingkoFiles.length === 1 ? "" : "s"}`
    );
  } catch (e) {
    onPluginError(e, "command", { files });
  }
};

// src/obsidian/events/workspace/context-menu-itetms/add-import-ginkgo-menu-item.ts
var addImportGinkgoMenuItem = (menu, plugin, files) => {
  const allJson = files.every((file) => file.extension === "json");
  if (!allJson)
    return;
  menu.addItem((item) => {
    item.setTitle(lang.import_from_gingko);
    item.setIcon(customIcons.cards.name);
    item.onClick(async () => {
      importFromGingko(plugin, files);
    });
  });
};

// src/obsidian/events/workspace/register-file-menu-event.ts
var registerFileMenuEvent = (plugin) => {
  plugin.registerEvent(
    plugin.app.workspace.on(
      "file-menu",
      (menu, abstractFile, source, leaf) => {
        if (abstractFile instanceof import_obsidian29.TFile) {
          addToggleViewMenuItem(menu, plugin, abstractFile, leaf);
          addImportGinkgoMenuItem(menu, plugin, [abstractFile]);
        } else if (abstractFile instanceof import_obsidian29.TFolder) {
          addFolderContextMenuItems(menu, plugin, abstractFile);
        }
      }
    )
  );
};

// src/obsidian/events/vault/register-file-move-event.ts
var import_obsidian30 = require("obsidian");
var registerFileRenameEvent = (plugin) => {
  plugin.registerEvent(
    plugin.app.vault.on("rename", (file, oldPath) => {
      if (file instanceof import_obsidian30.TFile) {
        if (fileViewTypeCache[oldPath]) {
          plugin.documents.dispatch({
            type: "DOCUMENTS/UPDATE_DOCUMENT_PATH",
            payload: {
              newPath: file.path,
              oldPath
            }
          });
          plugin.settings.dispatch({
            type: "HISTORY/UPDATE_DOCUMENT_PATH",
            payload: {
              newPath: file.path,
              oldPath
            }
          });
        }
      }
    })
  );
};

// src/obsidian/events/vault/register-file-delete-event.ts
var import_obsidian31 = require("obsidian");
var registerFileDeleteEvent = (plugin) => {
  plugin.registerEvent(
    plugin.app.vault.on("delete", (file) => {
      if (file instanceof import_obsidian31.TFile) {
        if (fileViewTypeCache[file.path]) {
          plugin.documents.dispatch({
            type: "DOCUMENTS/DELETE_DOCUMENT",
            payload: {
              path: file.path
            }
          });
          plugin.settings.dispatch({
            type: "DELETE_DOCUMENT_PREFERENCES",
            payload: {
              path: file.path
            }
          });
        }
      }
    })
  );
};

// src/helpers/slugify.ts
var slugify = (inputString) => {
  return inputString.toLowerCase().replace(/[^a-z0-9]/g, "-").replace(/-+/g, "-").replace(/^-|-$/g, "");
};

// src/obsidian/commands/helpers/get-active-file.ts
var getActiveFile = (plugin) => {
  const activeFile = plugin.app.workspace.getActiveFile();
  if (activeFile && activeFile.extension === "md")
    return activeFile;
};

// src/obsidian/events/workspace/effects/create-lineage-document.ts
var createLineageDocument = async (plugin) => {
  try {
    const format2 = plugin.settings.getValue().general.defaultDocumentFormat;
    const file = getActiveFile(plugin);
    let folder = null;
    if (file) {
      folder = file.parent;
    } else {
      folder = plugin.app.vault.getRoot();
    }
    if (folder) {
      const newFile = await createNewFile(plugin, folder);
      if (newFile) {
        await openFileInLineage(plugin, newFile, format2, "tab");
      }
    }
  } catch (e) {
    onPluginError(e, "command", lang.create_new_document);
  }
};

// src/obsidian/commands/add-commands.ts
var createCommands2 = (plugin) => {
  const commands = [];
  commands.push({
    name: lang.toggle_lineage_view,
    icon: customIcons.cards.name,
    checkCallback: (checking) => {
      const file = getActiveFile(plugin);
      if (file) {
        if (checking)
          return true;
        else {
          toggleFileViewType(plugin, file, void 0);
        }
      }
    }
  });
  commands.push({
    name: lang.create_new_document,
    icon: customIcons.cards.name,
    callback: () => createLineageDocument(plugin)
  });
  return commands;
};
var addCommands = (plugin) => {
  const commands = createCommands2(plugin);
  for (const command of commands) {
    plugin.addCommand({
      ...command,
      id: slugify(command.name)
    });
  }
};

// src/stores/hotkeys/hotkey-subscriptions.ts
var hotkeySubscriptions = (plugin) => {
  hotkeyStore.subscribe((state2, action) => {
    if (action) {
      if (action.type === "HOTKEY/RESET" || action.type === "HOTKEY/UPDATE") {
        plugin.settings.dispatch({
          type: "SET_CUSTOM_HOTKEYS",
          payload: {
            customHotkeys: state2.customHotkeys
          }
        });
        hotkeyStore.dispatch({
          type: "SET_CONFLICTING_HOTKEYS",
          payload: {
            conflictingHotkeys: getUsedHotkeys(plugin)
          }
        });
      }
    }
  });
};

// src/stores/settings/subscriptions/settings-subscriptions.ts
var settingsSubscriptions = (plugin) => {
  return plugin.settings.subscribe((state2) => {
    updateFileViewTypeCache(state2.documents);
  });
};

// src/stores/documents/documents-reducer.ts
var updateDocumentsState = (state2, action) => {
  if (action.type === "DOCUMENTS/DELETE_DOCUMENT") {
    const path = action.payload.path;
    if (path in state2.documents) {
      const oldEntry = state2.documents[path];
      oldEntry.documentStore.dispatch({
        type: "RESET_STORE"
      });
      delete state2.documents[path];
    }
  } else if (action.type === "DOCUMENTS/UPDATE_DOCUMENT_PATH") {
    const oldPath = action.payload.oldPath;
    const newPath = action.payload.newPath;
    if (oldPath in state2.documents) {
      const oldEntry = state2.documents[oldPath];
      delete state2.documents[oldPath];
      state2.documents[newPath] = oldEntry;
      oldEntry.documentStore.dispatch({
        type: "FS/SET_FILE_PATH",
        payload: {
          path: newPath
        }
      });
    }
  } else if (action.type === "DOCUMENTS/ADD_DOCUMENT") {
    state2.documents[action.payload.path] = {
      documentStore: action.payload.documentStore,
      viewId: action.payload.viewId
    };
  } else if (action.type === "WORKSPACE/SET_ACTIVE_LINEAGE_VIEW") {
    if (state2.documents[action.payload.path]) {
      state2.documents[action.payload.path].viewId = action.payload.viewId;
    }
  } else if (action.type === "BACKUPS/SET_PROCESSED") {
    state2.processedBackups = true;
  }
};
var documentsReducer = (store, action) => {
  updateDocumentsState(store, action);
  return store;
};

// src/stores/documents/default-documents-state.ts
var DefaultDocumentsState = () => ({
  documents: {},
  processedBackups: false
});

// src/obsidian/status-bar/status-bar.ts
var StatusBar = class {
  constructor(plugin) {
    this.plugin = plugin;
    this.update = (action) => {
      if (action.type === "NUMBER_OF_CARDS") {
        this.elements.numberOfCards.setText(
          action.payload.cards + " card" + (action.payload.cards === 1 ? "" : "s")
        );
      }
    };
    this.onload();
  }
  onload() {
    this.container = this.plugin.addStatusBarItem();
    this.elements = {
      numberOfCards: this.container.createDiv()
    };
    this.plugin.registerEvent(
      this.plugin.app.workspace.on("active-leaf-change", (x) => {
        const visible = Boolean(x && x.view instanceof LineageView);
        this.container.toggleClass("lineage__hidden-element", !visible);
      })
    );
  }
};

// src/stores/documents/subscriptions/effects/process-document-backups/modal/document-backup-modal.ts
var import_obsidian33 = require("obsidian");

// src/stores/documents/subscriptions/effects/process-document-backups/modal/modal-buttons.svelte
function create_fragment75(ctx) {
  let div;
  let button0;
  let t1;
  let button1;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      button0 = element("button");
      button0.textContent = "Delete backup";
      t1 = space();
      button1 = element("button");
      button1.textContent = "Restore backup";
      attr(button0, "class", "mod-warning");
      attr(button1, "class", "mod-cta");
      attr(div, "class", "modal-button-container");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, button0);
      append(div, t1);
      append(div, button1);
      if (!mounted) {
        dispose = [
          listen(button0, "click", function() {
            if (is_function(
              /*callbacks*/
              ctx[0].reject
            ))
              ctx[0].reject.apply(this, arguments);
          }),
          listen(button1, "click", function() {
            if (is_function(
              /*callbacks*/
              ctx[0].accept
            ))
              ctx[0].accept.apply(this, arguments);
          })
        ];
        mounted = true;
      }
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance73($$self, $$props, $$invalidate) {
  let { callbacks } = $$props;
  $$self.$$set = ($$props2) => {
    if ("callbacks" in $$props2)
      $$invalidate(0, callbacks = $$props2.callbacks);
  };
  return [callbacks];
}
var Modal_buttons2 = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance73, create_fragment75, safe_not_equal, { callbacks: 0 });
  }
};
var modal_buttons_default2 = Modal_buttons2;

// src/stores/documents/subscriptions/effects/process-document-backups/modal/modal-content.svelte
var import_obsidian32 = require("obsidian");
function add_css34(target) {
  append_styles(target, "svelte-1ho9qqp", "code.svelte-1ho9qqp{background-color:var(--color-base-40);padding:2px 4px}");
}
function get_each_context12(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[4] = list[i];
  return child_ctx;
}
function create_each_block12(ctx) {
  let div;
  let code;
  let t0_value = (
    /*line*/
    ctx[4] + ""
  );
  let t0;
  let t1;
  return {
    c() {
      div = element("div");
      code = element("code");
      t0 = text(t0_value);
      t1 = space();
      attr(code, "class", "svelte-1ho9qqp");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, code);
      append(code, t0);
      append(div, t1);
    },
    p(ctx2, dirty) {
      if (dirty & /*backup*/
      2 && t0_value !== (t0_value = /*line*/
      ctx2[4] + ""))
        set_data(t0, t0_value);
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
function create_fragment76(ctx) {
  let p0;
  let t0;
  let a;
  let t1;
  let t2;
  let t3;
  let div;
  let t4;
  let p1;
  let t5;
  let t6_value = relativeTime(
    /*backup*/
    ctx[1].created
  ).toLowerCase() + "";
  let t6;
  let t7;
  let mounted;
  let dispose;
  let each_value = ensure_array_like(
    /*backup*/
    ctx[1].content.split("\n")
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block12(get_each_context12(ctx, each_value, i));
  }
  return {
    c() {
      p0 = element("p");
      t0 = text("A backup of ");
      a = element("a");
      t1 = text(
        /*path*/
        ctx[0]
      );
      t2 = text(" was found.");
      t3 = space();
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t4 = space();
      p1 = element("p");
      t5 = text("The backup was created ");
      t6 = text(t6_value);
      t7 = text(".");
      set_style(div, "width", "100%");
      set_style(div, "max-height", "400px");
      set_style(div, "overflow", "auto");
    },
    m(target, anchor) {
      insert(target, p0, anchor);
      append(p0, t0);
      append(p0, a);
      append(a, t1);
      append(p0, t2);
      insert(target, t3, anchor);
      insert(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div, null);
        }
      }
      insert(target, t4, anchor);
      insert(target, p1, anchor);
      append(p1, t5);
      append(p1, t6);
      append(p1, t7);
      if (!mounted) {
        dispose = listen(
          a,
          "click",
          /*openPath*/
          ctx[2]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*path*/
      1)
        set_data(
          t1,
          /*path*/
          ctx2[0]
        );
      if (dirty & /*backup*/
      2) {
        each_value = ensure_array_like(
          /*backup*/
          ctx2[1].content.split("\n")
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context12(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block12(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(div, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (dirty & /*backup*/
      2 && t6_value !== (t6_value = relativeTime(
        /*backup*/
        ctx2[1].created
      ).toLowerCase() + ""))
        set_data(t6, t6_value);
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(p0);
        detach(t3);
        detach(div);
        detach(t4);
        detach(p1);
      }
      destroy_each(each_blocks, detaching);
      mounted = false;
      dispose();
    }
  };
}
function instance74($$self, $$props, $$invalidate) {
  let { path } = $$props;
  let { backup } = $$props;
  let { plugin } = $$props;
  const openPath = () => {
    const file = plugin.app.vault.getAbstractFileByPath(path);
    if (file && file instanceof import_obsidian32.TFile)
      openFile(plugin, file, "split");
  };
  $$self.$$set = ($$props2) => {
    if ("path" in $$props2)
      $$invalidate(0, path = $$props2.path);
    if ("backup" in $$props2)
      $$invalidate(1, backup = $$props2.backup);
    if ("plugin" in $$props2)
      $$invalidate(3, plugin = $$props2.plugin);
  };
  return [path, backup, openPath, plugin];
}
var Modal_content2 = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance74, create_fragment76, safe_not_equal, { path: 0, backup: 1, plugin: 3 }, add_css34);
  }
};
var modal_content_default2 = Modal_content2;

// src/stores/documents/subscriptions/effects/process-document-backups/modal/document-backup-modal.ts
var DocumentBackupModal = class extends import_obsidian33.Modal {
  constructor(props) {
    super(props.plugin.app);
    this.props = props;
    this.open = () => {
      this.setTitle("Lineage - Document backup");
      const fragment = document.createDocumentFragment();
      fragment.append();
      new modal_buttons_default2({
        target: this.contentEl.parentElement,
        props: {
          callbacks: this.props.callbacks
        }
      });
      new modal_content_default2({
        target: this.contentEl,
        props: this.props
      });
      const promise = new Promise((resolve) => {
        this.resolve = resolve;
      });
      super.open();
      return promise;
    };
    this.close = () => {
      this.resolve(void 0);
      super.close();
    };
  }
};

// src/stores/documents/subscriptions/effects/process-document-backups/helpers/restore-backup.ts
var import_obsidian34 = require("obsidian");
var restoreBackup = async (plugin, backup, path) => {
  const pathParts = path.split("/");
  const maybeFileName = pathParts.pop();
  if (!maybeFileName || !maybeFileName.endsWith(".md"))
    throw new Error("invalid backup path: " + path);
  const fileName = maybeFileName.replace(/\.md$/, "") + " - backup";
  const folderPath = pathParts.join("/");
  let folder;
  const maybeFolder = plugin.app.vault.getAbstractFileByPath(folderPath);
  if (maybeFolder instanceof import_obsidian34.TFolder) {
    folder = maybeFolder;
  } else {
    folder = plugin.app.vault.getRoot();
  }
  const newFile = await createNewFile(
    plugin,
    folder,
    backup.content,
    fileName
  );
  await openFile(plugin, newFile, "split");
};

// src/stores/documents/subscriptions/effects/process-document-backups/process-document-backups.ts
var import_obsidian35 = require("obsidian");
var processDocumentBackups = async (plugin) => {
  const deleteBackup = (path) => {
    plugin.settings.dispatch({
      type: "BACKUP/DELETE_FILE",
      payload: {
        path
      }
    });
  };
  const backups = plugin.settings.getValue().backup;
  for (const [path, backup] of Object.entries(backups)) {
    const file = plugin.app.vault.getAbstractFileByPath(path);
    if (file && file instanceof import_obsidian35.TFile) {
      const content = await plugin.app.vault.read(file);
      if (content === backup.content) {
        deleteBackup(path);
        continue;
      }
    }
    if (!file)
      continue;
    const modal = new DocumentBackupModal({
      plugin,
      callbacks: {
        accept: () => {
          restoreBackup(plugin, backup, path).then(() => {
            deleteBackup(path);
            modal.close();
          });
        },
        reject: () => {
          deleteBackup(path);
          modal.close();
        }
      },
      path,
      backup
    });
    await modal.open();
  }
  plugin.documents.dispatch({ type: "BACKUPS/SET_PROCESSED" });
};

// src/stores/documents/subscriptions/effects/remove-obsolete-documents/helpers/filter-obsolete-documents.ts
var filterObsoleteDocuments = (settings, allFiles) => {
  if (allFiles.size === 0)
    return 0;
  const paths = Object.keys(settings.documents);
  const deletedPaths = /* @__PURE__ */ new Set();
  for (const path of paths) {
    if (!allFiles.has(path)) {
      deletedPaths.add(path);
      delete settings.documents[path];
    }
  }
  return deletedPaths.size;
};

// src/stores/documents/subscriptions/effects/remove-obsolete-documents/helpers/get-all-loaded-files.ts
var import_obsidian36 = require("obsidian");
var getAllLoadedFiles = (plugin) => {
  const allFiles = plugin.app.vault.getAllLoadedFiles();
  const allPaths = /* @__PURE__ */ new Set();
  for (const maybeFile of allFiles) {
    if (maybeFile instanceof import_obsidian36.TFile) {
      allPaths.add(maybeFile.path);
    }
  }
  return allPaths;
};

// src/stores/documents/subscriptions/effects/remove-obsolete-documents.ts
var removeObsoleteDocuments = (plugin) => {
  const settings = plugin.settings.getValue();
  const allLoadedFiles = getAllLoadedFiles(plugin);
  const deleted = filterObsoleteDocuments(settings, allLoadedFiles);
  if (deleted === 0)
    return;
  logger.debug(`[lineage] removed ${deleted} from settings.documents`);
  plugin.settings.dispatch({
    type: "UPDATE_DOCUMENTS_DICTIONARY",
    payload: {
      documents: settings.documents
    }
  });
};

// src/stores/documents/subscriptions/documents-store-subscriptions.ts
var documentsStoreSubscriptions = (plugin) => {
  return plugin.documents.subscribe((_, action) => {
    if (action?.type === "WORKSPACE/LAYOUT_READY") {
      processDocumentBackups(plugin);
      setTimeout(() => removeObsoleteDocuments(plugin), 1e3 * 60 * 5);
    }
  });
};

// src/obsidian/events/workspace/actions/set-active-lineage-view.ts
var setActiveLineageView = (view) => {
  invariant(view.file);
  view.plugin.documents.dispatch({
    type: "WORKSPACE/SET_ACTIVE_LINEAGE_VIEW",
    payload: {
      path: view.file?.path,
      viewId: view.id
    }
  });
};

// src/obsidian/events/workspace/actions/set-active-leaf-changed.ts
var setActiveLeafChanged = (plugin) => {
  plugin.documents.dispatch({
    type: "WORKSPACE/ACTIVE_LEAF_CHANGE"
  });
};

// src/obsidian/events/workspace/register-active-leaf-change.ts
var registerActiveLeafChange = (plugin) => {
  plugin.registerEvent(
    plugin.app.workspace.on("active-leaf-change", (leaf) => {
      if (leaf?.view instanceof LineageView && leaf.view.file?.path) {
        setActiveLineageView(leaf.view);
      }
      setActiveLeafChanged(plugin);
    })
  );
};

// src/obsidian/events/workspace/actions/on-workspace-resize.ts
var onWorkspaceResize = (plugin) => {
  plugin.documents.dispatch({
    type: "WORKSPACE/RESIZE"
  });
};

// src/obsidian/events/workspace/register-workspace-resize.ts
var registerWorkspaceResize = (plugin) => {
  plugin.registerEvent(
    plugin.app.workspace.on("resize", () => {
      onWorkspaceResize(plugin);
    })
  );
};

// src/obsidian/events/workspace/actions/set-workspace-layout-ready.ts
var setWorkspaceLayoutReady = (plugin) => {
  plugin.documents.dispatch({
    type: "WORKSPACE/LAYOUT_READY"
  });
};

// src/obsidian/events/workspace/register-layout-ready.ts
var registerLayoutReady = (plugin) => {
  plugin.app.workspace.onLayoutReady(() => {
    setWorkspaceLayoutReady(plugin);
  });
};

// src/obsidian/patches/set-active-leaf.ts
function setActiveLeaf(next) {
  return function(leaf, param) {
    const isLineageViewAndIsEditing = leaf.view && leaf.view instanceof LineageView && leaf.view.inlineEditor.activeNode;
    if (isLineageViewAndIsEditing)
      return;
    return next.call(this, leaf, param);
  };
}

// src/stores/settings/migrations/migrate-document-preferences.ts
var migrateDocumentPreferences = (settings) => {
  for (const [path, pref] of Object.entries(settings.documents)) {
    if (typeof pref === "boolean") {
      settings.documents[path] = {
        documentFormat: "sections",
        viewType: "lineage",
        activeSection: null
      };
    }
  }
};

// src/obsidian/events/workspace/register-files-menu-event.ts
var import_obsidian37 = require("obsidian");
var registerFilesMenuEvent = (plugin) => {
  plugin.registerEvent(
    plugin.app.workspace.on("files-menu", (menu, abstractFile) => {
      const allFiles = abstractFile.every((af) => af instanceof import_obsidian37.TFile);
      if (allFiles)
        addImportGinkgoMenuItem(menu, plugin, abstractFile);
    })
  );
};

// src/main.ts
var Lineage = class extends import_obsidian38.Plugin {
  async onload() {
    await this.loadSettings();
    this.documents = new Store(
      DefaultDocumentsState(),
      documentsReducer,
      onPluginError
    );
    loadCustomIcons();
    this.registerView(
      FILE_VIEW_TYPE,
      (leaf) => new LineageView(leaf, this)
    );
    this.registerPatches();
    this.registerEffects();
    this.registerEvents();
    addCommands(this);
    loadCommands(this);
    this.statusBar = new StatusBar(this);
    this.loadRibbonIcon();
  }
  async saveSettings() {
    await this.saveData(this.settings.getValue());
  }
  async loadSettings() {
    const rawSettings = await this.loadData() || {};
    const settings = deepMerge(rawSettings, DEFAULT_SETTINGS());
    migrateDocumentPreferences(settings);
    this.settings = new Store(
      settings,
      settingsReducer,
      onPluginError
    );
    this.settings.subscribe(() => {
      this.saveSettings();
    });
    settingsSubscriptions(this);
  }
  registerEvents() {
    registerFileMenuEvent(this);
    registerFilesMenuEvent(this);
    registerFileRenameEvent(this);
    registerFileDeleteEvent(this);
    registerActiveLeafChange(this);
    registerWorkspaceResize(this);
    registerLayoutReady(this);
  }
  registerEffects() {
    hotkeySubscriptions(this);
    documentsStoreSubscriptions(this);
  }
  registerPatches() {
    this.register(around(this.app.workspace, { setActiveLeaf }));
    this.register(around(import_obsidian38.WorkspaceLeaf.prototype, { setViewState }));
  }
  loadRibbonIcon() {
    this.addRibbonIcon(
      customIcons.cards.name,
      "Toggle Lineage view",
      () => {
        const file = getActiveFile(this);
        if (file)
          toggleFileViewType(this, file, void 0);
        else
          createLineageDocument(this);
      }
    );
  }
};
/*! Bundled license information:

classnames/index.js:
  (*!
  	Copyright (c) 2018 Jed Watson.
  	Licensed under the MIT License (MIT), see
  	http://jedwatson.github.io/classnames
  *)

lucide-svelte/dist/defaultAttributes.js:
  (**
   * @license lucide-svelte v0.344.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/arrow-left.svelte:
  (**
   * @license lucide-svelte v0.344.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/arrow-right.svelte:
  (**
   * @license lucide-svelte v0.344.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/chevron-down.svelte:
  (**
   * @license lucide-svelte v0.344.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/chevron-right.svelte:
  (**
   * @license lucide-svelte v0.344.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/chevron-up.svelte:
  (**
   * @license lucide-svelte v0.344.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/clipboard-paste.svelte:
  (**
   * @license lucide-svelte v0.344.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/file-minus.svelte:
  (**
   * @license lucide-svelte v0.344.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/file-output.svelte:
  (**
   * @license lucide-svelte v0.344.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/file-pen.svelte:
  (**
   * @license lucide-svelte v0.344.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/file-plus.svelte:
  (**
   * @license lucide-svelte v0.344.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/file-symlink.svelte:
  (**
   * @license lucide-svelte v0.344.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/file-up.svelte:
  (**
   * @license lucide-svelte v0.344.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/heading-1.svelte:
  (**
   * @license lucide-svelte v0.344.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/history.svelte:
  (**
   * @license lucide-svelte v0.344.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/keyboard.svelte:
  (**
   * @license lucide-svelte v0.344.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/maximize.svelte:
  (**
   * @license lucide-svelte v0.344.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/merge.svelte:
  (**
   * @license lucide-svelte v0.344.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/minus.svelte:
  (**
   * @license lucide-svelte v0.344.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/more-vertical.svelte:
  (**
   * @license lucide-svelte v0.344.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/pen.svelte:
  (**
   * @license lucide-svelte v0.344.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/pencil.svelte:
  (**
   * @license lucide-svelte v0.344.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/plus.svelte:
  (**
   * @license lucide-svelte v0.344.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/redo-2.svelte:
  (**
   * @license lucide-svelte v0.344.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/rotate-ccw.svelte:
  (**
   * @license lucide-svelte v0.344.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/save.svelte:
  (**
   * @license lucide-svelte v0.344.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/scissors.svelte:
  (**
   * @license lucide-svelte v0.344.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/search.svelte:
  (**
   * @license lucide-svelte v0.344.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/settings.svelte:
  (**
   * @license lucide-svelte v0.344.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/split.svelte:
  (**
   * @license lucide-svelte v0.344.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/text.svelte:
  (**
   * @license lucide-svelte v0.344.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/trash.svelte:
  (**
   * @license lucide-svelte v0.344.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/undo-2.svelte:
  (**
   * @license lucide-svelte v0.344.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/x.svelte:
  (**
   * @license lucide-svelte v0.344.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/index.js:
  (**
   * @license lucide-svelte v0.344.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/aliases.js:
  (**
   * @license lucide-svelte v0.344.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)
*/
